
main.elf:     file format elf32-littlearm

SYMBOL TABLE:
08000000 l    d  .isr_vector	00000000 .isr_vector
0800010c l    d  .text	00000000 .text
0800218c l    d  .rodata	00000000 .rodata
08002574 l    d  .init_array	00000000 .init_array
0800257c l    d  .fini_array	00000000 .fini_array
20000000 l    d  .data	00000000 .data
20000670 l    d  .bss	00000000 .bss
20001054 l    d  ._user_heap_stack	00000000 ._user_heap_stack
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 /tmp/ccKQCY0E.o
f108f85f l       *ABS*	00000000 BootRAM
0800105c l       .text	00000000 LoopCopyDataInit
08001054 l       .text	00000000 CopyDataInit
08001070 l       .text	00000000 LoopFillZerobss
0800106a l       .text	00000000 FillZerobss
08001094 l       .text	00000000 Infinite_Loop
00000000 l    df *ABS*	00000000 crtstuff.c
08002174 l     O .text	00000000 __EH_FRAME_BEGIN__
0800010c l     F .text	00000000 __do_global_dtors_aux
20000670 l       .bss	00000000 completed.8603
0800257c l     O .fini_array	00000000 __do_global_dtors_aux_fini_array_entry
08000130 l     F .text	00000000 frame_dummy
20000674 l       .bss	00000000 object.8608
08002578 l     O .init_array	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 stm32f10x_gpio.c
00000000 l    df *ABS*	00000000 misc.c
00000000 l    df *ABS*	00000000 stm32f10x_rcc.c
20000000 l     O .data	00000010 APBAHBPrescTable
20000010 l     O .data	00000004 ADCPrescTable
00000000 l    df *ABS*	00000000 stm32f10x_usart.c
00000000 l    df *ABS*	00000000 lib_a-strcmp.o
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 stm32f10x_it.c
00000000 l    df *ABS*	00000000 system_stm32f10x.c
00000000 l    df *ABS*	00000000 io_cfg.c
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 tasks.c
0800111c l     F .text	00000014 prvIdleTask
08001130 l     F .text	00000024 prvResetNextTaskUnblockTime
08001154 l     F .text	00000050 prvAddCurrentTaskToDelayedList
20000690 l     O .bss	00000004 xNumOfOverflows
20000694 l     O .bss	00000004 pxDelayedTaskList
20000698 l     O .bss	00000004 xSchedulerRunning
2000069c l     O .bss	00000014 xDelayedTaskList1
200006b0 l     O .bss	00000014 xDelayedTaskList2
200006c4 l     O .bss	00000004 uxPendedTicks
200006c8 l     O .bss	00000064 pxReadyTasksLists
2000072c l     O .bss	00000004 uxSchedulerSuspended
20000734 l     O .bss	00000014 xPendingReadyList
20000748 l     O .bss	00000004 xTickCount
2000074c l     O .bss	00000004 pxOverflowDelayedTaskList
20000750 l     O .bss	00000004 uxTaskNumber
20000754 l     O .bss	00000004 uxCurrentNumberOfTasks
20000018 l     O .data	00000004 xNextTaskUnblockTime
20000758 l     O .bss	00000014 xSuspendedTaskList
2000076c l     O .bss	00000004 uxTopReadyPriority
20000770 l     O .bss	00000004 xYieldPending
00000000 l    df *ABS*	00000000 port.c
08001640 l     F .text	00000018 prvPortStartFirstTask
080016c4 l     F .text	0000001c prvTaskExitError
08001698 l       .text	00000000 pxCurrentTCBConst2
08001768 l       .text	00000000 pxCurrentTCBConst
20000774 l     O .bss	00000001 ucMaxSysCallPriority
20000778 l     O .bss	00000004 ulMaxPRIGROUPValue
2000001c l     O .data	00000004 uxCriticalNesting
00000000 l    df *ABS*	00000000 heap_1.c
2000077c l     O .bss	00000004 xNextFreeByte
20000780 l     O .bss	00000004 pucAlignedHeap.4761
20000784 l     O .bss	00000800 ucHeap
00000000 l    df *ABS*	00000000 utils.c
00000000 l    df *ABS*	00000000 xprintf.c
00000000 l    df *ABS*	00000000 cmd_line.c
00000000 l    df *ABS*	00000000 sys_cfg.c
00000000 l    df *ABS*	00000000 shell.c
08001c6c l     F .text	00000002 shell_reboot
08001c6e l     F .text	00000004 shell_ram
08001c74 l     F .text	00000010 shell_fatal
08001c84 l     F .text	00000010 shell_ver
08001c94 l     F .text	00000010 shell_reset
08001ca4 l     F .text	00000004 shell_set_calib
08001ca8 l     F .text	00000004 shell_help
08001cac l     F .text	00000004 shell_flash
08001cb0 l     F .text	00000004 shell_pop
08001cb4 l     F .text	00000004 shell_out
08001cb8 l     F .text	00000004 shell_mode
08001cbc l     F .text	00000004 shell_sensor
08001cc0 l     F .text	00000004 shell_cfg
08001cc4 l     F .text	0000014c shell_modbus_rs485
20000f84 l     O .bss	00000028 str_list
20000fac l     O .bss	00000001 str_list_len
20000fad l     O .bss	00000080 cmd_buffer
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strtol.c
08001ed4 l     F .text	00000136 _strtol_l.isra.0
00000000 l    df *ABS*	00000000 __call_atexit.c
08002038 l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 locale.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 /home/fanning/workspace/tools/gcc-arm-none-eabi-5_4-2016q3/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7-m/crti.o
00000000 l    df *ABS*	00000000 /home/fanning/workspace/tools/gcc-arm-none-eabi-5_4-2016q3/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7-m/crtn.o
00000000 l    df *ABS*	00000000 impure.c
200000d8 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 
08002580 l       .fini_array	00000000 __fini_array_end
20000670 l       .bss	00000000 __bss_start__
20001054 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
0800257c l       .fini_array	00000000 __fini_array_start
0800257c l       .init_array	00000000 __init_array_end
00000000 l       *UND*	00000000 hardware_init_hook
08002574 l       .init_array	00000000 __preinit_array_end
00000000 l       *UND*	00000000 __stack
08002574 l       .init_array	00000000 __init_array_start
00000000 l       *UND*	00000000 _exit
08002574 l       .init_array	00000000 __preinit_array_start
00000000 l       *UND*	00000000 free
08001094  w    F .text	00000002 EXTI2_IRQHandler
08000b38 g     F .text	00000012 USART_SetGuardTime
080005c4 g     F .text	0000000c RCC_HSICmd
08001e18 g     F .text	000000ba strcpy
080005e4 g     F .text	0000000c RCC_PLLCmd
08000374 g     F .text	0000001c GPIO_EventOutputConfig
08001bc8 g     F .text	00000050 sys_irq_shell
08001094  w    F .text	00000002 DebugMon_Handler
08000e64 g     F .text	00000024 systemConsole
080018f0 g     F .text	0000012c xstream
08000874 g     F .text	0000000c RCC_ClearITPendingBit
08001704 g     F .text	00000024 vPortExitCritical
08000338 g     F .text	0000000c GPIO_ReadOutputDataBit
08001094  w    F .text	00000002 TIM1_CC_IRQHandler
08000ef0 g     F .text	00000002 HardFault_Handler
080016b4 g     F .text	00000010 ulPortSetInterruptMask
00000080 g       *ABS*	00000000 _Min_Stack_Size
0800176c g     F .text	00000024 SysTick_Handler
08000810 g     F .text	0000000c RCC_MCOConfig
08000454 g     F .text	0000006c NVIC_Init
08001094  w    F .text	00000002 PVD_IRQHandler
08002580 g       *ABS*	00000000 _sidata
08001728 g     F .text	00000044 PendSV_Handler
08000eee g     F .text	00000002 NMI_Handler
08002574 g       .init_array	00000000 __exidx_end
08001094  w    F .text	00000002 EXTI3_IRQHandler
08000650 g     F .text	0000001c RCC_ITConfig
20000730 g     O .bss	00000004 pxCurrentTCB
08000b60 g     F .text	0000001a USART_SmartCardCmd
08000c20 g     F .text	0000000c USART_GetFlagStatus
0800218c g       .text	00000000 _etext
20000670 g       .bss	00000000 _sbss
080005f0 g     F .text	00000014 RCC_SYSCLKConfig
0800057c g     F .text	00000034 RCC_WaitForHSEStartUp
08000a9c g     F .text	00000016 USART_SetAddress
08000390 g     F .text	0000000c GPIO_EventOutputCmd
08000b4c g     F .text	00000012 USART_SetPrescaler
08000e48 g     F .text	0000001c task_life
080007f8 g     F .text	0000000c RCC_BackupResetCmd
08000bd0 g     F .text	0000001a USART_OneBitMethodCmd
080017b8 g     F .text	00000090 xPortStartScheduler
2000102d g     O .bss	00000021 shell
080004c0 g     F .text	00000014 NVIC_SetVectorTable
080011a4 g     F .text	00000194 xTaskGenericCreate
0800039c g     F .text	0000006c GPIO_PinRemapConfig
08001790  w    F .text	00000028 vPortSetupTimerInterrupt
08000804 g     F .text	0000000c RCC_ClockSecuritySystemCmd
08001094  w    F .text	00000002 EXTI0_IRQHandler
08001094  w    F .text	00000002 I2C2_EV_IRQHandler
08000850 g     F .text	00000010 RCC_ClearFlag
08001898 g     F .text	0000000c vPortFree
20000014 g     O .data	00000004 SystemCoreClock
08000b24 g     F .text	00000008 USART_ReceiveData
08000544 g     F .text	00000038 RCC_HSEConfig
00000000  w      *UND*	00000000 malloc
08001094  w    F .text	00000002 UsageFault_Handler
08000788 g     F .text	0000001c RCC_APB2PeriphClockCmd
080010b2 g     F .text	00000018 vListInsertEnd
08001094  w    F .text	00000002 ADC1_2_IRQHandler
0800025c g     F .text	000000b8 GPIO_Init
080005d0 g     F .text	00000014 RCC_PLLConfig
08000678 g     F .text	00000014 RCC_ADCCLKConfig
20001050 g     O .bss	00000004 xfunc_out
20000000 g       .data	00000000 _sdata
08001094  w    F .text	00000002 SPI1_IRQHandler
08000a34 g     F .text	0000001a USART_Cmd
08000244 g     F .text	00000016 GPIO_AFIODeInit
08000c04 g     F .text	0000001a USART_IrDACmd
080004ec g     F .text	00000018 SysTick_CLKSourceConfig
08001094  w    F .text	00000002 TAMPER_IRQHandler
08000360 g     F .text	00000004 GPIO_Write
08000344 g     F .text	00000006 GPIO_ReadOutputData
080010ac g     F .text	00000006 vListInitialiseItem
0800068c g     F .text	00000020 RCC_LSEConfig
08000c7c g     F .text	00000010 USART_ClearITPendingBit
080006c8 g     F .text	0000000c RCC_RTCCLKCmd
080016fc g     F .text	00000006 vPortClearInterruptMask
080007a4 g     F .text	0000001c RCC_APB1PeriphClockCmd
08000860 g     F .text	00000014 RCC_GetITStatus
08002574 g       .init_array	00000000 __exidx_start
08002458 g     O .rodata	00000004 _global_impure_ptr
0800076c g     F .text	0000001c RCC_AHBPeriphClockCmd
08001094  w    F .text	00000002 DMA1_Channel4_IRQHandler
08001848 g     F .text	00000050 pvPortMalloc
08000e98 g     F .text	00000044 vTaskInit
08000bb4 g     F .text	0000001a USART_OverSampling8Cmd
08002174 g     F .text	00000000 _init
08001096 g     F .text	00000016 vListInitialise
0800200c g     F .text	0000002c strtol
08001a1c g     F .text	00000024 xprintf
08001094  w    F .text	00000002 USART3_IRQHandler
08002058 g     F .text	00000028 __libc_fini_array
08001094  w    F .text	00000002 RTC_IRQHandler
20001054 g       .bss	00000000 _ebss
08000c34 g     F .text	00000048 USART_GetITStatus
08001038 g     F .text	0000000c led_life_on
08001094  w    F .text	00000002 DMA1_Channel7_IRQHandler
08001050  w    F .text	00000030 Reset_Handler
08000330 g     F .text	00000006 GPIO_ReadInputData
08000ae8 g     F .text	00000016 USART_LINBreakDetectLengthConfig
08001094  w    F .text	00000002 CAN1_RX1_IRQHandler
08001008 g     F .text	00000030 led_life_init
0800081c g     F .text	00000034 RCC_GetFlagStatus
0800034c g     F .text	00000004 GPIO_SetBits
08001094  w    F .text	00000002 TIM4_IRQHandler
08000604 g     F .text	00000010 RCC_GetSYSCLKSource
08000354 g     F .text	0000000a GPIO_WriteBit
08000e88 g     F .text	0000000e prvSetupHardware
00000000  w      *UND*	00000000 __deregister_frame_info
08001094  w    F .text	00000002 I2C1_EV_IRQHandler
08000434 g     F .text	0000000c GPIO_ETH_MediaInterfaceConfig
2000068c g     O .bss	00000001 cmd_flag
08001abc g     F .text	0000001c xputchar
080006d4 g     F .text	00000098 RCC_GetClocksFreq
08001094  w    F .text	00000002 DMA1_Channel6_IRQHandler
08000930 g     F .text	000000bc USART_Init
08001094  w    F .text	00000002 TIM3_IRQHandler
08001094  w    F .text	00000002 RCC_IRQHandler
08001094  w    F .text	00000002 TIM1_TRG_COM_IRQHandler
00000000 g       *ABS*	00000000 _Min_Heap_Size
08001094  w    F .text	00000002 DMA1_Channel1_IRQHandler
08001094 g       .text	00000002 Default_Handler
0800138c g     F .text	00000010 vTaskSuspendAll
08000b98 g     F .text	0000001a USART_HalfDuplexCmd
080006b8 g     F .text	00000010 RCC_RTCCLKConfig
080010fa g     F .text	00000020 uxListRemove
08001094  w    F .text	00000002 EXTI15_10_IRQHandler
080020d0 g     F .text	000000a4 __register_exitproc
08000a50 g     F .text	00000038 USART_ITConfig
080015cc g     F .text	00000074 vTaskSwitchContext
08000350 g     F .text	00000004 GPIO_ResetBits
08000bec g     F .text	00000016 USART_IrDAConfig
08001094  w    F .text	00000002 EXTI9_5_IRQHandler
08000408 g     F .text	0000002c GPIO_EXTILineConfig
080018a4 g     F .text	00000028 str_cmp
08001044 g     F .text	0000000c led_life_off
0800169c g     F .text	00000018 vPortYield
08000880 g     F .text	000000b0 USART_DeInit
08001094  w    F .text	00000002 SPI2_IRQHandler
08001094  w    F .text	00000002 MemManage_Handler
080005b0 g     F .text	00000014 RCC_AdjustHSICalibrationValue
08000edc g     F .text	00000012 main
08000a04 g     F .text	00000022 USART_ClockInit
08001ad8 g     F .text	000000cc sys_cfg_console
080010ca g     F .text	00000030 vListInsert
08001678 g     F .text	00000024 SVC_Handler
08000b2c g     F .text	0000000c USART_SendBreak
080020b4 g     F .text	0000001a __ascii_wctomb
08000628 g     F .text	00000014 RCC_PCLK1Config
00000000  w      *UND*	00000000 __libc_fini
08001094  w    F .text	00000002 DMA1_Channel5_IRQHandler
0800066c g     F .text	0000000c RCC_USBCLKConfig
08001094  w    F .text	00000002 EXTI4_IRQHandler
08001094  w    F .text	00000002 USB_LP_CAN1_RX0_IRQHandler
0800063c g     F .text	00000014 RCC_PCLK2Config
08000c8c g     F .text	000001ba strcmp
08000c2c g     F .text	00000008 USART_ClearFlag
08000f14 g     F .text	000000f4 SystemInit
080018cc g     F .text	00000024 xputc
08000168 g     F .text	000000dc GPIO_DeInit
08002180 g     F .text	00000000 _fini
080014b8 g     F .text	000000cc xTaskResumeAll
08001094  w    F .text	00000002 USB_HP_CAN1_TX_IRQHandler
08001338 g     F .text	00000054 vTaskStartScheduler
08000504 g     F .text	00000040 RCC_DeInit
0800204c g     F .text	0000000c atexit
08001094  w    F .text	00000002 DMA1_Channel3_IRQHandler
20000020 g     O .data	000000b4 lgn_cmd_table
08001c18 g     F .text	00000054 task_shell
20000500 g     O .data	00000004 _impure_ptr
08001094  w    F .text	00000002 TIM1_UP_IRQHandler
080004d4 g     F .text	00000018 NVIC_SystemLPConfig
08001094  w    F .text	00000002 WWDG_IRQHandler
080007dc g     F .text	0000001c RCC_APB1PeriphResetCmd
08002088 g     F .text	0000002a __ascii_mbtowc
08001094  w    F .text	00000002 TIM2_IRQHandler
08000ab4 g     F .text	00000016 USART_WakeUpConfig
08000314 g     F .text	00000010 GPIO_StructInit
0800139c g     F .text	0000011c xTaskIncrementTick
08001094  w    F .text	00000002 TIM1_BRK_IRQHandler
08000b1c g     F .text	00000008 USART_SendData
20002000 g       *ABS*	00000000 _estack
08001094  w    F .text	00000002 EXTI1_IRQHandler
20000670 g       .data	00000000 _edata
08000acc g     F .text	0000001a USART_ReceiverWakeUpCmd
080009ec g     F .text	00000016 USART_StructInit
08001094  w    F .text	00000002 RTCAlarm_IRQHandler
08001ba4 g     F .text	00000024 sys_ctrl_shell_get_char
08001094  w    F .text	00000002 USART2_IRQHandler
08000b7c g     F .text	0000001a USART_SmartCardNACKCmd
08000000 g     O .isr_vector	00000000 g_pfnVectors
08000b00 g     F .text	0000001a USART_LINCmd
08001094  w    F .text	00000002 I2C2_ER_IRQHandler
08001584 g     F .text	00000048 vTaskDelay
08001094  w    F .text	00000002 DMA1_Channel2_IRQHandler
08001e10 g     F .text	00000008 atoi
08002470 g     O .rodata	00000101 _ctype_
08001094  w    F .text	00000002 CAN1_SCE_IRQHandler
08001094  w    F .text	00000002 FLASH_IRQHandler
08000364 g     F .text	00000010 GPIO_PinLockConfig
08001094  w    F .text	00000002 BusFault_Handler
08000ef4 g     F .text	00000020 USART1_IRQHandler
080006ac g     F .text	0000000c RCC_LSICmd
08001a40 g     F .text	0000007c cmd_line_parser
0800165c g     F .text	0000001c pxPortInitialiseStack
08002080 g     F .text	00000006 __locale_ctype_ptr_l
08000a28 g     F .text	0000000c USART_ClockStructInit
080007c0 g     F .text	0000001c RCC_APB2PeriphResetCmd
08001094  w    F .text	00000002 I2C1_ER_IRQHandler
08000440 g     F .text	00000014 NVIC_PriorityGroupConfig
080016e0 g     F .text	0000001c vPortEnterCritical
00000000  w      *UND*	00000000 _Jv_RegisterClasses
08000324 g     F .text	0000000c GPIO_ReadInputDataBit
08000a88 g     F .text	00000014 USART_DMACmd
00000000  w      *UND*	00000000 __register_frame_info
20000504 g     O .data	0000016c __global_locale
08001094  w    F .text	00000002 USBWakeUp_IRQHandler
08000614 g     F .text	00000014 RCC_HCLKConfig



Disassembly of section .text:

0800010c <__do_global_dtors_aux>:
 800010c:	b510      	push	{r4, lr}
 800010e:	4c05      	ldr	r4, [pc, #20]	; (8000124 <__do_global_dtors_aux+0x18>)
 8000110:	7823      	ldrb	r3, [r4, #0]
 8000112:	b933      	cbnz	r3, 8000122 <__do_global_dtors_aux+0x16>
 8000114:	4b04      	ldr	r3, [pc, #16]	; (8000128 <__do_global_dtors_aux+0x1c>)
 8000116:	b113      	cbz	r3, 800011e <__do_global_dtors_aux+0x12>
 8000118:	4804      	ldr	r0, [pc, #16]	; (800012c <__do_global_dtors_aux+0x20>)
 800011a:	f3af 8000 	nop.w
 800011e:	2301      	movs	r3, #1
 8000120:	7023      	strb	r3, [r4, #0]
 8000122:	bd10      	pop	{r4, pc}
 8000124:	20000670 	.word	0x20000670
 8000128:	00000000 	.word	0x00000000
 800012c:	08002174 	.word	0x08002174

08000130 <frame_dummy>:
 8000130:	4b08      	ldr	r3, [pc, #32]	; (8000154 <frame_dummy+0x24>)
 8000132:	b510      	push	{r4, lr}
 8000134:	b11b      	cbz	r3, 800013e <frame_dummy+0xe>
 8000136:	4908      	ldr	r1, [pc, #32]	; (8000158 <frame_dummy+0x28>)
 8000138:	4808      	ldr	r0, [pc, #32]	; (800015c <frame_dummy+0x2c>)
 800013a:	f3af 8000 	nop.w
 800013e:	4808      	ldr	r0, [pc, #32]	; (8000160 <frame_dummy+0x30>)
 8000140:	6803      	ldr	r3, [r0, #0]
 8000142:	b903      	cbnz	r3, 8000146 <frame_dummy+0x16>
 8000144:	bd10      	pop	{r4, pc}
 8000146:	4b07      	ldr	r3, [pc, #28]	; (8000164 <frame_dummy+0x34>)
 8000148:	2b00      	cmp	r3, #0
 800014a:	d0fb      	beq.n	8000144 <frame_dummy+0x14>
 800014c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8000150:	4718      	bx	r3
 8000152:	bf00      	nop
 8000154:	00000000 	.word	0x00000000
 8000158:	20000674 	.word	0x20000674
 800015c:	08002174 	.word	0x08002174
 8000160:	20000670 	.word	0x20000670
 8000164:	00000000 	.word	0x00000000

08000168 <GPIO_DeInit>:
  * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8000168:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  if (GPIOx == GPIOA)
 800016a:	4b2f      	ldr	r3, [pc, #188]	; (8000228 <GPIO_DeInit+0xc0>)
 800016c:	4298      	cmp	r0, r3
 800016e:	d01e      	beq.n	80001ae <GPIO_DeInit+0x46>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
 8000170:	4b2e      	ldr	r3, [pc, #184]	; (800022c <GPIO_DeInit+0xc4>)
 8000172:	4298      	cmp	r0, r3
 8000174:	d025      	beq.n	80001c2 <GPIO_DeInit+0x5a>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
 8000176:	4b2e      	ldr	r3, [pc, #184]	; (8000230 <GPIO_DeInit+0xc8>)
 8000178:	4298      	cmp	r0, r3
 800017a:	d02c      	beq.n	80001d6 <GPIO_DeInit+0x6e>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
 800017c:	4b2d      	ldr	r3, [pc, #180]	; (8000234 <GPIO_DeInit+0xcc>)
 800017e:	4298      	cmp	r0, r3
 8000180:	d033      	beq.n	80001ea <GPIO_DeInit+0x82>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
  }    
  else if (GPIOx == GPIOE)
 8000182:	4b2d      	ldr	r3, [pc, #180]	; (8000238 <GPIO_DeInit+0xd0>)
 8000184:	4298      	cmp	r0, r3
 8000186:	d03a      	beq.n	80001fe <GPIO_DeInit+0x96>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
  } 
  else if (GPIOx == GPIOF)
 8000188:	4b2c      	ldr	r3, [pc, #176]	; (800023c <GPIO_DeInit+0xd4>)
 800018a:	4298      	cmp	r0, r3
 800018c:	d041      	beq.n	8000212 <GPIO_DeInit+0xaa>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
  }
  else
  {
    if (GPIOx == GPIOG)
 800018e:	4b2c      	ldr	r3, [pc, #176]	; (8000240 <GPIO_DeInit+0xd8>)
 8000190:	4298      	cmp	r0, r3
 8000192:	d000      	beq.n	8000196 <GPIO_DeInit+0x2e>
 8000194:	bd08      	pop	{r3, pc}
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
 8000196:	2101      	movs	r1, #1
 8000198:	f44f 7080 	mov.w	r0, #256	; 0x100
 800019c:	f000 fb10 	bl	80007c0 <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80001a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if (GPIOx == GPIOG)
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
 80001a4:	2100      	movs	r1, #0
 80001a6:	f44f 7080 	mov.w	r0, #256	; 0x100
 80001aa:	f000 bb09 	b.w	80007c0 <RCC_APB2PeriphResetCmd>
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  if (GPIOx == GPIOA)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
 80001ae:	2101      	movs	r1, #1
 80001b0:	2004      	movs	r0, #4
 80001b2:	f000 fb05 	bl	80007c0 <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80001b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  if (GPIOx == GPIOA)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
 80001ba:	2100      	movs	r1, #0
 80001bc:	2004      	movs	r0, #4
 80001be:	f000 baff 	b.w	80007c0 <RCC_APB2PeriphResetCmd>
  }
  else if (GPIOx == GPIOB)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
 80001c2:	2101      	movs	r1, #1
 80001c4:	2008      	movs	r0, #8
 80001c6:	f000 fafb 	bl	80007c0 <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80001ca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
 80001ce:	2100      	movs	r1, #0
 80001d0:	2008      	movs	r0, #8
 80001d2:	f000 baf5 	b.w	80007c0 <RCC_APB2PeriphResetCmd>
  }
  else if (GPIOx == GPIOC)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
 80001d6:	2101      	movs	r1, #1
 80001d8:	2010      	movs	r0, #16
 80001da:	f000 faf1 	bl	80007c0 <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80001de:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
 80001e2:	2100      	movs	r1, #0
 80001e4:	2010      	movs	r0, #16
 80001e6:	f000 baeb 	b.w	80007c0 <RCC_APB2PeriphResetCmd>
  }
  else if (GPIOx == GPIOD)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
 80001ea:	2101      	movs	r1, #1
 80001ec:	2020      	movs	r0, #32
 80001ee:	f000 fae7 	bl	80007c0 <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80001f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
 80001f6:	2100      	movs	r1, #0
 80001f8:	2020      	movs	r0, #32
 80001fa:	f000 bae1 	b.w	80007c0 <RCC_APB2PeriphResetCmd>
  }    
  else if (GPIOx == GPIOE)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
 80001fe:	2101      	movs	r1, #1
 8000200:	2040      	movs	r0, #64	; 0x40
 8000202:	f000 fadd 	bl	80007c0 <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 8000206:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
  }    
  else if (GPIOx == GPIOE)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
 800020a:	2100      	movs	r1, #0
 800020c:	2040      	movs	r0, #64	; 0x40
 800020e:	f000 bad7 	b.w	80007c0 <RCC_APB2PeriphResetCmd>
  } 
  else if (GPIOx == GPIOF)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
 8000212:	2101      	movs	r1, #1
 8000214:	2080      	movs	r0, #128	; 0x80
 8000216:	f000 fad3 	bl	80007c0 <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 800021a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
  } 
  else if (GPIOx == GPIOF)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
 800021e:	2100      	movs	r1, #0
 8000220:	2080      	movs	r0, #128	; 0x80
 8000222:	f000 bacd 	b.w	80007c0 <RCC_APB2PeriphResetCmd>
 8000226:	bf00      	nop
 8000228:	40010800 	.word	0x40010800
 800022c:	40010c00 	.word	0x40010c00
 8000230:	40011000 	.word	0x40011000
 8000234:	40011400 	.word	0x40011400
 8000238:	40011800 	.word	0x40011800
 800023c:	40011c00 	.word	0x40011c00
 8000240:	40012000 	.word	0x40012000

08000244 <GPIO_AFIODeInit>:
  *   and EXTI configuration) registers to their default reset values.
  * @param  None
  * @retval None
  */
void GPIO_AFIODeInit(void)
{
 8000244:	b508      	push	{r3, lr}
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
 8000246:	2101      	movs	r1, #1
 8000248:	4608      	mov	r0, r1
 800024a:	f000 fab9 	bl	80007c0 <RCC_APB2PeriphResetCmd>
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
}
 800024e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void GPIO_AFIODeInit(void)
{
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
 8000252:	2100      	movs	r1, #0
 8000254:	2001      	movs	r0, #1
 8000256:	f000 bab3 	b.w	80007c0 <RCC_APB2PeriphResetCmd>
 800025a:	bf00      	nop

0800025c <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *         contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 800025c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 8000260:	78cc      	ldrb	r4, [r1, #3]
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 8000262:	06e3      	lsls	r3, r4, #27
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8000264:	bf48      	it	mi
 8000266:	788b      	ldrbmi	r3, [r1, #2]
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8000268:	8809      	ldrh	r1, [r1, #0]
 800026a:	f004 070f 	and.w	r7, r4, #15
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 800026e:	bf48      	it	mi
 8000270:	431f      	orrmi	r7, r3
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8000272:	f011 0fff 	tst.w	r1, #255	; 0xff
 8000276:	d021      	beq.n	80002bc <GPIO_Init+0x60>
  {
    tmpreg = GPIOx->CRL;
 8000278:	6806      	ldr	r6, [r0, #0]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 800027a:	2300      	movs	r3, #0
    {
      pos = ((uint32_t)0x01) << pinpos;
 800027c:	f04f 0e01 	mov.w	lr, #1
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8000280:	f04f 080f 	mov.w	r8, #15
 8000284:	e002      	b.n	800028c <GPIO_Init+0x30>
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8000286:	3301      	adds	r3, #1
 8000288:	2b08      	cmp	r3, #8
 800028a:	d016      	beq.n	80002ba <GPIO_Init+0x5e>
    {
      pos = ((uint32_t)0x01) << pinpos;
 800028c:	fa0e f203 	lsl.w	r2, lr, r3
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
 8000290:	ea32 0501 	bics.w	r5, r2, r1
 8000294:	d1f7      	bne.n	8000286 <GPIO_Init+0x2a>
      {
        pos = pinpos << 2;
 8000296:	009d      	lsls	r5, r3, #2
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8000298:	fa08 fc05 	lsl.w	ip, r8, r5
 800029c:	ea26 060c 	bic.w	r6, r6, ip
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80002a0:	fa07 f505 	lsl.w	r5, r7, r5
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80002a4:	2c28      	cmp	r4, #40	; 0x28
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80002a6:	ea46 0605 	orr.w	r6, r6, r5
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80002aa:	d031      	beq.n	8000310 <GPIO_Init+0xb4>
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 80002ac:	2c48      	cmp	r4, #72	; 0x48
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80002ae:	f103 0301 	add.w	r3, r3, #1
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 80002b2:	bf08      	it	eq
 80002b4:	6102      	streq	r2, [r0, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80002b6:	2b08      	cmp	r3, #8
 80002b8:	d1e8      	bne.n	800028c <GPIO_Init+0x30>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 80002ba:	6006      	str	r6, [r0, #0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 80002bc:	29ff      	cmp	r1, #255	; 0xff
 80002be:	d923      	bls.n	8000308 <GPIO_Init+0xac>
  {
    tmpreg = GPIOx->CRH;
 80002c0:	6846      	ldr	r6, [r0, #4]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80002c2:	2300      	movs	r3, #0
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 80002c4:	f04f 0e01 	mov.w	lr, #1
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80002c8:	f04f 080f 	mov.w	r8, #15
 80002cc:	e002      	b.n	80002d4 <GPIO_Init+0x78>
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80002ce:	3301      	adds	r3, #1
 80002d0:	2b08      	cmp	r3, #8
 80002d2:	d018      	beq.n	8000306 <GPIO_Init+0xaa>
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 80002d4:	f103 0208 	add.w	r2, r3, #8
 80002d8:	fa0e f202 	lsl.w	r2, lr, r2
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
 80002dc:	ea32 0501 	bics.w	r5, r2, r1
 80002e0:	d1f5      	bne.n	80002ce <GPIO_Init+0x72>
      {
        pos = pinpos << 2;
 80002e2:	009d      	lsls	r5, r3, #2
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80002e4:	fa08 fc05 	lsl.w	ip, r8, r5
 80002e8:	ea26 060c 	bic.w	r6, r6, ip
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80002ec:	fa07 f505 	lsl.w	r5, r7, r5
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80002f0:	2c28      	cmp	r4, #40	; 0x28
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80002f2:	ea46 0605 	orr.w	r6, r6, r5
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80002f6:	d009      	beq.n	800030c <GPIO_Init+0xb0>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 80002f8:	2c48      	cmp	r4, #72	; 0x48
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80002fa:	f103 0301 	add.w	r3, r3, #1
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 80002fe:	bf08      	it	eq
 8000300:	6102      	streq	r2, [r0, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8000302:	2b08      	cmp	r3, #8
 8000304:	d1e6      	bne.n	80002d4 <GPIO_Init+0x78>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 8000306:	6046      	str	r6, [r0, #4]
 8000308:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 800030c:	6142      	str	r2, [r0, #20]
 800030e:	e7de      	b.n	80002ce <GPIO_Init+0x72>
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 8000310:	6142      	str	r2, [r0, #20]
 8000312:	e7b8      	b.n	8000286 <GPIO_Init+0x2a>

08000314 <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8000314:	f64f 71ff 	movw	r1, #65535	; 0xffff
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8000318:	2202      	movs	r2, #2
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 800031a:	2304      	movs	r3, #4
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 800031c:	8001      	strh	r1, [r0, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 800031e:	7082      	strb	r2, [r0, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8000320:	70c3      	strb	r3, [r0, #3]
 8000322:	4770      	bx	lr

08000324 <GPIO_ReadInputDataBit>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8000324:	6883      	ldr	r3, [r0, #8]
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
 8000326:	4219      	tst	r1, r3
}
 8000328:	bf14      	ite	ne
 800032a:	2001      	movne	r0, #1
 800032c:	2000      	moveq	r0, #0
 800032e:	4770      	bx	lr

08000330 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  return ((uint16_t)GPIOx->IDR);
 8000330:	6880      	ldr	r0, [r0, #8]
}
 8000332:	b280      	uxth	r0, r0
 8000334:	4770      	bx	lr
 8000336:	bf00      	nop

08000338 <GPIO_ReadOutputDataBit>:
  uint8_t bitstatus = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8000338:	68c3      	ldr	r3, [r0, #12]
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
 800033a:	4219      	tst	r1, r3
}
 800033c:	bf14      	ite	ne
 800033e:	2001      	movne	r0, #1
 8000340:	2000      	moveq	r0, #0
 8000342:	4770      	bx	lr

08000344 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    
  return ((uint16_t)GPIOx->ODR);
 8000344:	68c0      	ldr	r0, [r0, #12]
}
 8000346:	b280      	uxth	r0, r0
 8000348:	4770      	bx	lr
 800034a:	bf00      	nop

0800034c <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 800034c:	6101      	str	r1, [r0, #16]
 800034e:	4770      	bx	lr

08000350 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 8000350:	6141      	str	r1, [r0, #20]
 8000352:	4770      	bx	lr

08000354 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
 8000354:	b90a      	cbnz	r2, 800035a <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
 8000356:	6141      	str	r1, [r0, #20]
 8000358:	4770      	bx	lr
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
  {
    GPIOx->BSRR = GPIO_Pin;
 800035a:	6101      	str	r1, [r0, #16]
 800035c:	4770      	bx	lr
 800035e:	bf00      	nop

08000360 <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  GPIOx->ODR = PortVal;
 8000360:	60c1      	str	r1, [r0, #12]
 8000362:	4770      	bx	lr

08000364 <GPIO_PinLockConfig>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  tmp |= GPIO_Pin;
 8000364:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8000368:	6183      	str	r3, [r0, #24]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 800036a:	6181      	str	r1, [r0, #24]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 800036c:	6183      	str	r3, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 800036e:	6983      	ldr	r3, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8000370:	6983      	ldr	r3, [r0, #24]
 8000372:	4770      	bx	lr

08000374 <GPIO_EventOutputConfig>:
  * @param  GPIO_PinSource: specifies the pin for the Event output.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 8000374:	f64f 7380 	movw	r3, #65408	; 0xff80
  uint32_t tmpreg = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
 8000378:	4a04      	ldr	r2, [pc, #16]	; (800038c <GPIO_EventOutputConfig+0x18>)
  * @param  GPIO_PinSource: specifies the pin for the Event output.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 800037a:	b410      	push	{r4}
  uint32_t tmpreg = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
 800037c:	6814      	ldr	r4, [r2, #0]
 800037e:	4023      	ands	r3, r4
 8000380:	4319      	orrs	r1, r3
  /* Clear the PORT[6:4] and PIN[3:0] bits */
  tmpreg &= EVCR_PORTPINCONFIG_MASK;
  tmpreg |= (uint32_t)GPIO_PortSource << 0x04;
  tmpreg |= GPIO_PinSource;
 8000382:	ea41 1000 	orr.w	r0, r1, r0, lsl #4
  AFIO->EVCR = tmpreg;
 8000386:	6010      	str	r0, [r2, #0]
}
 8000388:	bc10      	pop	{r4}
 800038a:	4770      	bx	lr
 800038c:	40010000 	.word	0x40010000

08000390 <GPIO_EventOutputCmd>:
void GPIO_EventOutputCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) EVCR_EVOE_BB = (uint32_t)NewState;
 8000390:	4b01      	ldr	r3, [pc, #4]	; (8000398 <GPIO_EventOutputCmd+0x8>)
 8000392:	6018      	str	r0, [r3, #0]
 8000394:	4770      	bx	lr
 8000396:	bf00      	nop
 8000398:	4220001c 	.word	0x4220001c

0800039c <GPIO_PinRemapConfig>:

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
 800039c:	2800      	cmp	r0, #0
  {
    tmpreg = AFIO->MAPR2;
 800039e:	4b19      	ldr	r3, [pc, #100]	; (8000404 <GPIO_PinRemapConfig+0x68>)
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80003a0:	f400 1240 	and.w	r2, r0, #3145728	; 0x300000
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    tmpreg = AFIO->MAPR2;
 80003a4:	bfb4      	ite	lt
 80003a6:	69db      	ldrlt	r3, [r3, #28]
  }
  else
  {
    tmpreg = AFIO->MAPR;
 80003a8:	685b      	ldrge	r3, [r3, #4]
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80003aa:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
  * @param  NewState: new state of the port pin remapping.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
{
 80003ae:	b430      	push	{r4, r5}
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;
 80003b0:	b284      	uxth	r4, r0

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80003b2:	d01e      	beq.n	80003f2 <GPIO_PinRemapConfig+0x56>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 80003b4:	02c2      	lsls	r2, r0, #11
 80003b6:	d513      	bpl.n	80003e0 <GPIO_PinRemapConfig+0x44>
  {
    tmp1 = ((uint32_t)0x03) << tmpmask;
    tmpreg &= ~tmp1;
 80003b8:	f3c0 4503 	ubfx	r5, r0, #16, #4
 80003bc:	2203      	movs	r2, #3
 80003be:	40aa      	lsls	r2, r5
 80003c0:	ea23 0302 	bic.w	r3, r3, r2
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 80003c4:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }

  if (NewState != DISABLE)
 80003c8:	b119      	cbz	r1, 80003d2 <GPIO_PinRemapConfig+0x36>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
 80003ca:	0d42      	lsrs	r2, r0, #21
 80003cc:	0112      	lsls	r2, r2, #4
 80003ce:	4094      	lsls	r4, r2
 80003d0:	4323      	orrs	r3, r4
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    AFIO->MAPR2 = tmpreg;
 80003d2:	4a0c      	ldr	r2, [pc, #48]	; (8000404 <GPIO_PinRemapConfig+0x68>)
  if (NewState != DISABLE)
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
 80003d4:	2800      	cmp	r0, #0
  {
    AFIO->MAPR2 = tmpreg;
 80003d6:	bfb4      	ite	lt
 80003d8:	61d3      	strlt	r3, [r2, #28]
  }
  else
  {
    AFIO->MAPR = tmpreg;
 80003da:	6053      	strge	r3, [r2, #4]
  }  
}
 80003dc:	bc30      	pop	{r4, r5}
 80003de:	4770      	bx	lr
    tmpreg &= ~tmp1;
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 80003e0:	0d42      	lsrs	r2, r0, #21
 80003e2:	0112      	lsls	r2, r2, #4
 80003e4:	fa04 f202 	lsl.w	r2, r4, r2
 80003e8:	ea23 0302 	bic.w	r3, r3, r2
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 80003ec:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
 80003f0:	e7ea      	b.n	80003c8 <GPIO_PinRemapConfig+0x2c>
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 80003f2:	4d04      	ldr	r5, [pc, #16]	; (8000404 <GPIO_PinRemapConfig+0x68>)
  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
 80003f4:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 80003f8:	686a      	ldr	r2, [r5, #4]
 80003fa:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 80003fe:	606a      	str	r2, [r5, #4]
 8000400:	e7e2      	b.n	80003c8 <GPIO_PinRemapConfig+0x2c>
 8000402:	bf00      	nop
 8000404:	40010000 	.word	0x40010000

08000408 <GPIO_EXTILineConfig>:
  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 8000408:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 800040c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8000410:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
  uint32_t tmp = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 8000414:	f001 0103 	and.w	r1, r1, #3
  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 8000418:	b410      	push	{r4}
  uint32_t tmp = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 800041a:	0089      	lsls	r1, r1, #2
  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
 800041c:	689c      	ldr	r4, [r3, #8]
 800041e:	220f      	movs	r2, #15
 8000420:	408a      	lsls	r2, r1
 8000422:	ea24 0202 	bic.w	r2, r4, r2
 8000426:	609a      	str	r2, [r3, #8]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
 8000428:	689a      	ldr	r2, [r3, #8]
 800042a:	4088      	lsls	r0, r1
 800042c:	4310      	orrs	r0, r2
 800042e:	6098      	str	r0, [r3, #8]
}
 8000430:	bc10      	pop	{r4}
 8000432:	4770      	bx	lr

08000434 <GPIO_ETH_MediaInterfaceConfig>:
void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface) 
{ 
  assert_param(IS_GPIO_ETH_MEDIA_INTERFACE(GPIO_ETH_MediaInterface)); 

  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) MAPR_MII_RMII_SEL_BB = GPIO_ETH_MediaInterface; 
 8000434:	4b01      	ldr	r3, [pc, #4]	; (800043c <GPIO_ETH_MediaInterfaceConfig+0x8>)
 8000436:	6018      	str	r0, [r3, #0]
 8000438:	4770      	bx	lr
 800043a:	bf00      	nop
 800043c:	422000dc 	.word	0x422000dc

08000440 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8000440:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8000444:	4b02      	ldr	r3, [pc, #8]	; (8000450 <NVIC_PriorityGroupConfig+0x10>)
 8000446:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
 800044a:	60d8      	str	r0, [r3, #12]
 800044c:	4770      	bx	lr
 800044e:	bf00      	nop
 8000450:	e000ed00 	.word	0xe000ed00

08000454 <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8000454:	78c3      	ldrb	r3, [r0, #3]
 8000456:	b95b      	cbnz	r3, 8000470 <NVIC_Init+0x1c>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000458:	7803      	ldrb	r3, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800045a:	2101      	movs	r1, #1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800045c:	095a      	lsrs	r2, r3, #5
 800045e:	4816      	ldr	r0, [pc, #88]	; (80004b8 <NVIC_Init+0x64>)
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8000460:	f003 031f 	and.w	r3, r3, #31
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000464:	3220      	adds	r2, #32
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8000466:	fa01 f303 	lsl.w	r3, r1, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800046a:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 800046e:	4770      	bx	lr
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8000470:	4b12      	ldr	r3, [pc, #72]	; (80004bc <NVIC_Init+0x68>)
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8000472:	b430      	push	{r4, r5}
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8000474:	68d9      	ldr	r1, [r3, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8000476:	7882      	ldrb	r2, [r0, #2]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8000478:	43c9      	mvns	r1, r1
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 800047a:	7844      	ldrb	r4, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 800047c:	f3c1 2102 	ubfx	r1, r1, #8, #3
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8000480:	230f      	movs	r3, #15
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
 8000482:	f1c1 0504 	rsb	r5, r1, #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8000486:	40cb      	lsrs	r3, r1
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8000488:	40ac      	lsls	r4, r5
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 800048a:	4013      	ands	r3, r2
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 800048c:	7802      	ldrb	r2, [r0, #0]
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 800048e:	4323      	orrs	r3, r4
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8000490:	011b      	lsls	r3, r3, #4
 8000492:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 8000496:	b2db      	uxtb	r3, r3
 8000498:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 800049c:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80004a0:	7803      	ldrb	r3, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80004a2:	2201      	movs	r2, #1
 80004a4:	f003 001f 	and.w	r0, r3, #31

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80004a8:	4903      	ldr	r1, [pc, #12]	; (80004b8 <NVIC_Init+0x64>)
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80004aa:	095b      	lsrs	r3, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80004ac:	4082      	lsls	r2, r0
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80004ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 80004b2:	bc30      	pop	{r4, r5}
 80004b4:	4770      	bx	lr
 80004b6:	bf00      	nop
 80004b8:	e000e100 	.word	0xe000e100
 80004bc:	e000ed00 	.word	0xe000ed00

080004c0 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 80004c0:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 80004c4:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 80004c8:	4b01      	ldr	r3, [pc, #4]	; (80004d0 <NVIC_SetVectorTable+0x10>)
 80004ca:	4308      	orrs	r0, r1
 80004cc:	6098      	str	r0, [r3, #8]
 80004ce:	4770      	bx	lr
 80004d0:	e000ed00 	.word	0xe000ed00

080004d4 <NVIC_SystemLPConfig>:
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 80004d4:	4a04      	ldr	r2, [pc, #16]	; (80004e8 <NVIC_SystemLPConfig+0x14>)
 80004d6:	6913      	ldr	r3, [r2, #16]
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 80004d8:	b919      	cbnz	r1, 80004e2 <NVIC_SystemLPConfig+0xe>
  {
    SCB->SCR |= LowPowerMode;
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 80004da:	ea23 0000 	bic.w	r0, r3, r0
 80004de:	6110      	str	r0, [r2, #16]
 80004e0:	4770      	bx	lr
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 80004e2:	4318      	orrs	r0, r3
 80004e4:	6110      	str	r0, [r2, #16]
 80004e6:	4770      	bx	lr
 80004e8:	e000ed00 	.word	0xe000ed00

080004ec <SysTick_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 80004ec:	4a04      	ldr	r2, [pc, #16]	; (8000500 <SysTick_CLKSourceConfig+0x14>)
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 80004ee:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 80004f0:	6813      	ldr	r3, [r2, #0]
 80004f2:	bf0c      	ite	eq
 80004f4:	f043 0304 	orreq.w	r3, r3, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 80004f8:	f023 0304 	bicne.w	r3, r3, #4
 80004fc:	6013      	str	r3, [r2, #0]
 80004fe:	4770      	bx	lr
 8000500:	e000e010 	.word	0xe000e010

08000504 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000504:	4b0d      	ldr	r3, [pc, #52]	; (800053c <RCC_DeInit+0x38>)

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8000506:	4a0e      	ldr	r2, [pc, #56]	; (8000540 <RCC_DeInit+0x3c>)
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000508:	6819      	ldr	r1, [r3, #0]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 800050a:	f44f 001f 	mov.w	r0, #10420224	; 0x9f0000
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800050e:	f041 0101 	orr.w	r1, r1, #1
 8000512:	6019      	str	r1, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8000514:	6859      	ldr	r1, [r3, #4]
 8000516:	400a      	ands	r2, r1
 8000518:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800051a:	681a      	ldr	r2, [r3, #0]
 800051c:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8000520:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000524:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000526:	681a      	ldr	r2, [r3, #0]
 8000528:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800052c:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 800052e:	685a      	ldr	r2, [r3, #4]
 8000530:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8000534:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8000536:	6098      	str	r0, [r3, #8]
 8000538:	4770      	bx	lr
 800053a:	bf00      	nop
 800053c:	40021000 	.word	0x40021000
 8000540:	f8ff0000 	.word	0xf8ff0000

08000544 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 8000544:	4b0c      	ldr	r3, [pc, #48]	; (8000578 <RCC_HSEConfig+0x34>)
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 8000546:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 800054a:	681a      	ldr	r2, [r3, #0]
 800054c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000550:	601a      	str	r2, [r3, #0]
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
 8000552:	681a      	ldr	r2, [r3, #0]
 8000554:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000558:	601a      	str	r2, [r3, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 800055a:	d008      	beq.n	800056e <RCC_HSEConfig+0x2a>
 800055c:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 8000560:	d104      	bne.n	800056c <RCC_HSEConfig+0x28>
      RCC->CR |= CR_HSEON_Set;
      break;
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 8000562:	681a      	ldr	r2, [r3, #0]
 8000564:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 8000568:	601a      	str	r2, [r3, #0]
 800056a:	4770      	bx	lr
 800056c:	4770      	bx	lr
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
 800056e:	681a      	ldr	r2, [r3, #0]
 8000570:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000574:	601a      	str	r2, [r3, #0]
      break;
 8000576:	4770      	bx	lr
 8000578:	40021000 	.word	0x40021000

0800057c <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 800057c:	b082      	sub	sp, #8
  __IO uint32_t StartUpCounter = 0;
 800057e:	2300      	movs	r3, #0

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8000580:	4a0a      	ldr	r2, [pc, #40]	; (80005ac <RCC_WaitForHSEStartUp+0x30>)
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
  __IO uint32_t StartUpCounter = 0;
 8000582:	9301      	str	r3, [sp, #4]
 8000584:	e002      	b.n	800058c <RCC_WaitForHSEStartUp+0x10>
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    StartUpCounter++;  
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 8000586:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800058a:	d008      	beq.n	800059e <RCC_WaitForHSEStartUp+0x22>

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 800058c:	6813      	ldr	r3, [r2, #0]
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800058e:	f413 3f00 	tst.w	r3, #131072	; 0x20000
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    StartUpCounter++;  
 8000592:	9b01      	ldr	r3, [sp, #4]
 8000594:	f103 0301 	add.w	r3, r3, #1
 8000598:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 800059a:	9b01      	ldr	r3, [sp, #4]
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800059c:	d0f3      	beq.n	8000586 <RCC_WaitForHSEStartUp+0xa>

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 800059e:	4b03      	ldr	r3, [pc, #12]	; (80005ac <RCC_WaitForHSEStartUp+0x30>)
 80005a0:	6818      	ldr	r0, [r3, #0]
  }
  else
  {
    status = ERROR;
  }  
  return (status);
 80005a2:	f3c0 4040 	ubfx	r0, r0, #17, #1
}
 80005a6:	b002      	add	sp, #8
 80005a8:	4770      	bx	lr
 80005aa:	bf00      	nop
 80005ac:	40021000 	.word	0x40021000

080005b0 <RCC_AdjustHSICalibrationValue>:
void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
  tmpreg = RCC->CR;
 80005b0:	4a03      	ldr	r2, [pc, #12]	; (80005c0 <RCC_AdjustHSICalibrationValue+0x10>)
 80005b2:	6813      	ldr	r3, [r2, #0]
  /* Clear HSITRIM[4:0] bits */
  tmpreg &= CR_HSITRIM_Mask;
 80005b4:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 80005b8:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
  /* Store the new value */
  RCC->CR = tmpreg;
 80005bc:	6010      	str	r0, [r2, #0]
 80005be:	4770      	bx	lr
 80005c0:	40021000 	.word	0x40021000

080005c4 <RCC_HSICmd>:
  */
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 80005c4:	4b01      	ldr	r3, [pc, #4]	; (80005cc <RCC_HSICmd+0x8>)
 80005c6:	6018      	str	r0, [r3, #0]
 80005c8:	4770      	bx	lr
 80005ca:	bf00      	nop
 80005cc:	42420000 	.word	0x42420000

080005d0 <RCC_PLLConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 80005d0:	4a03      	ldr	r2, [pc, #12]	; (80005e0 <RCC_PLLConfig+0x10>)
 80005d2:	6853      	ldr	r3, [r2, #4]
 80005d4:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 80005d8:	4319      	orrs	r1, r3
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 80005da:	4308      	orrs	r0, r1
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80005dc:	6050      	str	r0, [r2, #4]
 80005de:	4770      	bx	lr
 80005e0:	40021000 	.word	0x40021000

080005e4 <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 80005e4:	4b01      	ldr	r3, [pc, #4]	; (80005ec <RCC_PLLCmd+0x8>)
 80005e6:	6018      	str	r0, [r3, #0]
 80005e8:	4770      	bx	lr
 80005ea:	bf00      	nop
 80005ec:	42420060 	.word	0x42420060

080005f0 <RCC_SYSCLKConfig>:
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 80005f0:	4a03      	ldr	r2, [pc, #12]	; (8000600 <RCC_SYSCLKConfig+0x10>)
 80005f2:	6853      	ldr	r3, [r2, #4]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 80005f4:	f023 0303 	bic.w	r3, r3, #3
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 80005f8:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80005fa:	6050      	str	r0, [r2, #4]
 80005fc:	4770      	bx	lr
 80005fe:	bf00      	nop
 8000600:	40021000 	.word	0x40021000

08000604 <RCC_GetSYSCLKSource>:
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 8000604:	4b02      	ldr	r3, [pc, #8]	; (8000610 <RCC_GetSYSCLKSource+0xc>)
 8000606:	6858      	ldr	r0, [r3, #4]
}
 8000608:	f000 000c 	and.w	r0, r0, #12
 800060c:	4770      	bx	lr
 800060e:	bf00      	nop
 8000610:	40021000 	.word	0x40021000

08000614 <RCC_HCLKConfig>:
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 8000614:	4a03      	ldr	r2, [pc, #12]	; (8000624 <RCC_HCLKConfig+0x10>)
 8000616:	6853      	ldr	r3, [r2, #4]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 8000618:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 800061c:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800061e:	6050      	str	r0, [r2, #4]
 8000620:	4770      	bx	lr
 8000622:	bf00      	nop
 8000624:	40021000 	.word	0x40021000

08000628 <RCC_PCLK1Config>:
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8000628:	4a03      	ldr	r2, [pc, #12]	; (8000638 <RCC_PCLK1Config+0x10>)
 800062a:	6853      	ldr	r3, [r2, #4]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 800062c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8000630:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8000632:	6050      	str	r0, [r2, #4]
 8000634:	4770      	bx	lr
 8000636:	bf00      	nop
 8000638:	40021000 	.word	0x40021000

0800063c <RCC_PCLK2Config>:
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 800063c:	4a03      	ldr	r2, [pc, #12]	; (800064c <RCC_PCLK2Config+0x10>)
 800063e:	6853      	ldr	r3, [r2, #4]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 8000640:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8000644:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8000648:	6050      	str	r0, [r2, #4]
 800064a:	4770      	bx	lr
 800064c:	40021000 	.word	0x40021000

08000650 <RCC_ITConfig>:
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000650:	b929      	cbnz	r1, 800065e <RCC_ITConfig+0xe>
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
  }
  else
  {
    /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 8000652:	4a05      	ldr	r2, [pc, #20]	; (8000668 <RCC_ITConfig+0x18>)
 8000654:	7813      	ldrb	r3, [r2, #0]
 8000656:	ea23 0000 	bic.w	r0, r3, r0
 800065a:	7010      	strb	r0, [r2, #0]
 800065c:	4770      	bx	lr
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 800065e:	4b02      	ldr	r3, [pc, #8]	; (8000668 <RCC_ITConfig+0x18>)
 8000660:	781a      	ldrb	r2, [r3, #0]
 8000662:	4310      	orrs	r0, r2
 8000664:	7018      	strb	r0, [r3, #0]
 8000666:	4770      	bx	lr
 8000668:	40021009 	.word	0x40021009

0800066c <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 800066c:	4b01      	ldr	r3, [pc, #4]	; (8000674 <RCC_USBCLKConfig+0x8>)
 800066e:	6018      	str	r0, [r3, #0]
 8000670:	4770      	bx	lr
 8000672:	bf00      	nop
 8000674:	424200d8 	.word	0x424200d8

08000678 <RCC_ADCCLKConfig>:
void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
  tmpreg = RCC->CFGR;
 8000678:	4a03      	ldr	r2, [pc, #12]	; (8000688 <RCC_ADCCLKConfig+0x10>)
 800067a:	6853      	ldr	r3, [r2, #4]
  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
 800067c:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
 8000680:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8000682:	6050      	str	r0, [r2, #4]
 8000684:	4770      	bx	lr
 8000686:	bf00      	nop
 8000688:	40021000 	.word	0x40021000

0800068c <RCC_LSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 800068c:	4b06      	ldr	r3, [pc, #24]	; (80006a8 <RCC_LSEConfig+0x1c>)
 800068e:	2200      	movs	r2, #0
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 8000690:	2801      	cmp	r0, #1
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8000692:	701a      	strb	r2, [r3, #0]
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8000694:	701a      	strb	r2, [r3, #0]
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 8000696:	d005      	beq.n	80006a4 <RCC_LSEConfig+0x18>
 8000698:	2804      	cmp	r0, #4
 800069a:	d102      	bne.n	80006a2 <RCC_LSEConfig+0x16>
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
      break;
      
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 800069c:	2205      	movs	r2, #5
 800069e:	701a      	strb	r2, [r3, #0]
 80006a0:	4770      	bx	lr
 80006a2:	4770      	bx	lr
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 80006a4:	7018      	strb	r0, [r3, #0]
      break;
 80006a6:	4770      	bx	lr
 80006a8:	40021020 	.word	0x40021020

080006ac <RCC_LSICmd>:
  */
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 80006ac:	4b01      	ldr	r3, [pc, #4]	; (80006b4 <RCC_LSICmd+0x8>)
 80006ae:	6018      	str	r0, [r3, #0]
 80006b0:	4770      	bx	lr
 80006b2:	bf00      	nop
 80006b4:	42420480 	.word	0x42420480

080006b8 <RCC_RTCCLKConfig>:
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 80006b8:	4a02      	ldr	r2, [pc, #8]	; (80006c4 <RCC_RTCCLKConfig+0xc>)
 80006ba:	6a13      	ldr	r3, [r2, #32]
 80006bc:	4318      	orrs	r0, r3
 80006be:	6210      	str	r0, [r2, #32]
 80006c0:	4770      	bx	lr
 80006c2:	bf00      	nop
 80006c4:	40021000 	.word	0x40021000

080006c8 <RCC_RTCCLKCmd>:
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 80006c8:	4b01      	ldr	r3, [pc, #4]	; (80006d0 <RCC_RTCCLKCmd+0x8>)
 80006ca:	6018      	str	r0, [r3, #0]
 80006cc:	4770      	bx	lr
 80006ce:	bf00      	nop
 80006d0:	4242043c 	.word	0x4242043c

080006d4 <RCC_GetClocksFreq>:
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 80006d4:	4a21      	ldr	r2, [pc, #132]	; (800075c <RCC_GetClocksFreq+0x88>)
  * @note   The result of this function could be not correct when using 
  *         fractional value for HSE crystal.  
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 80006d6:	b410      	push	{r4}
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 80006d8:	6853      	ldr	r3, [r2, #4]
  
  switch (tmp)
 80006da:	f003 030c 	and.w	r3, r3, #12
 80006de:	2b04      	cmp	r3, #4
 80006e0:	d006      	beq.n	80006f0 <RCC_GetClocksFreq+0x1c>
 80006e2:	2b08      	cmp	r3, #8
 80006e4:	d025      	beq.n	8000732 <RCC_GetClocksFreq+0x5e>
 80006e6:	b11b      	cbz	r3, 80006f0 <RCC_GetClocksFreq+0x1c>
      }
#endif /* STM32F10X_CL */ 
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80006e8:	4a1d      	ldr	r2, [pc, #116]	; (8000760 <RCC_GetClocksFreq+0x8c>)
      break;
 80006ea:	4613      	mov	r3, r2
      }
#endif /* STM32F10X_CL */ 
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80006ec:	6002      	str	r2, [r0, #0]
      break;
 80006ee:	e001      	b.n	80006f4 <RCC_GetClocksFreq+0x20>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 80006f0:	4b1b      	ldr	r3, [pc, #108]	; (8000760 <RCC_GetClocksFreq+0x8c>)
 80006f2:	6003      	str	r3, [r0, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 80006f4:	4a19      	ldr	r2, [pc, #100]	; (800075c <RCC_GetClocksFreq+0x88>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 80006f6:	491b      	ldr	r1, [pc, #108]	; (8000764 <RCC_GetClocksFreq+0x90>)
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 80006f8:	6854      	ldr	r4, [r2, #4]
  tmp = tmp >> 4;
 80006fa:	f3c4 1403 	ubfx	r4, r4, #4, #4
  presc = APBAHBPrescTable[tmp];
 80006fe:	5d0c      	ldrb	r4, [r1, r4]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8000700:	40e3      	lsrs	r3, r4
 8000702:	6043      	str	r3, [r0, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 8000704:	6854      	ldr	r4, [r2, #4]
  tmp = tmp >> 8;
 8000706:	f3c4 2402 	ubfx	r4, r4, #8, #3
  presc = APBAHBPrescTable[tmp];
 800070a:	5d0c      	ldrb	r4, [r1, r4]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800070c:	fa23 f404 	lsr.w	r4, r3, r4
 8000710:	6084      	str	r4, [r0, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 8000712:	6854      	ldr	r4, [r2, #4]
  tmp = tmp >> 11;
 8000714:	f3c4 24c2 	ubfx	r4, r4, #11, #3
  presc = APBAHBPrescTable[tmp];
 8000718:	5d0c      	ldrb	r4, [r1, r4]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800071a:	40e3      	lsrs	r3, r4
 800071c:	60c3      	str	r3, [r0, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 800071e:	6852      	ldr	r2, [r2, #4]
  tmp = tmp >> 14;
  presc = ADCPrescTable[tmp];
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
}
 8000720:	bc10      	pop	{r4}
  presc = APBAHBPrescTable[tmp];
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
  tmp = tmp >> 14;
 8000722:	f3c2 3281 	ubfx	r2, r2, #14, #2
  presc = ADCPrescTable[tmp];
 8000726:	440a      	add	r2, r1
 8000728:	7c12      	ldrb	r2, [r2, #16]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 800072a:	fbb3 f3f2 	udiv	r3, r3, r2
 800072e:	6103      	str	r3, [r0, #16]
}
 8000730:	4770      	bx	lr
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
      break;
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 8000732:	6853      	ldr	r3, [r2, #4]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 8000734:	6851      	ldr	r1, [r2, #4]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 8000736:	f3c3 4383 	ubfx	r3, r3, #18, #4
      
      if (pllsource == 0x00)
 800073a:	03c9      	lsls	r1, r1, #15
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 800073c:	f103 0302 	add.w	r3, r3, #2
      
      if (pllsource == 0x00)
 8000740:	d507      	bpl.n	8000752 <RCC_GetClocksFreq+0x7e>
       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
       /* HSE oscillator clock selected as PREDIV1 clock entry */
       RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
 8000742:	6852      	ldr	r2, [r2, #4]
 8000744:	0392      	lsls	r2, r2, #14
 8000746:	d404      	bmi.n	8000752 <RCC_GetClocksFreq+0x7e>
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
 8000748:	4a05      	ldr	r2, [pc, #20]	; (8000760 <RCC_GetClocksFreq+0x8c>)
 800074a:	fb02 f303 	mul.w	r3, r2, r3
 800074e:	6003      	str	r3, [r0, #0]
 8000750:	e7d0      	b.n	80006f4 <RCC_GetClocksFreq+0x20>
       RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
 8000752:	4a05      	ldr	r2, [pc, #20]	; (8000768 <RCC_GetClocksFreq+0x94>)
 8000754:	fb02 f303 	mul.w	r3, r2, r3
 8000758:	6003      	str	r3, [r0, #0]
 800075a:	e7cb      	b.n	80006f4 <RCC_GetClocksFreq+0x20>
 800075c:	40021000 	.word	0x40021000
 8000760:	007a1200 	.word	0x007a1200
 8000764:	20000000 	.word	0x20000000
 8000768:	003d0900 	.word	0x003d0900

0800076c <RCC_AHBPeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800076c:	b929      	cbnz	r1, 800077a <RCC_AHBPeriphClockCmd+0xe>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 800076e:	4a05      	ldr	r2, [pc, #20]	; (8000784 <RCC_AHBPeriphClockCmd+0x18>)
 8000770:	6953      	ldr	r3, [r2, #20]
 8000772:	ea23 0000 	bic.w	r0, r3, r0
 8000776:	6150      	str	r0, [r2, #20]
 8000778:	4770      	bx	lr
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 800077a:	4b02      	ldr	r3, [pc, #8]	; (8000784 <RCC_AHBPeriphClockCmd+0x18>)
 800077c:	695a      	ldr	r2, [r3, #20]
 800077e:	4310      	orrs	r0, r2
 8000780:	6158      	str	r0, [r3, #20]
 8000782:	4770      	bx	lr
 8000784:	40021000 	.word	0x40021000

08000788 <RCC_APB2PeriphClockCmd>:
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000788:	b929      	cbnz	r1, 8000796 <RCC_APB2PeriphClockCmd+0xe>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800078a:	4a05      	ldr	r2, [pc, #20]	; (80007a0 <RCC_APB2PeriphClockCmd+0x18>)
 800078c:	6993      	ldr	r3, [r2, #24]
 800078e:	ea23 0000 	bic.w	r0, r3, r0
 8000792:	6190      	str	r0, [r2, #24]
 8000794:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8000796:	4b02      	ldr	r3, [pc, #8]	; (80007a0 <RCC_APB2PeriphClockCmd+0x18>)
 8000798:	699a      	ldr	r2, [r3, #24]
 800079a:	4310      	orrs	r0, r2
 800079c:	6198      	str	r0, [r3, #24]
 800079e:	4770      	bx	lr
 80007a0:	40021000 	.word	0x40021000

080007a4 <RCC_APB1PeriphClockCmd>:
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80007a4:	b929      	cbnz	r1, 80007b2 <RCC_APB1PeriphClockCmd+0xe>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 80007a6:	4a05      	ldr	r2, [pc, #20]	; (80007bc <RCC_APB1PeriphClockCmd+0x18>)
 80007a8:	69d3      	ldr	r3, [r2, #28]
 80007aa:	ea23 0000 	bic.w	r0, r3, r0
 80007ae:	61d0      	str	r0, [r2, #28]
 80007b0:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80007b2:	4b02      	ldr	r3, [pc, #8]	; (80007bc <RCC_APB1PeriphClockCmd+0x18>)
 80007b4:	69da      	ldr	r2, [r3, #28]
 80007b6:	4310      	orrs	r0, r2
 80007b8:	61d8      	str	r0, [r3, #28]
 80007ba:	4770      	bx	lr
 80007bc:	40021000 	.word	0x40021000

080007c0 <RCC_APB2PeriphResetCmd>:
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80007c0:	b929      	cbnz	r1, 80007ce <RCC_APB2PeriphResetCmd+0xe>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 80007c2:	4a05      	ldr	r2, [pc, #20]	; (80007d8 <RCC_APB2PeriphResetCmd+0x18>)
 80007c4:	68d3      	ldr	r3, [r2, #12]
 80007c6:	ea23 0000 	bic.w	r0, r3, r0
 80007ca:	60d0      	str	r0, [r2, #12]
 80007cc:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 80007ce:	4b02      	ldr	r3, [pc, #8]	; (80007d8 <RCC_APB2PeriphResetCmd+0x18>)
 80007d0:	68da      	ldr	r2, [r3, #12]
 80007d2:	4310      	orrs	r0, r2
 80007d4:	60d8      	str	r0, [r3, #12]
 80007d6:	4770      	bx	lr
 80007d8:	40021000 	.word	0x40021000

080007dc <RCC_APB1PeriphResetCmd>:
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80007dc:	b929      	cbnz	r1, 80007ea <RCC_APB1PeriphResetCmd+0xe>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 80007de:	4a05      	ldr	r2, [pc, #20]	; (80007f4 <RCC_APB1PeriphResetCmd+0x18>)
 80007e0:	6913      	ldr	r3, [r2, #16]
 80007e2:	ea23 0000 	bic.w	r0, r3, r0
 80007e6:	6110      	str	r0, [r2, #16]
 80007e8:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80007ea:	4b02      	ldr	r3, [pc, #8]	; (80007f4 <RCC_APB1PeriphResetCmd+0x18>)
 80007ec:	691a      	ldr	r2, [r3, #16]
 80007ee:	4310      	orrs	r0, r2
 80007f0:	6118      	str	r0, [r3, #16]
 80007f2:	4770      	bx	lr
 80007f4:	40021000 	.word	0x40021000

080007f8 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 80007f8:	4b01      	ldr	r3, [pc, #4]	; (8000800 <RCC_BackupResetCmd+0x8>)
 80007fa:	6018      	str	r0, [r3, #0]
 80007fc:	4770      	bx	lr
 80007fe:	bf00      	nop
 8000800:	42420440 	.word	0x42420440

08000804 <RCC_ClockSecuritySystemCmd>:
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8000804:	4b01      	ldr	r3, [pc, #4]	; (800080c <RCC_ClockSecuritySystemCmd+0x8>)
 8000806:	6018      	str	r0, [r3, #0]
 8000808:	4770      	bx	lr
 800080a:	bf00      	nop
 800080c:	4242004c 	.word	0x4242004c

08000810 <RCC_MCOConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCO));

  /* Perform Byte access to MCO bits to select the MCO source */
  *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
 8000810:	4b01      	ldr	r3, [pc, #4]	; (8000818 <RCC_MCOConfig+0x8>)
 8000812:	7018      	strb	r0, [r3, #0]
 8000814:	4770      	bx	lr
 8000816:	bf00      	nop
 8000818:	40021007 	.word	0x40021007

0800081c <RCC_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 800081c:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 800081e:	2b01      	cmp	r3, #1
 8000820:	d00b      	beq.n	800083a <RCC_GetFlagStatus+0x1e>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8000822:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 8000824:	4b09      	ldr	r3, [pc, #36]	; (800084c <RCC_GetFlagStatus+0x30>)
  {
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
 8000826:	f000 001f 	and.w	r0, r0, #31
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
  {
    statusreg = RCC->BDCR;
 800082a:	bf0c      	ite	eq
 800082c:	6a1b      	ldreq	r3, [r3, #32]
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 800082e:	6a5b      	ldrne	r3, [r3, #36]	; 0x24
  {
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
 8000830:	fa23 f000 	lsr.w	r0, r3, r0
}
 8000834:	f000 0001 	and.w	r0, r0, #1
 8000838:	4770      	bx	lr

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 800083a:	4b04      	ldr	r3, [pc, #16]	; (800084c <RCC_GetFlagStatus+0x30>)
  {
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
 800083c:	f000 001f 	and.w	r0, r0, #31

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8000840:	681b      	ldr	r3, [r3, #0]
  {
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
 8000842:	fa23 f000 	lsr.w	r0, r3, r0
}
 8000846:	f000 0001 	and.w	r0, r0, #1
 800084a:	4770      	bx	lr
 800084c:	40021000 	.word	0x40021000

08000850 <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= CSR_RMVF_Set;
 8000850:	4a02      	ldr	r2, [pc, #8]	; (800085c <RCC_ClearFlag+0xc>)
 8000852:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8000854:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000858:	6253      	str	r3, [r2, #36]	; 0x24
 800085a:	4770      	bx	lr
 800085c:	40021000 	.word	0x40021000

08000860 <RCC_GetITStatus>:
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 8000860:	4b03      	ldr	r3, [pc, #12]	; (8000870 <RCC_GetITStatus+0x10>)
 8000862:	689b      	ldr	r3, [r3, #8]
  {
    bitstatus = RESET;
  }

  /* Return the RCC_IT status */
  return  bitstatus;
 8000864:	4218      	tst	r0, r3
}
 8000866:	bf14      	ite	ne
 8000868:	2001      	movne	r0, #1
 800086a:	2000      	moveq	r0, #0
 800086c:	4770      	bx	lr
 800086e:	bf00      	nop
 8000870:	40021000 	.word	0x40021000

08000874 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 8000874:	4b01      	ldr	r3, [pc, #4]	; (800087c <RCC_ClearITPendingBit+0x8>)
 8000876:	7018      	strb	r0, [r3, #0]
 8000878:	4770      	bx	lr
 800087a:	bf00      	nop
 800087c:	4002100a 	.word	0x4002100a

08000880 <USART_DeInit>:
  *   This parameter can be one of the following values: 
  *      USART1, USART2, USART3, UART4 or UART5.
  * @retval None
  */
void USART_DeInit(USART_TypeDef* USARTx)
{
 8000880:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
 8000882:	4b26      	ldr	r3, [pc, #152]	; (800091c <USART_DeInit+0x9c>)
 8000884:	4298      	cmp	r0, r3
 8000886:	d018      	beq.n	80008ba <USART_DeInit+0x3a>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  }
  else if (USARTx == USART2)
 8000888:	4b25      	ldr	r3, [pc, #148]	; (8000920 <USART_DeInit+0xa0>)
 800088a:	4298      	cmp	r0, r3
 800088c:	d021      	beq.n	80008d2 <USART_DeInit+0x52>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  }
  else if (USARTx == USART3)
 800088e:	4b25      	ldr	r3, [pc, #148]	; (8000924 <USART_DeInit+0xa4>)
 8000890:	4298      	cmp	r0, r3
 8000892:	d02a      	beq.n	80008ea <USART_DeInit+0x6a>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  }    
  else if (USARTx == UART4)
 8000894:	4b24      	ldr	r3, [pc, #144]	; (8000928 <USART_DeInit+0xa8>)
 8000896:	4298      	cmp	r0, r3
 8000898:	d033      	beq.n	8000902 <USART_DeInit+0x82>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
  }    
  else
  {
    if (USARTx == UART5)
 800089a:	4b24      	ldr	r3, [pc, #144]	; (800092c <USART_DeInit+0xac>)
 800089c:	4298      	cmp	r0, r3
 800089e:	d000      	beq.n	80008a2 <USART_DeInit+0x22>
 80008a0:	bd08      	pop	{r3, pc}
    { 
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 80008a2:	2101      	movs	r1, #1
 80008a4:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008a8:	f7ff ff98 	bl	80007dc <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    }
  }
}
 80008ac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if (USARTx == UART5)
    { 
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 80008b0:	2100      	movs	r1, #0
 80008b2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008b6:	f7ff bf91 	b.w	80007dc <RCC_APB1PeriphResetCmd>
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
 80008ba:	2101      	movs	r1, #1
 80008bc:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80008c0:	f7ff ff7e 	bl	80007c0 <RCC_APB2PeriphResetCmd>
    { 
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    }
  }
}
 80008c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 80008c8:	2100      	movs	r1, #0
 80008ca:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80008ce:	f7ff bf77 	b.w	80007c0 <RCC_APB2PeriphResetCmd>
  }
  else if (USARTx == USART2)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 80008d2:	2101      	movs	r1, #1
 80008d4:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80008d8:	f7ff ff80 	bl	80007dc <RCC_APB1PeriphResetCmd>
    { 
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    }
  }
}
 80008dc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  }
  else if (USARTx == USART2)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 80008e0:	2100      	movs	r1, #0
 80008e2:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80008e6:	f7ff bf79 	b.w	80007dc <RCC_APB1PeriphResetCmd>
  }
  else if (USARTx == USART3)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 80008ea:	2101      	movs	r1, #1
 80008ec:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80008f0:	f7ff ff74 	bl	80007dc <RCC_APB1PeriphResetCmd>
    { 
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    }
  }
}
 80008f4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  }
  else if (USARTx == USART3)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 80008f8:	2100      	movs	r1, #0
 80008fa:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80008fe:	f7ff bf6d 	b.w	80007dc <RCC_APB1PeriphResetCmd>
  }    
  else if (USARTx == UART4)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 8000902:	2101      	movs	r1, #1
 8000904:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8000908:	f7ff ff68 	bl	80007dc <RCC_APB1PeriphResetCmd>
    { 
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    }
  }
}
 800090c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  }    
  else if (USARTx == UART4)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 8000910:	2100      	movs	r1, #0
 8000912:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8000916:	f7ff bf61 	b.w	80007dc <RCC_APB1PeriphResetCmd>
 800091a:	bf00      	nop
 800091c:	40013800 	.word	0x40013800
 8000920:	40004400 	.word	0x40004400
 8000924:	40004800 	.word	0x40004800
 8000928:	40004c00 	.word	0x40004c00
 800092c:	40005000 	.word	0x40005000

08000930 <USART_Init>:
  *         that contains the configuration information for the specified USART 
  *         peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8000930:	b530      	push	{r4, r5, lr}
 8000932:	4604      	mov	r4, r0
 8000934:	460d      	mov	r5, r1
  }

  usartxbase = (uint32_t)USARTx;

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8000936:	8a03      	ldrh	r3, [r0, #16]
 8000938:	88ca      	ldrh	r2, [r1, #6]
 800093a:	b29b      	uxth	r3, r3
 800093c:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8000940:	4313      	orrs	r3, r2
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8000942:	8203      	strh	r3, [r0, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8000944:	8982      	ldrh	r2, [r0, #12]
 8000946:	890b      	ldrh	r3, [r1, #8]
 8000948:	8888      	ldrh	r0, [r1, #4]
 800094a:	b292      	uxth	r2, r2
 800094c:	8949      	ldrh	r1, [r1, #10]
 800094e:	4303      	orrs	r3, r0
 8000950:	f422 52b0 	bic.w	r2, r2, #5632	; 0x1600
 8000954:	430b      	orrs	r3, r1
 8000956:	f022 020c 	bic.w	r2, r2, #12
 800095a:	4313      	orrs	r3, r2
 800095c:	b29b      	uxth	r3, r3
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;
  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 800095e:	81a3      	strh	r3, [r4, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8000960:	8aa3      	ldrh	r3, [r4, #20]
 8000962:	89aa      	ldrh	r2, [r5, #12]
 8000964:	b29b      	uxth	r3, r3
 8000966:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  *         that contains the configuration information for the specified USART 
  *         peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800096a:	b087      	sub	sp, #28
 800096c:	4313      	orrs	r3, r2
  tmpreg &= CR3_CLEAR_Mask;
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 800096e:	82a3      	strh	r3, [r4, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8000970:	a801      	add	r0, sp, #4
 8000972:	f7ff feaf 	bl	80006d4 <RCC_GetClocksFreq>
  if (usartxbase == USART1_BASE)
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8000976:	9904      	ldr	r1, [sp, #16]
  USARTx->CR3 = (uint16_t)tmpreg;

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  if (usartxbase == USART1_BASE)
 8000978:	481a      	ldr	r0, [pc, #104]	; (80009e4 <USART_Init+0xb4>)
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 800097a:	9b03      	ldr	r3, [sp, #12]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 800097c:	89a2      	ldrh	r2, [r4, #12]
/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  if (usartxbase == USART1_BASE)
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 800097e:	4284      	cmp	r4, r0
 8000980:	bf08      	it	eq
 8000982:	460b      	moveq	r3, r1
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8000984:	f412 4f00 	tst.w	r2, #32768	; 0x8000
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8000988:	682a      	ldr	r2, [r5, #0]
 800098a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800098e:	bf14      	ite	ne
 8000990:	0052      	lslne	r2, r2, #1
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8000992:	0092      	lsleq	r2, r2, #2
 8000994:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000998:	fbb3 f3f2 	udiv	r3, r3, r2
  }
  tmpreg = (integerdivider / 100) << 4;
 800099c:	4d12      	ldr	r5, [pc, #72]	; (80009e8 <USART_Init+0xb8>)

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 800099e:	89a1      	ldrh	r1, [r4, #12]
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
  }
  tmpreg = (integerdivider / 100) << 4;
 80009a0:	fba5 2003 	umull	r2, r0, r5, r3

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 80009a4:	2264      	movs	r2, #100	; 0x64
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
  }
  tmpreg = (integerdivider / 100) << 4;
 80009a6:	0940      	lsrs	r0, r0, #5

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 80009a8:	fb00 3312 	mls	r3, r0, r2, r3

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 80009ac:	040a      	lsls	r2, r1, #16
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
  }
  tmpreg = (integerdivider / 100) << 4;

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 80009ae:	ea4f 1000 	mov.w	r0, r0, lsl #4

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 80009b2:	d40a      	bmi.n	80009ca <USART_Init+0x9a>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 80009b4:	011a      	lsls	r2, r3, #4
 80009b6:	3232      	adds	r2, #50	; 0x32
 80009b8:	fba5 2302 	umull	r2, r3, r5, r2
 80009bc:	f3c3 1343 	ubfx	r3, r3, #5, #4
 80009c0:	4303      	orrs	r3, r0
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)tmpreg;
 80009c2:	b29b      	uxth	r3, r3
 80009c4:	8123      	strh	r3, [r4, #8]
}
 80009c6:	b007      	add	sp, #28
 80009c8:	bd30      	pop	{r4, r5, pc}
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 80009ca:	00d9      	lsls	r1, r3, #3
 80009cc:	3132      	adds	r1, #50	; 0x32
 80009ce:	fba5 3101 	umull	r3, r1, r5, r1
 80009d2:	f3c1 1242 	ubfx	r2, r1, #5, #3
 80009d6:	ea42 0300 	orr.w	r3, r2, r0
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)tmpreg;
 80009da:	b29b      	uxth	r3, r3
 80009dc:	8123      	strh	r3, [r4, #8]
}
 80009de:	b007      	add	sp, #28
 80009e0:	bd30      	pop	{r4, r5, pc}
 80009e2:	bf00      	nop
 80009e4:	40013800 	.word	0x40013800
 80009e8:	51eb851f 	.word	0x51eb851f

080009ec <USART_StructInit>:
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 80009ec:	2300      	movs	r3, #0
  * @retval None
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
 80009ee:	f44f 5116 	mov.w	r1, #9600	; 0x2580
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
  USART_InitStruct->USART_Parity = USART_Parity_No ;
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80009f2:	220c      	movs	r2, #12
  * @retval None
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
 80009f4:	6001      	str	r1, [r0, #0]
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
  USART_InitStruct->USART_Parity = USART_Parity_No ;
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80009f6:	8142      	strh	r2, [r0, #10]
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 80009f8:	8083      	strh	r3, [r0, #4]
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
 80009fa:	80c3      	strh	r3, [r0, #6]
  USART_InitStruct->USART_Parity = USART_Parity_No ;
 80009fc:	8103      	strh	r3, [r0, #8]
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 80009fe:	8183      	strh	r3, [r0, #12]
 8000a00:	4770      	bx	lr
 8000a02:	bf00      	nop

08000a04 <USART_ClockInit>:
  *         USART peripheral.  
  * @note The Smart Card and Synchronous modes are not available for UART4 and UART5.
  * @retval None
  */
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
{
 8000a04:	b430      	push	{r4, r5}
 8000a06:	884b      	ldrh	r3, [r1, #2]
 8000a08:	880d      	ldrh	r5, [r1, #0]
 8000a0a:	888c      	ldrh	r4, [r1, #4]
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8000a0c:	8a02      	ldrh	r2, [r0, #16]
 8000a0e:	432b      	orrs	r3, r5
 8000a10:	88c9      	ldrh	r1, [r1, #6]
 8000a12:	4323      	orrs	r3, r4
 8000a14:	b292      	uxth	r2, r2
 8000a16:	430b      	orrs	r3, r1
 8000a18:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
 8000a1c:	4313      	orrs	r3, r2
 8000a1e:	b29b      	uxth	r3, r3
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8000a20:	8203      	strh	r3, [r0, #16]
}
 8000a22:	bc30      	pop	{r4, r5}
 8000a24:	4770      	bx	lr
 8000a26:	bf00      	nop

08000a28 <USART_ClockStructInit>:
  * @retval None
  */
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
{
  /* USART_ClockInitStruct members default value */
  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 8000a28:	2300      	movs	r3, #0
 8000a2a:	8003      	strh	r3, [r0, #0]
  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 8000a2c:	8043      	strh	r3, [r0, #2]
  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 8000a2e:	8083      	strh	r3, [r0, #4]
  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 8000a30:	80c3      	strh	r3, [r0, #6]
 8000a32:	4770      	bx	lr

08000a34 <USART_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
 8000a34:	8983      	ldrh	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8000a36:	b929      	cbnz	r1, 8000a44 <USART_Cmd+0x10>
    USARTx->CR1 |= CR1_UE_Set;
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
 8000a38:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8000a3c:	041b      	lsls	r3, r3, #16
 8000a3e:	0c1b      	lsrs	r3, r3, #16
 8000a40:	8183      	strh	r3, [r0, #12]
 8000a42:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
 8000a44:	b29b      	uxth	r3, r3
 8000a46:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000a4a:	8183      	strh	r3, [r0, #12]
 8000a4c:	4770      	bx	lr
 8000a4e:	bf00      	nop

08000a50 <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 8000a50:	b410      	push	{r4}
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
 8000a52:	f001 041f 	and.w	r4, r1, #31
  }   
  
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8000a56:	f3c1 1142 	ubfx	r1, r1, #5, #3

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
 8000a5a:	2301      	movs	r3, #1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8000a5c:	2901      	cmp	r1, #1
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
 8000a5e:	fa03 f304 	lsl.w	r3, r3, r4
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8000a62:	d00f      	beq.n	8000a84 <USART_ITConfig+0x34>
  {
    usartxbase += 0x0C;
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 8000a64:	2902      	cmp	r1, #2
  {
    usartxbase += 0x10;
 8000a66:	bf0c      	ite	eq
 8000a68:	3010      	addeq	r0, #16
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 8000a6a:	3014      	addne	r0, #20
  }
  if (NewState != DISABLE)
 8000a6c:	b92a      	cbnz	r2, 8000a7a <USART_ITConfig+0x2a>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8000a6e:	6802      	ldr	r2, [r0, #0]
  }
}
 8000a70:	bc10      	pop	{r4}
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8000a72:	ea22 0303 	bic.w	r3, r2, r3
 8000a76:	6003      	str	r3, [r0, #0]
  }
}
 8000a78:	4770      	bx	lr
  {
    usartxbase += 0x14; 
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8000a7a:	6802      	ldr	r2, [r0, #0]
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
  }
}
 8000a7c:	bc10      	pop	{r4}
  {
    usartxbase += 0x14; 
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8000a7e:	4313      	orrs	r3, r2
 8000a80:	6003      	str	r3, [r0, #0]
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
  }
}
 8000a82:	4770      	bx	lr
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
  {
    usartxbase += 0x0C;
 8000a84:	300c      	adds	r0, #12
 8000a86:	e7f1      	b.n	8000a6c <USART_ITConfig+0x1c>

08000a88 <USART_DMACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  if (NewState != DISABLE)
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 8000a88:	8a83      	ldrh	r3, [r0, #20]
 8000a8a:	b29b      	uxth	r3, r3
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  if (NewState != DISABLE)
 8000a8c:	b91a      	cbnz	r2, 8000a96 <USART_DMACmd+0xe>
  }
  else
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
 8000a8e:	ea23 0101 	bic.w	r1, r3, r1
 8000a92:	8281      	strh	r1, [r0, #20]
 8000a94:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  if (NewState != DISABLE)
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 8000a96:	4319      	orrs	r1, r3
 8000a98:	8281      	strh	r1, [r0, #20]
 8000a9a:	4770      	bx	lr

08000a9c <USART_SetAddress>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_ADDRESS(USART_Address)); 
    
  /* Clear the USART address */
  USARTx->CR2 &= CR2_Address_Mask;
 8000a9c:	8a03      	ldrh	r3, [r0, #16]
 8000a9e:	f023 030f 	bic.w	r3, r3, #15
 8000aa2:	041b      	lsls	r3, r3, #16
 8000aa4:	0c1b      	lsrs	r3, r3, #16
 8000aa6:	8203      	strh	r3, [r0, #16]
  /* Set the USART address node */
  USARTx->CR2 |= USART_Address;
 8000aa8:	8a03      	ldrh	r3, [r0, #16]
 8000aaa:	b29b      	uxth	r3, r3
 8000aac:	4319      	orrs	r1, r3
 8000aae:	8201      	strh	r1, [r0, #16]
 8000ab0:	4770      	bx	lr
 8000ab2:	bf00      	nop

08000ab4 <USART_WakeUpConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_WAKEUP(USART_WakeUp));
  
  USARTx->CR1 &= CR1_WAKE_Mask;
 8000ab4:	8983      	ldrh	r3, [r0, #12]
 8000ab6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000aba:	041b      	lsls	r3, r3, #16
 8000abc:	0c1b      	lsrs	r3, r3, #16
 8000abe:	8183      	strh	r3, [r0, #12]
  USARTx->CR1 |= USART_WakeUp;
 8000ac0:	8983      	ldrh	r3, [r0, #12]
 8000ac2:	b29b      	uxth	r3, r3
 8000ac4:	4319      	orrs	r1, r3
 8000ac6:	8181      	strh	r1, [r0, #12]
 8000ac8:	4770      	bx	lr
 8000aca:	bf00      	nop

08000acc <USART_ReceiverWakeUpCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
  {
    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    USARTx->CR1 |= CR1_RWU_Set;
 8000acc:	8983      	ldrh	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
 8000ace:	b929      	cbnz	r1, 8000adc <USART_ReceiverWakeUpCmd+0x10>
    USARTx->CR1 |= CR1_RWU_Set;
  }
  else
  {
    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    USARTx->CR1 &= CR1_RWU_Reset;
 8000ad0:	f023 0302 	bic.w	r3, r3, #2
 8000ad4:	041b      	lsls	r3, r3, #16
 8000ad6:	0c1b      	lsrs	r3, r3, #16
 8000ad8:	8183      	strh	r3, [r0, #12]
 8000ada:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
  {
    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    USARTx->CR1 |= CR1_RWU_Set;
 8000adc:	b29b      	uxth	r3, r3
 8000ade:	f043 0302 	orr.w	r3, r3, #2
 8000ae2:	8183      	strh	r3, [r0, #12]
 8000ae4:	4770      	bx	lr
 8000ae6:	bf00      	nop

08000ae8 <USART_LINBreakDetectLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
  
  USARTx->CR2 &= CR2_LBDL_Mask;
 8000ae8:	8a03      	ldrh	r3, [r0, #16]
 8000aea:	f023 0320 	bic.w	r3, r3, #32
 8000aee:	041b      	lsls	r3, r3, #16
 8000af0:	0c1b      	lsrs	r3, r3, #16
 8000af2:	8203      	strh	r3, [r0, #16]
  USARTx->CR2 |= USART_LINBreakDetectLength;  
 8000af4:	8a03      	ldrh	r3, [r0, #16]
 8000af6:	b29b      	uxth	r3, r3
 8000af8:	4319      	orrs	r1, r3
 8000afa:	8201      	strh	r1, [r0, #16]
 8000afc:	4770      	bx	lr
 8000afe:	bf00      	nop

08000b00 <USART_LINCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= CR2_LINEN_Set;
 8000b00:	8a03      	ldrh	r3, [r0, #16]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8000b02:	b929      	cbnz	r1, 8000b10 <USART_LINCmd+0x10>
    USARTx->CR2 |= CR2_LINEN_Set;
  }
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= CR2_LINEN_Reset;
 8000b04:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8000b08:	041b      	lsls	r3, r3, #16
 8000b0a:	0c1b      	lsrs	r3, r3, #16
 8000b0c:	8203      	strh	r3, [r0, #16]
 8000b0e:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= CR2_LINEN_Set;
 8000b10:	b29b      	uxth	r3, r3
 8000b12:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000b16:	8203      	strh	r3, [r0, #16]
 8000b18:	4770      	bx	lr
 8000b1a:	bf00      	nop

08000b1c <USART_SendData>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 8000b1c:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8000b20:	8081      	strh	r1, [r0, #4]
 8000b22:	4770      	bx	lr

08000b24 <USART_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 8000b24:	8880      	ldrh	r0, [r0, #4]
}
 8000b26:	f3c0 0008 	ubfx	r0, r0, #0, #9
 8000b2a:	4770      	bx	lr

08000b2c <USART_SendBreak>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Send break characters */
  USARTx->CR1 |= CR1_SBK_Set;
 8000b2c:	8983      	ldrh	r3, [r0, #12]
 8000b2e:	b29b      	uxth	r3, r3
 8000b30:	f043 0301 	orr.w	r3, r3, #1
 8000b34:	8183      	strh	r3, [r0, #12]
 8000b36:	4770      	bx	lr

08000b38 <USART_SetGuardTime>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  
  /* Clear the USART Guard time */
  USARTx->GTPR &= GTPR_LSB_Mask;
 8000b38:	8b03      	ldrh	r3, [r0, #24]
 8000b3a:	b2db      	uxtb	r3, r3
 8000b3c:	8303      	strh	r3, [r0, #24]
  /* Set the USART guard time */
  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 8000b3e:	8b03      	ldrh	r3, [r0, #24]
 8000b40:	b29b      	uxth	r3, r3
 8000b42:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8000b46:	8301      	strh	r1, [r0, #24]
 8000b48:	4770      	bx	lr
 8000b4a:	bf00      	nop

08000b4c <USART_SetPrescaler>:
{ 
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Clear the USART prescaler */
  USARTx->GTPR &= GTPR_MSB_Mask;
 8000b4c:	8b03      	ldrh	r3, [r0, #24]
 8000b4e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8000b52:	8303      	strh	r3, [r0, #24]
  /* Set the USART prescaler */
  USARTx->GTPR |= USART_Prescaler;
 8000b54:	8b03      	ldrh	r3, [r0, #24]
 8000b56:	b29b      	uxth	r3, r3
 8000b58:	4319      	orrs	r1, r3
 8000b5a:	8301      	strh	r1, [r0, #24]
 8000b5c:	4770      	bx	lr
 8000b5e:	bf00      	nop

08000b60 <USART_SmartCardCmd>:
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= CR3_SCEN_Set;
 8000b60:	8a83      	ldrh	r3, [r0, #20]
void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000b62:	b929      	cbnz	r1, 8000b70 <USART_SmartCardCmd+0x10>
    USARTx->CR3 |= CR3_SCEN_Set;
  }
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= CR3_SCEN_Reset;
 8000b64:	f023 0320 	bic.w	r3, r3, #32
 8000b68:	041b      	lsls	r3, r3, #16
 8000b6a:	0c1b      	lsrs	r3, r3, #16
 8000b6c:	8283      	strh	r3, [r0, #20]
 8000b6e:	4770      	bx	lr
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= CR3_SCEN_Set;
 8000b70:	b29b      	uxth	r3, r3
 8000b72:	f043 0320 	orr.w	r3, r3, #32
 8000b76:	8283      	strh	r3, [r0, #20]
 8000b78:	4770      	bx	lr
 8000b7a:	bf00      	nop

08000b7c <USART_SmartCardNACKCmd>:
  assert_param(IS_USART_123_PERIPH(USARTx));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= CR3_NACK_Set;
 8000b7c:	8a83      	ldrh	r3, [r0, #20]
void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000b7e:	b929      	cbnz	r1, 8000b8c <USART_SmartCardNACKCmd+0x10>
    USARTx->CR3 |= CR3_NACK_Set;
  }
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= CR3_NACK_Reset;
 8000b80:	f023 0310 	bic.w	r3, r3, #16
 8000b84:	041b      	lsls	r3, r3, #16
 8000b86:	0c1b      	lsrs	r3, r3, #16
 8000b88:	8283      	strh	r3, [r0, #20]
 8000b8a:	4770      	bx	lr
  assert_param(IS_USART_123_PERIPH(USARTx));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= CR3_NACK_Set;
 8000b8c:	b29b      	uxth	r3, r3
 8000b8e:	f043 0310 	orr.w	r3, r3, #16
 8000b92:	8283      	strh	r3, [r0, #20]
 8000b94:	4770      	bx	lr
 8000b96:	bf00      	nop

08000b98 <USART_HalfDuplexCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= CR3_HDSEL_Set;
 8000b98:	8a83      	ldrh	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8000b9a:	b929      	cbnz	r1, 8000ba8 <USART_HalfDuplexCmd+0x10>
    USARTx->CR3 |= CR3_HDSEL_Set;
  }
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= CR3_HDSEL_Reset;
 8000b9c:	f023 0308 	bic.w	r3, r3, #8
 8000ba0:	041b      	lsls	r3, r3, #16
 8000ba2:	0c1b      	lsrs	r3, r3, #16
 8000ba4:	8283      	strh	r3, [r0, #20]
 8000ba6:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= CR3_HDSEL_Set;
 8000ba8:	b29b      	uxth	r3, r3
 8000baa:	f043 0308 	orr.w	r3, r3, #8
 8000bae:	8283      	strh	r3, [r0, #20]
 8000bb0:	4770      	bx	lr
 8000bb2:	bf00      	nop

08000bb4 <USART_OverSampling8Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= CR1_OVER8_Set;
 8000bb4:	8983      	ldrh	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8000bb6:	b919      	cbnz	r1, 8000bc0 <USART_OverSampling8Cmd+0xc>
    USARTx->CR1 |= CR1_OVER8_Set;
  }
  else
  {
    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    USARTx->CR1 &= CR1_OVER8_Reset;
 8000bb8:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8000bbc:	8183      	strh	r3, [r0, #12]
 8000bbe:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= CR1_OVER8_Set;
 8000bc0:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8000bc4:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8000bc8:	b29b      	uxth	r3, r3
 8000bca:	8183      	strh	r3, [r0, #12]
 8000bcc:	4770      	bx	lr
 8000bce:	bf00      	nop

08000bd0 <USART_OneBitMethodCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= CR3_ONEBITE_Set;
 8000bd0:	8a83      	ldrh	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8000bd2:	b929      	cbnz	r1, 8000be0 <USART_OneBitMethodCmd+0x10>
    USARTx->CR3 |= CR3_ONEBITE_Set;
  }
  else
  {
    /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
    USARTx->CR3 &= CR3_ONEBITE_Reset;
 8000bd4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000bd8:	041b      	lsls	r3, r3, #16
 8000bda:	0c1b      	lsrs	r3, r3, #16
 8000bdc:	8283      	strh	r3, [r0, #20]
 8000bde:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= CR3_ONEBITE_Set;
 8000be0:	b29b      	uxth	r3, r3
 8000be2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000be6:	8283      	strh	r3, [r0, #20]
 8000be8:	4770      	bx	lr
 8000bea:	bf00      	nop

08000bec <USART_IrDAConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
    
  USARTx->CR3 &= CR3_IRLP_Mask;
 8000bec:	8a83      	ldrh	r3, [r0, #20]
 8000bee:	f023 0304 	bic.w	r3, r3, #4
 8000bf2:	041b      	lsls	r3, r3, #16
 8000bf4:	0c1b      	lsrs	r3, r3, #16
 8000bf6:	8283      	strh	r3, [r0, #20]
  USARTx->CR3 |= USART_IrDAMode;
 8000bf8:	8a83      	ldrh	r3, [r0, #20]
 8000bfa:	b29b      	uxth	r3, r3
 8000bfc:	4319      	orrs	r1, r3
 8000bfe:	8281      	strh	r1, [r0, #20]
 8000c00:	4770      	bx	lr
 8000c02:	bf00      	nop

08000c04 <USART_IrDACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= CR3_IREN_Set;
 8000c04:	8a83      	ldrh	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 8000c06:	b929      	cbnz	r1, 8000c14 <USART_IrDACmd+0x10>
    USARTx->CR3 |= CR3_IREN_Set;
  }
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= CR3_IREN_Reset;
 8000c08:	f023 0302 	bic.w	r3, r3, #2
 8000c0c:	041b      	lsls	r3, r3, #16
 8000c0e:	0c1b      	lsrs	r3, r3, #16
 8000c10:	8283      	strh	r3, [r0, #20]
 8000c12:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= CR3_IREN_Set;
 8000c14:	b29b      	uxth	r3, r3
 8000c16:	f043 0302 	orr.w	r3, r3, #2
 8000c1a:	8283      	strh	r3, [r0, #20]
 8000c1c:	4770      	bx	lr
 8000c1e:	bf00      	nop

08000c20 <USART_GetFlagStatus>:
  if (USART_FLAG == USART_FLAG_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }  
  
  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 8000c20:	8803      	ldrh	r3, [r0, #0]
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 8000c22:	4219      	tst	r1, r3
}
 8000c24:	bf14      	ite	ne
 8000c26:	2001      	movne	r0, #1
 8000c28:	2000      	moveq	r0, #0
 8000c2a:	4770      	bx	lr

08000c2c <USART_ClearFlag>:
  if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  } 
   
  USARTx->SR = (uint16_t)~USART_FLAG;
 8000c2c:	43c9      	mvns	r1, r1
 8000c2e:	b289      	uxth	r1, r1
 8000c30:	8001      	strh	r1, [r0, #0]
 8000c32:	4770      	bx	lr

08000c34 <USART_GetITStatus>:
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8000c34:	f3c1 1242 	ubfx	r2, r1, #5, #3
  *     @arg USART_IT_FE:   Framing Error interrupt
  *     @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8000c38:	b410      	push	{r4}
  
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;
  itmask = (uint32_t)0x01 << itmask;
 8000c3a:	2301      	movs	r3, #1
  }   
  
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;
 8000c3c:	f001 041f 	and.w	r4, r1, #31
  itmask = (uint32_t)0x01 << itmask;
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8000c40:	2a01      	cmp	r2, #1
  
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;
  itmask = (uint32_t)0x01 << itmask;
 8000c42:	fa03 f304 	lsl.w	r3, r3, r4
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8000c46:	d015      	beq.n	8000c74 <USART_GetITStatus+0x40>
  {
    itmask &= USARTx->CR1;
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 8000c48:	2a02      	cmp	r2, #2
  {
    itmask &= USARTx->CR2;
 8000c4a:	bf0c      	ite	eq
 8000c4c:	8a02      	ldrheq	r2, [r0, #16]
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 8000c4e:	8a82      	ldrhne	r2, [r0, #20]
 8000c50:	b292      	uxth	r2, r2
 8000c52:	4013      	ands	r3, r2
  }
  
  bitpos = USART_IT >> 0x08;
  bitpos = (uint32_t)0x01 << bitpos;
  bitpos &= USARTx->SR;
 8000c54:	8802      	ldrh	r2, [r0, #0]
 8000c56:	b292      	uxth	r2, r2
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8000c58:	b14b      	cbz	r3, 8000c6e <USART_GetITStatus+0x3a>
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x08;
  bitpos = (uint32_t)0x01 << bitpos;
 8000c5a:	2301      	movs	r3, #1
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x08;
 8000c5c:	0a09      	lsrs	r1, r1, #8
  bitpos = (uint32_t)0x01 << bitpos;
 8000c5e:	fa03 f101 	lsl.w	r1, r3, r1
  bitpos &= USARTx->SR;
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
  {
    bitstatus = SET;
 8000c62:	420a      	tst	r2, r1
 8000c64:	bf14      	ite	ne
 8000c66:	4618      	movne	r0, r3
 8000c68:	2000      	moveq	r0, #0
  {
    bitstatus = RESET;
  }
  
  return bitstatus;  
}
 8000c6a:	bc10      	pop	{r4}
 8000c6c:	4770      	bx	lr
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8000c6e:	4618      	mov	r0, r3
  }
  
  return bitstatus;  
}
 8000c70:	bc10      	pop	{r4}
 8000c72:	4770      	bx	lr
  itmask = USART_IT & IT_Mask;
  itmask = (uint32_t)0x01 << itmask;
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
  {
    itmask &= USARTx->CR1;
 8000c74:	8982      	ldrh	r2, [r0, #12]
 8000c76:	b292      	uxth	r2, r2
 8000c78:	4013      	ands	r3, r2
 8000c7a:	e7eb      	b.n	8000c54 <USART_GetITStatus+0x20>

08000c7c <USART_ClearITPendingBit>:
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  bitpos = USART_IT >> 0x08;
  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
  USARTx->SR = (uint16_t)~itmask;
 8000c7c:	0a09      	lsrs	r1, r1, #8
 8000c7e:	2301      	movs	r3, #1
 8000c80:	fa03 f101 	lsl.w	r1, r3, r1
 8000c84:	43c9      	mvns	r1, r1
 8000c86:	b289      	uxth	r1, r1
 8000c88:	8001      	strh	r1, [r0, #0]
 8000c8a:	4770      	bx	lr

08000c8c <strcmp>:
 8000c8c:	ea80 0c01 	eor.w	ip, r0, r1
 8000c90:	f01c 0f03 	tst.w	ip, #3
 8000c94:	d137      	bne.n	8000d06 <strcmp+0x7a>
 8000c96:	f010 0c03 	ands.w	ip, r0, #3
 8000c9a:	f020 0003 	bic.w	r0, r0, #3
 8000c9e:	f021 0103 	bic.w	r1, r1, #3
 8000ca2:	f850 2b04 	ldr.w	r2, [r0], #4
 8000ca6:	bf08      	it	eq
 8000ca8:	f851 3b04 	ldreq.w	r3, [r1], #4
 8000cac:	d00e      	beq.n	8000ccc <strcmp+0x40>
 8000cae:	f08c 0c03 	eor.w	ip, ip, #3
 8000cb2:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8000cb6:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8000cba:	fa23 fc0c 	lsr.w	ip, r3, ip
 8000cbe:	f851 3b04 	ldr.w	r3, [r1], #4
 8000cc2:	ea42 020c 	orr.w	r2, r2, ip
 8000cc6:	ea43 030c 	orr.w	r3, r3, ip
 8000cca:	bf00      	nop
 8000ccc:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8000cd0:	429a      	cmp	r2, r3
 8000cd2:	bf01      	itttt	eq
 8000cd4:	ea2c 0c02 	biceq.w	ip, ip, r2
 8000cd8:	f01c 3f80 	tsteq.w	ip, #2155905152	; 0x80808080
 8000cdc:	f850 2b04 	ldreq.w	r2, [r0], #4
 8000ce0:	f851 3b04 	ldreq.w	r3, [r1], #4
 8000ce4:	d0f2      	beq.n	8000ccc <strcmp+0x40>
 8000ce6:	ea4f 6002 	mov.w	r0, r2, lsl #24
 8000cea:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8000cee:	2801      	cmp	r0, #1
 8000cf0:	bf28      	it	cs
 8000cf2:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
 8000cf6:	bf08      	it	eq
 8000cf8:	0a1b      	lsreq	r3, r3, #8
 8000cfa:	d0f4      	beq.n	8000ce6 <strcmp+0x5a>
 8000cfc:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000d00:	0e00      	lsrs	r0, r0, #24
 8000d02:	1ac0      	subs	r0, r0, r3
 8000d04:	4770      	bx	lr
 8000d06:	f010 0f03 	tst.w	r0, #3
 8000d0a:	d00a      	beq.n	8000d22 <strcmp+0x96>
 8000d0c:	f810 2b01 	ldrb.w	r2, [r0], #1
 8000d10:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000d14:	2a01      	cmp	r2, #1
 8000d16:	bf28      	it	cs
 8000d18:	429a      	cmpcs	r2, r3
 8000d1a:	d0f4      	beq.n	8000d06 <strcmp+0x7a>
 8000d1c:	eba2 0003 	sub.w	r0, r2, r3
 8000d20:	4770      	bx	lr
 8000d22:	f84d 5d04 	str.w	r5, [sp, #-4]!
 8000d26:	f850 2b04 	ldr.w	r2, [r0], #4
 8000d2a:	f001 0503 	and.w	r5, r1, #3
 8000d2e:	f021 0103 	bic.w	r1, r1, #3
 8000d32:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d36:	2d02      	cmp	r5, #2
 8000d38:	d026      	beq.n	8000d88 <strcmp+0xfc>
 8000d3a:	d84d      	bhi.n	8000dd8 <strcmp+0x14c>
 8000d3c:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
 8000d40:	ebb5 2f13 	cmp.w	r5, r3, lsr #8
 8000d44:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8000d48:	ea2c 0c02 	bic.w	ip, ip, r2
 8000d4c:	d10d      	bne.n	8000d6a <strcmp+0xde>
 8000d4e:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 8000d52:	bf08      	it	eq
 8000d54:	f851 3b04 	ldreq.w	r3, [r1], #4
 8000d58:	d10a      	bne.n	8000d70 <strcmp+0xe4>
 8000d5a:	ea85 0502 	eor.w	r5, r5, r2
 8000d5e:	ebb5 6f03 	cmp.w	r5, r3, lsl #24
 8000d62:	d10c      	bne.n	8000d7e <strcmp+0xf2>
 8000d64:	f850 2b04 	ldr.w	r2, [r0], #4
 8000d68:	e7e8      	b.n	8000d3c <strcmp+0xb0>
 8000d6a:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000d6e:	e05b      	b.n	8000e28 <strcmp+0x19c>
 8000d70:	f03c 4c7f 	bics.w	ip, ip, #4278190080	; 0xff000000
 8000d74:	d154      	bne.n	8000e20 <strcmp+0x194>
 8000d76:	780b      	ldrb	r3, [r1, #0]
 8000d78:	ea4f 6512 	mov.w	r5, r2, lsr #24
 8000d7c:	e054      	b.n	8000e28 <strcmp+0x19c>
 8000d7e:	ea4f 6512 	mov.w	r5, r2, lsr #24
 8000d82:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000d86:	e04f      	b.n	8000e28 <strcmp+0x19c>
 8000d88:	ea4f 4502 	mov.w	r5, r2, lsl #16
 8000d8c:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8000d90:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8000d94:	ea2c 0c02 	bic.w	ip, ip, r2
 8000d98:	ebb5 4f13 	cmp.w	r5, r3, lsr #16
 8000d9c:	d118      	bne.n	8000dd0 <strcmp+0x144>
 8000d9e:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 8000da2:	bf08      	it	eq
 8000da4:	f851 3b04 	ldreq.w	r3, [r1], #4
 8000da8:	d107      	bne.n	8000dba <strcmp+0x12e>
 8000daa:	ea85 0502 	eor.w	r5, r5, r2
 8000dae:	ebb5 4f03 	cmp.w	r5, r3, lsl #16
 8000db2:	d109      	bne.n	8000dc8 <strcmp+0x13c>
 8000db4:	f850 2b04 	ldr.w	r2, [r0], #4
 8000db8:	e7e6      	b.n	8000d88 <strcmp+0xfc>
 8000dba:	ea5f 4c0c 	movs.w	ip, ip, lsl #16
 8000dbe:	d12f      	bne.n	8000e20 <strcmp+0x194>
 8000dc0:	880b      	ldrh	r3, [r1, #0]
 8000dc2:	ea4f 4512 	mov.w	r5, r2, lsr #16
 8000dc6:	e02f      	b.n	8000e28 <strcmp+0x19c>
 8000dc8:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8000dcc:	ea4f 4512 	mov.w	r5, r2, lsr #16
 8000dd0:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8000dd4:	e028      	b.n	8000e28 <strcmp+0x19c>
 8000dd6:	bf00      	nop
 8000dd8:	f002 05ff 	and.w	r5, r2, #255	; 0xff
 8000ddc:	ebb5 6f13 	cmp.w	r5, r3, lsr #24
 8000de0:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8000de4:	ea2c 0c02 	bic.w	ip, ip, r2
 8000de8:	d10d      	bne.n	8000e06 <strcmp+0x17a>
 8000dea:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 8000dee:	bf08      	it	eq
 8000df0:	f851 3b04 	ldreq.w	r3, [r1], #4
 8000df4:	d10a      	bne.n	8000e0c <strcmp+0x180>
 8000df6:	ea85 0502 	eor.w	r5, r5, r2
 8000dfa:	ebb5 2f03 	cmp.w	r5, r3, lsl #8
 8000dfe:	d10a      	bne.n	8000e16 <strcmp+0x18a>
 8000e00:	f850 2b04 	ldr.w	r2, [r0], #4
 8000e04:	e7e8      	b.n	8000dd8 <strcmp+0x14c>
 8000e06:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8000e0a:	e00d      	b.n	8000e28 <strcmp+0x19c>
 8000e0c:	f012 0fff 	tst.w	r2, #255	; 0xff
 8000e10:	d006      	beq.n	8000e20 <strcmp+0x194>
 8000e12:	f851 3b04 	ldr.w	r3, [r1], #4
 8000e16:	ea4f 2512 	mov.w	r5, r2, lsr #8
 8000e1a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000e1e:	e003      	b.n	8000e28 <strcmp+0x19c>
 8000e20:	f04f 0000 	mov.w	r0, #0
 8000e24:	bc20      	pop	{r5}
 8000e26:	4770      	bx	lr
 8000e28:	f005 02ff 	and.w	r2, r5, #255	; 0xff
 8000e2c:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8000e30:	2801      	cmp	r0, #1
 8000e32:	bf28      	it	cs
 8000e34:	4290      	cmpcs	r0, r2
 8000e36:	bf04      	itt	eq
 8000e38:	0a2d      	lsreq	r5, r5, #8
 8000e3a:	0a1b      	lsreq	r3, r3, #8
 8000e3c:	d0f4      	beq.n	8000e28 <strcmp+0x19c>
 8000e3e:	eba2 0000 	sub.w	r0, r2, r0
 8000e42:	bc20      	pop	{r5}
 8000e44:	4770      	bx	lr
 8000e46:	bf00      	nop

08000e48 <task_life>:
void prvSetupHardware(void) {
	sys_cfg_console();
	led_life_init();
}

void task_life(void *dummy) {
 8000e48:	b508      	push	{r3, lr}
	(void)dummy;

	while (1) {
		led_life_on();
 8000e4a:	f000 f8f5 	bl	8001038 <led_life_on>
		vTaskDelay(600);
 8000e4e:	f44f 7016 	mov.w	r0, #600	; 0x258
 8000e52:	f000 fb97 	bl	8001584 <vTaskDelay>
		led_life_off();
 8000e56:	f000 f8f5 	bl	8001044 <led_life_off>
		vTaskDelay(600);
 8000e5a:	f44f 7016 	mov.w	r0, #600	; 0x258
 8000e5e:	f000 fb91 	bl	8001584 <vTaskDelay>
 8000e62:	e7f2      	b.n	8000e4a <task_life+0x2>

08000e64 <systemConsole>:
	}
}

void systemConsole(void *dummy) {
 8000e64:	b508      	push	{r3, lr}
	(void)dummy;

	while (1) {
		if (cmd_flag) {
 8000e66:	4c06      	ldr	r4, [pc, #24]	; (8000e80 <systemConsole+0x1c>)
			task_shell(shell.data);
			cmd_flag = 0;
 8000e68:	2500      	movs	r5, #0

void systemConsole(void *dummy) {
	(void)dummy;

	while (1) {
		if (cmd_flag) {
 8000e6a:	7823      	ldrb	r3, [r4, #0]
 8000e6c:	b11b      	cbz	r3, 8000e76 <systemConsole+0x12>
			task_shell(shell.data);
 8000e6e:	4805      	ldr	r0, [pc, #20]	; (8000e84 <systemConsole+0x20>)
 8000e70:	f000 fed2 	bl	8001c18 <task_shell>
			cmd_flag = 0;
 8000e74:	7025      	strb	r5, [r4, #0]
		}
		vTaskDelay(10);
 8000e76:	200a      	movs	r0, #10
 8000e78:	f000 fb84 	bl	8001584 <vTaskDelay>
	}
 8000e7c:	e7f5      	b.n	8000e6a <systemConsole+0x6>
 8000e7e:	bf00      	nop
 8000e80:	2000068c 	.word	0x2000068c
 8000e84:	2000102e 	.word	0x2000102e

08000e88 <prvSetupHardware>:

static __IO uint32_t TimingDelay;

uint8_t cmd_flag = 0;

void prvSetupHardware(void) {
 8000e88:	b508      	push	{r3, lr}
	sys_cfg_console();
 8000e8a:	f000 fe25 	bl	8001ad8 <sys_cfg_console>
	led_life_init();
}
 8000e8e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

uint8_t cmd_flag = 0;

void prvSetupHardware(void) {
	sys_cfg_console();
	led_life_init();
 8000e92:	f000 b8b9 	b.w	8001008 <led_life_init>
	...

08000e98 <vTaskInit>:
		}
		vTaskDelay(10);
	}
}

void vTaskInit(void) {
 8000e98:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	xTaskCreate(task_life,
 8000e9a:	2400      	movs	r4, #0
 8000e9c:	2301      	movs	r3, #1
 8000e9e:	9300      	str	r3, [sp, #0]
 8000ea0:	9403      	str	r4, [sp, #12]
 8000ea2:	4623      	mov	r3, r4
 8000ea4:	9402      	str	r4, [sp, #8]
 8000ea6:	9401      	str	r4, [sp, #4]
 8000ea8:	2280      	movs	r2, #128	; 0x80
 8000eaa:	4908      	ldr	r1, [pc, #32]	; (8000ecc <vTaskInit+0x34>)
 8000eac:	4808      	ldr	r0, [pc, #32]	; (8000ed0 <vTaskInit+0x38>)
 8000eae:	f000 f979 	bl	80011a4 <xTaskGenericCreate>
				configMINIMAL_STACK_SIZE,
				NULL,                 /* pvParameters */
				tskIDLE_PRIORITY + 1, /* uxPriority */
				NULL                  /* pvCreatedTask */);

	xTaskCreate(systemConsole,
 8000eb2:	2302      	movs	r3, #2
 8000eb4:	9300      	str	r3, [sp, #0]
 8000eb6:	9403      	str	r4, [sp, #12]
 8000eb8:	9402      	str	r4, [sp, #8]
 8000eba:	9401      	str	r4, [sp, #4]
 8000ebc:	4623      	mov	r3, r4
 8000ebe:	2280      	movs	r2, #128	; 0x80
 8000ec0:	4904      	ldr	r1, [pc, #16]	; (8000ed4 <vTaskInit+0x3c>)
 8000ec2:	4805      	ldr	r0, [pc, #20]	; (8000ed8 <vTaskInit+0x40>)
 8000ec4:	f000 f96e 	bl	80011a4 <xTaskGenericCreate>
				(const signed char *)"systemConsole",
				configMINIMAL_STACK_SIZE,
				NULL,                 /* pvParameters */
				tskIDLE_PRIORITY + 2, /* uxPriority */
				NULL                  /* pvCreatedTask */);
}
 8000ec8:	b004      	add	sp, #16
 8000eca:	bd10      	pop	{r4, pc}
 8000ecc:	0800218c 	.word	0x0800218c
 8000ed0:	08000e49 	.word	0x08000e49
 8000ed4:	08002196 	.word	0x08002196
 8000ed8:	08000e65 	.word	0x08000e65

08000edc <main>:
  * @brief  Main program.
  * @param  None
  * @retval None
  */

int main(void) {
 8000edc:	b508      	push	{r3, lr}
	 * this is done through SystemInit() function which is called from startup
	 * file (startup_stm32f2xx_xx.s) before to branch to application main.
	 * To reconfigure the default setting of SystemInit() function, refer to
	 * system_stm32f2xx.c file */

	prvSetupHardware();
 8000ede:	f7ff ffd3 	bl	8000e88 <prvSetupHardware>

	vTaskInit();
 8000ee2:	f7ff ffd9 	bl	8000e98 <vTaskInit>

	vTaskStartScheduler();
 8000ee6:	f000 fa27 	bl	8001338 <vTaskStartScheduler>

	return (0);
}
 8000eea:	2000      	movs	r0, #0
 8000eec:	bd08      	pop	{r3, pc}

08000eee <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8000eee:	4770      	bx	lr

08000ef0 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8000ef0:	e7fe      	b.n	8000ef0 <HardFault_Handler>
	...

08000ef4 <USART1_IRQHandler>:
	while (1)
	{
	}
}

void USART1_IRQHandler(void) {
 8000ef4:	b508      	push	{r3, lr}
	if (USART_GetITStatus(USARTx, USART_IT_RXNE) == SET) {
 8000ef6:	f240 5125 	movw	r1, #1317	; 0x525
 8000efa:	4805      	ldr	r0, [pc, #20]	; (8000f10 <USART1_IRQHandler+0x1c>)
 8000efc:	f7ff fe9a 	bl	8000c34 <USART_GetITStatus>
 8000f00:	2801      	cmp	r0, #1
 8000f02:	d103      	bne.n	8000f0c <USART1_IRQHandler+0x18>
		sys_irq_shell();
	}
}
 8000f04:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	}
}

void USART1_IRQHandler(void) {
	if (USART_GetITStatus(USARTx, USART_IT_RXNE) == SET) {
		sys_irq_shell();
 8000f08:	f000 be5e 	b.w	8001bc8 <sys_irq_shell>
 8000f0c:	bd08      	pop	{r3, pc}
 8000f0e:	bf00      	nop
 8000f10:	40013800 	.word	0x40013800

08000f14 <SystemInit>:
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000f14:	4b38      	ldr	r3, [pc, #224]	; (8000ff8 <SystemInit+0xe4>)
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8000f16:	b082      	sub	sp, #8
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000f18:	681a      	ldr	r2, [r3, #0]
 8000f1a:	f042 0201 	orr.w	r2, r2, #1
 8000f1e:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8000f20:	6859      	ldr	r1, [r3, #4]
 8000f22:	4a36      	ldr	r2, [pc, #216]	; (8000ffc <SystemInit+0xe8>)
 8000f24:	400a      	ands	r2, r1
 8000f26:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000f28:	681a      	ldr	r2, [r3, #0]
 8000f2a:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8000f2e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000f32:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000f34:	681a      	ldr	r2, [r3, #0]
 8000f36:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000f3a:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8000f3c:	685a      	ldr	r2, [r3, #4]
 8000f3e:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8000f42:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8000f44:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 8000f48:	609a      	str	r2, [r3, #8]
  * @param  None
  * @retval None
  */
static void SetSysClockTo72(void)
{
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8000f4a:	2200      	movs	r2, #0
 8000f4c:	9200      	str	r2, [sp, #0]
 8000f4e:	9201      	str	r2, [sp, #4]
  
  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8000f50:	681a      	ldr	r2, [r3, #0]
 8000f52:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000f56:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8000f58:	681a      	ldr	r2, [r3, #0]
 8000f5a:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 8000f5e:	9201      	str	r2, [sp, #4]
    StartUpCounter++;  
 8000f60:	9a00      	ldr	r2, [sp, #0]
 8000f62:	3201      	adds	r2, #1
 8000f64:	9200      	str	r2, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8000f66:	9a01      	ldr	r2, [sp, #4]
 8000f68:	b91a      	cbnz	r2, 8000f72 <SystemInit+0x5e>
 8000f6a:	9a00      	ldr	r2, [sp, #0]
 8000f6c:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 8000f70:	d1f2      	bne.n	8000f58 <SystemInit+0x44>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8000f72:	681a      	ldr	r2, [r3, #0]
 8000f74:	f412 3200 	ands.w	r2, r2, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 8000f78:	bf18      	it	ne
 8000f7a:	2201      	movne	r2, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8000f7c:	9201      	str	r2, [sp, #4]
  }  

  if (HSEStatus == (uint32_t)0x01)
 8000f7e:	9a01      	ldr	r2, [sp, #4]
 8000f80:	2a01      	cmp	r2, #1
 8000f82:	d005      	beq.n	8000f90 <SystemInit+0x7c>
  SetSysClock();

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8000f84:	4b1e      	ldr	r3, [pc, #120]	; (8001000 <SystemInit+0xec>)
 8000f86:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000f8a:	609a      	str	r2, [r3, #8]
#endif 
}
 8000f8c:	b002      	add	sp, #8
 8000f8e:	4770      	bx	lr
  }  

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 8000f90:	4a1c      	ldr	r2, [pc, #112]	; (8001004 <SystemInit+0xf0>)
 8000f92:	6811      	ldr	r1, [r2, #0]
 8000f94:	f041 0110 	orr.w	r1, r1, #16
 8000f98:	6011      	str	r1, [r2, #0]

    /* Flash 2 wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
 8000f9a:	6811      	ldr	r1, [r2, #0]
 8000f9c:	f021 0107 	bic.w	r1, r1, #7
 8000fa0:	6011      	str	r1, [r2, #0]
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
 8000fa2:	6811      	ldr	r1, [r2, #0]
 8000fa4:	f041 0102 	orr.w	r1, r1, #2
 8000fa8:	6011      	str	r1, [r2, #0]

 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 8000faa:	685a      	ldr	r2, [r3, #4]
 8000fac:	605a      	str	r2, [r3, #4]
      
    /* PCLK2 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 8000fae:	685a      	ldr	r2, [r3, #4]
 8000fb0:	605a      	str	r2, [r3, #4]
    
    /* PCLK1 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
 8000fb2:	685a      	ldr	r2, [r3, #4]
 8000fb4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000fb8:	605a      	str	r2, [r3, #4]
    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
                            RCC_CFGR_PLLMULL9); 
#else    
    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
 8000fba:	685a      	ldr	r2, [r3, #4]
 8000fbc:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 8000fc0:	605a      	str	r2, [r3, #4]
                                        RCC_CFGR_PLLMULL));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
 8000fc2:	685a      	ldr	r2, [r3, #4]
 8000fc4:	f442 12e8 	orr.w	r2, r2, #1900544	; 0x1d0000
 8000fc8:	605a      	str	r2, [r3, #4]
#endif /* STM32F10X_CL */

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 8000fca:	681a      	ldr	r2, [r3, #0]
 8000fcc:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000fd0:	601a      	str	r2, [r3, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8000fd2:	6819      	ldr	r1, [r3, #0]
 8000fd4:	4a08      	ldr	r2, [pc, #32]	; (8000ff8 <SystemInit+0xe4>)
 8000fd6:	0189      	lsls	r1, r1, #6
 8000fd8:	d5fb      	bpl.n	8000fd2 <SystemInit+0xbe>
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8000fda:	6851      	ldr	r1, [r2, #4]
 8000fdc:	f021 0103 	bic.w	r1, r1, #3
 8000fe0:	6051      	str	r1, [r2, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
 8000fe2:	6851      	ldr	r1, [r2, #4]
 8000fe4:	f041 0102 	orr.w	r1, r1, #2
 8000fe8:	6051      	str	r1, [r2, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
 8000fea:	685a      	ldr	r2, [r3, #4]
 8000fec:	f002 020c 	and.w	r2, r2, #12
 8000ff0:	2a08      	cmp	r2, #8
 8000ff2:	d1fa      	bne.n	8000fea <SystemInit+0xd6>
 8000ff4:	e7c6      	b.n	8000f84 <SystemInit+0x70>
 8000ff6:	bf00      	nop
 8000ff8:	40021000 	.word	0x40021000
 8000ffc:	f8ff0000 	.word	0xf8ff0000
 8001000:	e000ed00 	.word	0xe000ed00
 8001004:	40022000 	.word	0x40022000

08001008 <led_life_init>:

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/

void led_life_init() {
 8001008:	b507      	push	{r0, r1, r2, lr}
	GPIO_InitTypeDef        GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(LED_LIFE_IO_CLOCK, ENABLE);
 800100a:	2101      	movs	r1, #1
 800100c:	2040      	movs	r0, #64	; 0x40
 800100e:	f7ff fbbb 	bl	8000788 <RCC_APB2PeriphClockCmd>

	GPIO_InitStructure.GPIO_Pin = LED_LIFE_IO_PIN;
 8001012:	2380      	movs	r3, #128	; 0x80
 8001014:	f8ad 3004 	strh.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8001018:	2310      	movs	r3, #16
 800101a:	f88d 3007 	strb.w	r3, [sp, #7]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(LED_LIFE_IO_PORT, &GPIO_InitStructure);
 800101e:	a901      	add	r1, sp, #4
	GPIO_InitTypeDef        GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(LED_LIFE_IO_CLOCK, ENABLE);

	GPIO_InitStructure.GPIO_Pin = LED_LIFE_IO_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001020:	2303      	movs	r3, #3
	GPIO_Init(LED_LIFE_IO_PORT, &GPIO_InitStructure);
 8001022:	4804      	ldr	r0, [pc, #16]	; (8001034 <led_life_init+0x2c>)
	GPIO_InitTypeDef        GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(LED_LIFE_IO_CLOCK, ENABLE);

	GPIO_InitStructure.GPIO_Pin = LED_LIFE_IO_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001024:	f88d 3006 	strb.w	r3, [sp, #6]
	GPIO_Init(LED_LIFE_IO_PORT, &GPIO_InitStructure);
 8001028:	f7ff f918 	bl	800025c <GPIO_Init>
}
 800102c:	b003      	add	sp, #12
 800102e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001032:	bf00      	nop
 8001034:	40011800 	.word	0x40011800

08001038 <led_life_on>:

void led_life_on() {
	GPIO_SetBits(LED_LIFE_IO_PORT, LED_LIFE_IO_PIN);
 8001038:	2180      	movs	r1, #128	; 0x80
 800103a:	4801      	ldr	r0, [pc, #4]	; (8001040 <led_life_on+0x8>)
 800103c:	f7ff b986 	b.w	800034c <GPIO_SetBits>
 8001040:	40011800 	.word	0x40011800

08001044 <led_life_off>:
}

void led_life_off() {
	GPIO_ResetBits(LED_LIFE_IO_PORT, LED_LIFE_IO_PIN);
 8001044:	2180      	movs	r1, #128	; 0x80
 8001046:	4801      	ldr	r0, [pc, #4]	; (800104c <led_life_off+0x8>)
 8001048:	f7ff b982 	b.w	8000350 <GPIO_ResetBits>
 800104c:	40011800 	.word	0x40011800

08001050 <Reset_Handler>:
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:	

/* Copy the data segment initializers from flash to SRAM */  
  movs	r1, #0
 8001050:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8001052:	e003      	b.n	800105c <LoopCopyDataInit>

08001054 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8001054:	4b0a      	ldr	r3, [pc, #40]	; (8001080 <LoopFillZerobss+0x10>)
	ldr	r3, [r3, r1]
 8001056:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8001058:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 800105a:	3104      	adds	r1, #4

0800105c <LoopCopyDataInit>:
    
LoopCopyDataInit:
	ldr	r0, =_sdata
 800105c:	4809      	ldr	r0, [pc, #36]	; (8001084 <LoopFillZerobss+0x14>)
	ldr	r3, =_edata
 800105e:	4b0a      	ldr	r3, [pc, #40]	; (8001088 <LoopFillZerobss+0x18>)
	adds	r2, r0, r1
 8001060:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8001062:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8001064:	d3f6      	bcc.n	8001054 <CopyDataInit>
	ldr	r2, =_sbss
 8001066:	4a09      	ldr	r2, [pc, #36]	; (800108c <LoopFillZerobss+0x1c>)
	b	LoopFillZerobss
 8001068:	e002      	b.n	8001070 <LoopFillZerobss>

0800106a <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
	movs	r3, #0
 800106a:	2300      	movs	r3, #0
	str	r3, [r2], #4
 800106c:	f842 3b04 	str.w	r3, [r2], #4

08001070 <LoopFillZerobss>:
    
LoopFillZerobss:
	ldr	r3, = _ebss
 8001070:	4b07      	ldr	r3, [pc, #28]	; (8001090 <LoopFillZerobss+0x20>)
	cmp	r2, r3
 8001072:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8001074:	d3f9      	bcc.n	800106a <FillZerobss>
/* Call the clock system intitialization function.*/
  bl  SystemInit 	
 8001076:	f7ff ff4d 	bl	8000f14 <SystemInit>
/* Call the application's entry point.*/
	bl	main
 800107a:	f7ff ff2f 	bl	8000edc <main>
	bx	lr    
 800107e:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */  
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 8001080:	08002580 	.word	0x08002580
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4
    
LoopCopyDataInit:
	ldr	r0, =_sdata
 8001084:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8001088:	20000670 	.word	0x20000670
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 800108c:	20000670 	.word	0x20000670
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4
    
LoopFillZerobss:
	ldr	r3, = _ebss
 8001090:	20001054 	.word	0x20001054

08001094 <ADC1_2_IRQHandler>:
 * @retval None       
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8001094:	e7fe      	b.n	8001094 <ADC1_2_IRQHandler>

08001096 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001096:	f100 0308 	add.w	r3, r0, #8
 800109a:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800109c:	f04f 32ff 	mov.w	r2, #4294967295

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80010a0:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80010a2:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80010a4:	2300      	movs	r3, #0
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80010a6:	6082      	str	r2, [r0, #8]
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80010a8:	6003      	str	r3, [r0, #0]
 80010aa:	4770      	bx	lr

080010ac <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 80010ac:	2300      	movs	r3, #0
 80010ae:	6103      	str	r3, [r0, #16]
 80010b0:	4770      	bx	lr

080010b2 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 80010b2:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80010b4:	689a      	ldr	r2, [r3, #8]
ListItem_t * const pxIndex = pxList->pxIndex;

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 80010b6:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80010b8:	608a      	str	r2, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 80010ba:	689a      	ldr	r2, [r3, #8]
 80010bc:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 80010be:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 80010c0:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
	pxIndex->pxPrevious->pxNext = pxNewListItem;
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 80010c2:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 80010c4:	3301      	adds	r3, #1
 80010c6:	6003      	str	r3, [r0, #0]
 80010c8:	4770      	bx	lr

080010ca <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 80010ca:	680a      	ldr	r2, [r1, #0]
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 80010cc:	b530      	push	{r4, r5, lr}
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 80010ce:	1c53      	adds	r3, r2, #1
 80010d0:	d101      	bne.n	80010d6 <vListInsert+0xc>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 80010d2:	6903      	ldr	r3, [r0, #16]
 80010d4:	e007      	b.n	80010e6 <vListInsert+0x1c>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80010d6:	f100 0308 	add.w	r3, r0, #8
 80010da:	685c      	ldr	r4, [r3, #4]
 80010dc:	6825      	ldr	r5, [r4, #0]
 80010de:	42aa      	cmp	r2, r5
 80010e0:	d301      	bcc.n	80010e6 <vListInsert+0x1c>
 80010e2:	4623      	mov	r3, r4
 80010e4:	e7f9      	b.n	80010da <vListInsert+0x10>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 80010e6:	685a      	ldr	r2, [r3, #4]
 80010e8:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80010ea:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 80010ec:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 80010ee:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 80010f0:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = pxNewListItem;

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 80010f2:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 80010f4:	3301      	adds	r3, #1
 80010f6:	6003      	str	r3, [r0, #0]
 80010f8:	bd30      	pop	{r4, r5, pc}

080010fa <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80010fa:	6841      	ldr	r1, [r0, #4]
 80010fc:	6882      	ldr	r2, [r0, #8]

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 80010fe:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8001100:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8001102:	6882      	ldr	r2, [r0, #8]
 8001104:	6051      	str	r1, [r2, #4]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8001106:	6859      	ldr	r1, [r3, #4]
 8001108:	4288      	cmp	r0, r1
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800110a:	bf08      	it	eq
 800110c:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 800110e:	2200      	movs	r2, #0
 8001110:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8001112:	6818      	ldr	r0, [r3, #0]
 8001114:	3801      	subs	r0, #1
 8001116:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8001118:	4770      	bx	lr
	...

0800111c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 800111c:	b508      	push	{r3, lr}

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800111e:	4c03      	ldr	r4, [pc, #12]	; (800112c <prvIdleTask+0x10>)
 8001120:	6823      	ldr	r3, [r4, #0]
 8001122:	2b01      	cmp	r3, #1
 8001124:	d9fd      	bls.n	8001122 <prvIdleTask+0x6>
			{
				taskYIELD();
 8001126:	f000 fab9 	bl	800169c <vPortYield>
 800112a:	e7f9      	b.n	8001120 <prvIdleTask+0x4>
 800112c:	200006c8 	.word	0x200006c8

08001130 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001130:	4a06      	ldr	r2, [pc, #24]	; (800114c <prvResetNextTaskUnblockTime+0x1c>)
 8001132:	6813      	ldr	r3, [r2, #0]
 8001134:	6819      	ldr	r1, [r3, #0]
 8001136:	4b06      	ldr	r3, [pc, #24]	; (8001150 <prvResetNextTaskUnblockTime+0x20>)
 8001138:	b911      	cbnz	r1, 8001140 <prvResetNextTaskUnblockTime+0x10>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800113a:	f04f 32ff 	mov.w	r2, #4294967295
 800113e:	e003      	b.n	8001148 <prvResetNextTaskUnblockTime+0x18>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001140:	6812      	ldr	r2, [r2, #0]
 8001142:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 8001144:	68d2      	ldr	r2, [r2, #12]
 8001146:	6852      	ldr	r2, [r2, #4]
 8001148:	601a      	str	r2, [r3, #0]
 800114a:	4770      	bx	lr
 800114c:	20000694 	.word	0x20000694
 8001150:	20000018 	.word	0x20000018

08001154 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8001154:	4b0e      	ldr	r3, [pc, #56]	; (8001190 <prvAddCurrentTaskToDelayedList+0x3c>)
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 8001156:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8001158:	681a      	ldr	r2, [r3, #0]
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 800115a:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 800115c:	6050      	str	r0, [r2, #4]

	if( xTimeToWake < xTickCount )
 800115e:	4a0d      	ldr	r2, [pc, #52]	; (8001194 <prvAddCurrentTaskToDelayedList+0x40>)
 8001160:	6812      	ldr	r2, [r2, #0]
 8001162:	4290      	cmp	r0, r2
 8001164:	d207      	bcs.n	8001176 <prvAddCurrentTaskToDelayedList+0x22>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 8001166:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800116a:	4a0b      	ldr	r2, [pc, #44]	; (8001198 <prvAddCurrentTaskToDelayedList+0x44>)
 800116c:	6810      	ldr	r0, [r2, #0]
 800116e:	6819      	ldr	r1, [r3, #0]
 8001170:	3104      	adds	r1, #4
 8001172:	f7ff bfaa 	b.w	80010ca <vListInsert>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8001176:	4a09      	ldr	r2, [pc, #36]	; (800119c <prvAddCurrentTaskToDelayedList+0x48>)
 8001178:	6810      	ldr	r0, [r2, #0]
 800117a:	6819      	ldr	r1, [r3, #0]
 800117c:	3104      	adds	r1, #4
 800117e:	f7ff ffa4 	bl	80010ca <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 8001182:	4b07      	ldr	r3, [pc, #28]	; (80011a0 <prvAddCurrentTaskToDelayedList+0x4c>)
 8001184:	681a      	ldr	r2, [r3, #0]
 8001186:	4294      	cmp	r4, r2
		{
			xNextTaskUnblockTime = xTimeToWake;
 8001188:	bf38      	it	cc
 800118a:	601c      	strcc	r4, [r3, #0]
 800118c:	bd10      	pop	{r4, pc}
 800118e:	bf00      	nop
 8001190:	20000730 	.word	0x20000730
 8001194:	20000748 	.word	0x20000748
 8001198:	2000074c 	.word	0x2000074c
 800119c:	20000694 	.word	0x20000694
 80011a0:	20000018 	.word	0x20000018

080011a4 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 80011a4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80011a8:	ae0a      	add	r6, sp, #40	; 0x28
 80011aa:	460f      	mov	r7, r1
 80011ac:	e896 0a40 	ldmia.w	r6, {r6, r9, fp}
 80011b0:	4615      	mov	r5, r2
 80011b2:	469a      	mov	sl, r3
BaseType_t xReturn;
TCB_t * pxNewTCB;

	configASSERT( pxTaskCode );
 80011b4:	4680      	mov	r8, r0
 80011b6:	b910      	cbnz	r0, 80011be <xTaskGenericCreate+0x1a>
 80011b8:	f000 fa7c 	bl	80016b4 <ulPortSetInterruptMask>
 80011bc:	e7fe      	b.n	80011bc <xTaskGenericCreate+0x18>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 80011be:	2e04      	cmp	r6, #4
 80011c0:	d902      	bls.n	80011c8 <xTaskGenericCreate+0x24>
 80011c2:	f000 fa77 	bl	80016b4 <ulPortSetInterruptMask>
 80011c6:	e7fe      	b.n	80011c6 <xTaskGenericCreate+0x22>
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 80011c8:	2048      	movs	r0, #72	; 0x48
 80011ca:	f000 fb3d 	bl	8001848 <pvPortMalloc>

	if( pxNewTCB != NULL )
 80011ce:	4604      	mov	r4, r0
 80011d0:	2800      	cmp	r0, #0
 80011d2:	f000 8094 	beq.w	80012fe <xTaskGenericCreate+0x15a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80011d6:	f1bb 0f00 	cmp.w	fp, #0
 80011da:	d103      	bne.n	80011e4 <xTaskGenericCreate+0x40>
 80011dc:	00a8      	lsls	r0, r5, #2
 80011de:	f000 fb33 	bl	8001848 <pvPortMalloc>
 80011e2:	e000      	b.n	80011e6 <xTaskGenericCreate+0x42>
 80011e4:	4658      	mov	r0, fp
 80011e6:	6320      	str	r0, [r4, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 80011e8:	b918      	cbnz	r0, 80011f2 <xTaskGenericCreate+0x4e>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 80011ea:	4620      	mov	r0, r4
 80011ec:	f000 fb54 	bl	8001898 <vPortFree>
 80011f0:	e085      	b.n	80012fe <xTaskGenericCreate+0x15a>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 80011f2:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 80011f6:	3d01      	subs	r5, #1
 80011f8:	eb00 0085 	add.w	r0, r0, r5, lsl #2
 80011fc:	1e7b      	subs	r3, r7, #1
 80011fe:	f020 0507 	bic.w	r5, r0, #7
 8001202:	f104 0233 	add.w	r2, r4, #51	; 0x33
 8001206:	370f      	adds	r7, #15
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 8001208:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 800120c:	f802 1f01 	strb.w	r1, [r2, #1]!

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 8001210:	7819      	ldrb	r1, [r3, #0]
 8001212:	b109      	cbz	r1, 8001218 <xTaskGenericCreate+0x74>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8001214:	429f      	cmp	r7, r3
 8001216:	d1f7      	bne.n	8001208 <xTaskGenericCreate+0x64>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8001218:	2300      	movs	r3, #0
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 800121a:	1d27      	adds	r7, r4, #4
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800121c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8001220:	4638      	mov	r0, r7
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 8001222:	62e6      	str	r6, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8001224:	6466      	str	r6, [r4, #68]	; 0x44
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8001226:	f7ff ff41 	bl	80010ac <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 800122a:	f104 0018 	add.w	r0, r4, #24
 800122e:	f7ff ff3d 	bl	80010ac <vListInitialiseItem>
	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001232:	f1c6 0305 	rsb	r3, r6, #5
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8001236:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001238:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 800123a:	6264      	str	r4, [r4, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800123c:	4652      	mov	r2, sl
 800123e:	4641      	mov	r1, r8
 8001240:	4628      	mov	r0, r5
 8001242:	f000 fa0b 	bl	800165c <pxPortInitialiseStack>
 8001246:	6020      	str	r0, [r4, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 8001248:	f1b9 0f00 	cmp.w	r9, #0
 800124c:	d001      	beq.n	8001252 <xTaskGenericCreate+0xae>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 800124e:	f8c9 4000 	str.w	r4, [r9]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 8001252:	f000 fa45 	bl	80016e0 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 8001256:	4a2c      	ldr	r2, [pc, #176]	; (8001308 <xTaskGenericCreate+0x164>)
			if( pxCurrentTCB == NULL )
 8001258:	4d2c      	ldr	r5, [pc, #176]	; (800130c <xTaskGenericCreate+0x168>)

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
		{
			uxCurrentNumberOfTasks++;
 800125a:	6813      	ldr	r3, [r2, #0]
 800125c:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 800132c <xTaskGenericCreate+0x188>
 8001260:	3301      	adds	r3, #1
 8001262:	6013      	str	r3, [r2, #0]
			if( pxCurrentTCB == NULL )
 8001264:	682b      	ldr	r3, [r5, #0]
 8001266:	bb23      	cbnz	r3, 80012b2 <xTaskGenericCreate+0x10e>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 8001268:	602c      	str	r4, [r5, #0]

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800126a:	6812      	ldr	r2, [r2, #0]
 800126c:	2a01      	cmp	r2, #1
 800126e:	d128      	bne.n	80012c2 <xTaskGenericCreate+0x11e>
 8001270:	4698      	mov	r8, r3
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8001272:	eb09 0008 	add.w	r0, r9, r8
 8001276:	f108 0814 	add.w	r8, r8, #20
 800127a:	f7ff ff0c 	bl	8001096 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800127e:	f1b8 0f64 	cmp.w	r8, #100	; 0x64
 8001282:	d1f6      	bne.n	8001272 <xTaskGenericCreate+0xce>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 8001284:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 8001330 <xTaskGenericCreate+0x18c>
	vListInitialise( &xDelayedTaskList2 );
 8001288:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8001334 <xTaskGenericCreate+0x190>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 800128c:	4650      	mov	r0, sl
 800128e:	f7ff ff02 	bl	8001096 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8001292:	4640      	mov	r0, r8
 8001294:	f7ff feff 	bl	8001096 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8001298:	481d      	ldr	r0, [pc, #116]	; (8001310 <xTaskGenericCreate+0x16c>)
 800129a:	f7ff fefc 	bl	8001096 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 800129e:	481d      	ldr	r0, [pc, #116]	; (8001314 <xTaskGenericCreate+0x170>)
 80012a0:	f7ff fef9 	bl	8001096 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 80012a4:	4b1c      	ldr	r3, [pc, #112]	; (8001318 <xTaskGenericCreate+0x174>)
 80012a6:	f8c3 a000 	str.w	sl, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80012aa:	4b1c      	ldr	r3, [pc, #112]	; (800131c <xTaskGenericCreate+0x178>)
 80012ac:	f8c3 8000 	str.w	r8, [r3]
 80012b0:	e007      	b.n	80012c2 <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 80012b2:	4b1b      	ldr	r3, [pc, #108]	; (8001320 <xTaskGenericCreate+0x17c>)
 80012b4:	681b      	ldr	r3, [r3, #0]
 80012b6:	b923      	cbnz	r3, 80012c2 <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 80012b8:	682b      	ldr	r3, [r5, #0]
 80012ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80012bc:	429e      	cmp	r6, r3
					{
						pxCurrentTCB = pxNewTCB;
 80012be:	bf28      	it	cs
 80012c0:	602c      	strcs	r4, [r5, #0]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 80012c2:	4a18      	ldr	r2, [pc, #96]	; (8001324 <xTaskGenericCreate+0x180>)
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 80012c4:	2014      	movs	r0, #20
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 80012c6:	6813      	ldr	r3, [r2, #0]
 80012c8:	3301      	adds	r3, #1
 80012ca:	6013      	str	r3, [r2, #0]
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 80012cc:	4a16      	ldr	r2, [pc, #88]	; (8001328 <xTaskGenericCreate+0x184>)
 80012ce:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80012d0:	6811      	ldr	r1, [r2, #0]
 80012d2:	fb00 9003 	mla	r0, r0, r3, r9
 80012d6:	428b      	cmp	r3, r1
 80012d8:	4639      	mov	r1, r7
 80012da:	bf88      	it	hi
 80012dc:	6013      	strhi	r3, [r2, #0]
 80012de:	f7ff fee8 	bl	80010b2 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 80012e2:	f000 fa0f 	bl	8001704 <vPortExitCritical>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 80012e6:	4b0e      	ldr	r3, [pc, #56]	; (8001320 <xTaskGenericCreate+0x17c>)
 80012e8:	681b      	ldr	r3, [r3, #0]
 80012ea:	b12b      	cbz	r3, 80012f8 <xTaskGenericCreate+0x154>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 80012ec:	682b      	ldr	r3, [r5, #0]
 80012ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80012f0:	429e      	cmp	r6, r3
 80012f2:	d901      	bls.n	80012f8 <xTaskGenericCreate+0x154>
			{
				taskYIELD_IF_USING_PREEMPTION();
 80012f4:	f000 f9d2 	bl	800169c <vPortYield>
 80012f8:	2001      	movs	r0, #1
 80012fa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80012fe:	f04f 30ff 	mov.w	r0, #4294967295
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
 8001302:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001306:	bf00      	nop
 8001308:	20000754 	.word	0x20000754
 800130c:	20000730 	.word	0x20000730
 8001310:	20000734 	.word	0x20000734
 8001314:	20000758 	.word	0x20000758
 8001318:	20000694 	.word	0x20000694
 800131c:	2000074c 	.word	0x2000074c
 8001320:	20000698 	.word	0x20000698
 8001324:	20000750 	.word	0x20000750
 8001328:	2000076c 	.word	0x2000076c
 800132c:	200006c8 	.word	0x200006c8
 8001330:	2000069c 	.word	0x2000069c
 8001334:	200006b0 	.word	0x200006b0

08001338 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 8001338:	b530      	push	{r4, r5, lr}
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 800133a:	2400      	movs	r4, #0

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 800133c:	b085      	sub	sp, #20
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 800133e:	9403      	str	r4, [sp, #12]
 8001340:	9402      	str	r4, [sp, #8]
 8001342:	9401      	str	r4, [sp, #4]
 8001344:	9400      	str	r4, [sp, #0]
 8001346:	4623      	mov	r3, r4
 8001348:	2280      	movs	r2, #128	; 0x80
 800134a:	490c      	ldr	r1, [pc, #48]	; (800137c <vTaskStartScheduler+0x44>)
 800134c:	480c      	ldr	r0, [pc, #48]	; (8001380 <vTaskStartScheduler+0x48>)
 800134e:	f7ff ff29 	bl	80011a4 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8001352:	2801      	cmp	r0, #1
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 8001354:	4605      	mov	r5, r0
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8001356:	d10a      	bne.n	800136e <vTaskStartScheduler+0x36>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 8001358:	f000 f9ac 	bl	80016b4 <ulPortSetInterruptMask>
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
 800135c:	4b09      	ldr	r3, [pc, #36]	; (8001384 <vTaskStartScheduler+0x4c>)
 800135e:	601d      	str	r5, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8001360:	4b09      	ldr	r3, [pc, #36]	; (8001388 <vTaskStartScheduler+0x50>)
 8001362:	601c      	str	r4, [r3, #0]
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 8001364:	b005      	add	sp, #20
 8001366:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 800136a:	f000 ba25 	b.w	80017b8 <xPortStartScheduler>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
 800136e:	b910      	cbnz	r0, 8001376 <vTaskStartScheduler+0x3e>
 8001370:	f000 f9a0 	bl	80016b4 <ulPortSetInterruptMask>
 8001374:	e7fe      	b.n	8001374 <vTaskStartScheduler+0x3c>
	}
}
 8001376:	b005      	add	sp, #20
 8001378:	bd30      	pop	{r4, r5, pc}
 800137a:	bf00      	nop
 800137c:	080021a4 	.word	0x080021a4
 8001380:	0800111d 	.word	0x0800111d
 8001384:	20000698 	.word	0x20000698
 8001388:	20000748 	.word	0x20000748

0800138c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 800138c:	4a02      	ldr	r2, [pc, #8]	; (8001398 <vTaskSuspendAll+0xc>)
 800138e:	6813      	ldr	r3, [r2, #0]
 8001390:	3301      	adds	r3, #1
 8001392:	6013      	str	r3, [r2, #0]
 8001394:	4770      	bx	lr
 8001396:	bf00      	nop
 8001398:	2000072c 	.word	0x2000072c

0800139c <xTaskIncrementTick>:

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800139c:	4b3b      	ldr	r3, [pc, #236]	; (800148c <xTaskIncrementTick+0xf0>)

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 800139e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80013a2:	681b      	ldr	r3, [r3, #0]
 80013a4:	2b00      	cmp	r3, #0
 80013a6:	d136      	bne.n	8001416 <xTaskIncrementTick+0x7a>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 80013a8:	4b39      	ldr	r3, [pc, #228]	; (8001490 <xTaskIncrementTick+0xf4>)
 80013aa:	681a      	ldr	r2, [r3, #0]
 80013ac:	3201      	adds	r2, #1
 80013ae:	601a      	str	r2, [r3, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 80013b0:	681d      	ldr	r5, [r3, #0]

			if( xConstTickCount == ( TickType_t ) 0U )
 80013b2:	b98d      	cbnz	r5, 80013d8 <xTaskIncrementTick+0x3c>
			{
				taskSWITCH_DELAYED_LISTS();
 80013b4:	4b37      	ldr	r3, [pc, #220]	; (8001494 <xTaskIncrementTick+0xf8>)
 80013b6:	681a      	ldr	r2, [r3, #0]
 80013b8:	6812      	ldr	r2, [r2, #0]
 80013ba:	b112      	cbz	r2, 80013c2 <xTaskIncrementTick+0x26>
 80013bc:	f000 f97a 	bl	80016b4 <ulPortSetInterruptMask>
 80013c0:	e7fe      	b.n	80013c0 <xTaskIncrementTick+0x24>
 80013c2:	4a35      	ldr	r2, [pc, #212]	; (8001498 <xTaskIncrementTick+0xfc>)
 80013c4:	6819      	ldr	r1, [r3, #0]
 80013c6:	6810      	ldr	r0, [r2, #0]
 80013c8:	6018      	str	r0, [r3, #0]
 80013ca:	6011      	str	r1, [r2, #0]
 80013cc:	4a33      	ldr	r2, [pc, #204]	; (800149c <xTaskIncrementTick+0x100>)
 80013ce:	6813      	ldr	r3, [r2, #0]
 80013d0:	3301      	adds	r3, #1
 80013d2:	6013      	str	r3, [r2, #0]
 80013d4:	f7ff feac 	bl	8001130 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 80013d8:	4c31      	ldr	r4, [pc, #196]	; (80014a0 <xTaskIncrementTick+0x104>)
 80013da:	f04f 0b00 	mov.w	fp, #0
 80013de:	6823      	ldr	r3, [r4, #0]
 80013e0:	9401      	str	r4, [sp, #4]
 80013e2:	429d      	cmp	r5, r3
 80013e4:	4e2f      	ldr	r6, [pc, #188]	; (80014a4 <xTaskIncrementTick+0x108>)
 80013e6:	4f30      	ldr	r7, [pc, #192]	; (80014a8 <xTaskIncrementTick+0x10c>)
 80013e8:	d30b      	bcc.n	8001402 <xTaskIncrementTick+0x66>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80013ea:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8001494 <xTaskIncrementTick+0xf8>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 80013ee:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 80014b4 <xTaskIncrementTick+0x118>
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80013f2:	f8d8 2000 	ldr.w	r2, [r8]
 80013f6:	6812      	ldr	r2, [r2, #0]
 80013f8:	b9a2      	cbnz	r2, 8001424 <xTaskIncrementTick+0x88>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 80013fa:	9b01      	ldr	r3, [sp, #4]
 80013fc:	f04f 32ff 	mov.w	r2, #4294967295
 8001400:	601a      	str	r2, [r3, #0]
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8001402:	683a      	ldr	r2, [r7, #0]
 8001404:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8001406:	2214      	movs	r2, #20
 8001408:	434a      	muls	r2, r1
 800140a:	58b2      	ldr	r2, [r6, r2]
			{
				xSwitchRequired = pdTRUE;
 800140c:	2a02      	cmp	r2, #2
 800140e:	bf28      	it	cs
 8001410:	f04f 0b01 	movcs.w	fp, #1
 8001414:	e030      	b.n	8001478 <xTaskIncrementTick+0xdc>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 8001416:	4a25      	ldr	r2, [pc, #148]	; (80014ac <xTaskIncrementTick+0x110>)

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 8001418:	f04f 0b00 	mov.w	fp, #0
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 800141c:	6813      	ldr	r3, [r2, #0]
 800141e:	3301      	adds	r3, #1
 8001420:	6013      	str	r3, [r2, #0]
 8001422:	e029      	b.n	8001478 <xTaskIncrementTick+0xdc>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001424:	f8d8 2000 	ldr.w	r2, [r8]
 8001428:	68d2      	ldr	r2, [r2, #12]
 800142a:	68d4      	ldr	r4, [r2, #12]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 800142c:	6861      	ldr	r1, [r4, #4]

						if( xConstTickCount < xItemValue )
 800142e:	428d      	cmp	r5, r1
 8001430:	d202      	bcs.n	8001438 <xTaskIncrementTick+0x9c>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
 8001432:	9b01      	ldr	r3, [sp, #4]
 8001434:	6019      	str	r1, [r3, #0]
							break;
 8001436:	e7e4      	b.n	8001402 <xTaskIncrementTick+0x66>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8001438:	f104 0a04 	add.w	sl, r4, #4
 800143c:	4650      	mov	r0, sl
 800143e:	f7ff fe5c 	bl	80010fa <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8001442:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8001444:	b119      	cbz	r1, 800144e <xTaskIncrementTick+0xb2>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001446:	f104 0018 	add.w	r0, r4, #24
 800144a:	f7ff fe56 	bl	80010fa <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 800144e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8001450:	f8d9 1000 	ldr.w	r1, [r9]
 8001454:	2314      	movs	r3, #20
 8001456:	4288      	cmp	r0, r1
 8001458:	bf88      	it	hi
 800145a:	f8c9 0000 	strhi.w	r0, [r9]
 800145e:	4651      	mov	r1, sl
 8001460:	fb03 6000 	mla	r0, r3, r0, r6
 8001464:	f7ff fe25 	bl	80010b2 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001468:	6838      	ldr	r0, [r7, #0]
 800146a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800146c:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
							{
								xSwitchRequired = pdTRUE;
 800146e:	4291      	cmp	r1, r2
 8001470:	bf28      	it	cs
 8001472:	f04f 0b01 	movcs.w	fp, #1
 8001476:	e7bc      	b.n	80013f2 <xTaskIncrementTick+0x56>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8001478:	4a0d      	ldr	r2, [pc, #52]	; (80014b0 <xTaskIncrementTick+0x114>)
 800147a:	6812      	ldr	r2, [r2, #0]
		{
			xSwitchRequired = pdTRUE;
 800147c:	2a00      	cmp	r2, #0
 800147e:	bf18      	it	ne
 8001480:	f04f 0b01 	movne.w	fp, #1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 8001484:	4658      	mov	r0, fp
 8001486:	b003      	add	sp, #12
 8001488:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800148c:	2000072c 	.word	0x2000072c
 8001490:	20000748 	.word	0x20000748
 8001494:	20000694 	.word	0x20000694
 8001498:	2000074c 	.word	0x2000074c
 800149c:	20000690 	.word	0x20000690
 80014a0:	20000018 	.word	0x20000018
 80014a4:	200006c8 	.word	0x200006c8
 80014a8:	20000730 	.word	0x20000730
 80014ac:	200006c4 	.word	0x200006c4
 80014b0:	20000770 	.word	0x20000770
 80014b4:	2000076c 	.word	0x2000076c

080014b8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 80014b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 80014bc:	4c29      	ldr	r4, [pc, #164]	; (8001564 <xTaskResumeAll+0xac>)
 80014be:	6823      	ldr	r3, [r4, #0]
 80014c0:	b913      	cbnz	r3, 80014c8 <xTaskResumeAll+0x10>
 80014c2:	f000 f8f7 	bl	80016b4 <ulPortSetInterruptMask>
 80014c6:	e7fe      	b.n	80014c6 <xTaskResumeAll+0xe>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 80014c8:	f000 f90a 	bl	80016e0 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 80014cc:	6823      	ldr	r3, [r4, #0]
 80014ce:	3b01      	subs	r3, #1
 80014d0:	6023      	str	r3, [r4, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80014d2:	6823      	ldr	r3, [r4, #0]
 80014d4:	b10b      	cbz	r3, 80014da <xTaskResumeAll+0x22>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 80014d6:	2400      	movs	r4, #0
 80014d8:	e03f      	b.n	800155a <xTaskResumeAll+0xa2>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 80014da:	4b23      	ldr	r3, [pc, #140]	; (8001568 <xTaskResumeAll+0xb0>)
 80014dc:	681b      	ldr	r3, [r3, #0]
 80014de:	2b00      	cmp	r3, #0
 80014e0:	d0f9      	beq.n	80014d6 <xTaskResumeAll+0x1e>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80014e2:	4d22      	ldr	r5, [pc, #136]	; (800156c <xTaskResumeAll+0xb4>)
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
 80014e4:	4e22      	ldr	r6, [pc, #136]	; (8001570 <xTaskResumeAll+0xb8>)
 80014e6:	f8df 8098 	ldr.w	r8, [pc, #152]	; 8001580 <xTaskResumeAll+0xc8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80014ea:	682b      	ldr	r3, [r5, #0]
 80014ec:	b1f3      	cbz	r3, 800152c <xTaskResumeAll+0x74>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 80014ee:	68eb      	ldr	r3, [r5, #12]
 80014f0:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 80014f2:	1d27      	adds	r7, r4, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80014f4:	f104 0018 	add.w	r0, r4, #24
 80014f8:	f7ff fdff 	bl	80010fa <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 80014fc:	4638      	mov	r0, r7
 80014fe:	f7ff fdfc 	bl	80010fa <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8001502:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001504:	6832      	ldr	r2, [r6, #0]
 8001506:	2014      	movs	r0, #20
 8001508:	4293      	cmp	r3, r2
 800150a:	fb00 8003 	mla	r0, r0, r3, r8
 800150e:	4639      	mov	r1, r7
 8001510:	bf88      	it	hi
 8001512:	6033      	strhi	r3, [r6, #0]
 8001514:	f7ff fdcd 	bl	80010b2 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001518:	4b16      	ldr	r3, [pc, #88]	; (8001574 <xTaskResumeAll+0xbc>)
 800151a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800151c:	681b      	ldr	r3, [r3, #0]
 800151e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001520:	429a      	cmp	r2, r3
 8001522:	d3e2      	bcc.n	80014ea <xTaskResumeAll+0x32>
					{
						xYieldPending = pdTRUE;
 8001524:	4b14      	ldr	r3, [pc, #80]	; (8001578 <xTaskResumeAll+0xc0>)
 8001526:	2201      	movs	r2, #1
 8001528:	601a      	str	r2, [r3, #0]
 800152a:	e7dc      	b.n	80014e6 <xTaskResumeAll+0x2e>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 800152c:	4c13      	ldr	r4, [pc, #76]	; (800157c <xTaskResumeAll+0xc4>)
 800152e:	6823      	ldr	r3, [r4, #0]
 8001530:	b933      	cbnz	r3, 8001540 <xTaskResumeAll+0x88>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 8001532:	4b11      	ldr	r3, [pc, #68]	; (8001578 <xTaskResumeAll+0xc0>)
 8001534:	681c      	ldr	r4, [r3, #0]
 8001536:	2c01      	cmp	r4, #1
 8001538:	d1cd      	bne.n	80014d6 <xTaskResumeAll+0x1e>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 800153a:	f000 f8af 	bl	800169c <vPortYield>
 800153e:	e00c      	b.n	800155a <xTaskResumeAll+0xa2>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 8001540:	4d0d      	ldr	r5, [pc, #52]	; (8001578 <xTaskResumeAll+0xc0>)
 8001542:	2601      	movs	r6, #1
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 8001544:	6823      	ldr	r3, [r4, #0]
 8001546:	2b00      	cmp	r3, #0
 8001548:	d0f3      	beq.n	8001532 <xTaskResumeAll+0x7a>
					{
						if( xTaskIncrementTick() != pdFALSE )
 800154a:	f7ff ff27 	bl	800139c <xTaskIncrementTick>
 800154e:	b100      	cbz	r0, 8001552 <xTaskResumeAll+0x9a>
						{
							xYieldPending = pdTRUE;
 8001550:	602e      	str	r6, [r5, #0]
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 8001552:	6823      	ldr	r3, [r4, #0]
 8001554:	3b01      	subs	r3, #1
 8001556:	6023      	str	r3, [r4, #0]
 8001558:	e7f4      	b.n	8001544 <xTaskResumeAll+0x8c>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 800155a:	f000 f8d3 	bl	8001704 <vPortExitCritical>

	return xAlreadyYielded;
}
 800155e:	4620      	mov	r0, r4
 8001560:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001564:	2000072c 	.word	0x2000072c
 8001568:	20000754 	.word	0x20000754
 800156c:	20000734 	.word	0x20000734
 8001570:	2000076c 	.word	0x2000076c
 8001574:	20000730 	.word	0x20000730
 8001578:	20000770 	.word	0x20000770
 800157c:	200006c4 	.word	0x200006c4
 8001580:	200006c8 	.word	0x200006c8

08001584 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 8001584:	b510      	push	{r4, lr}
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 8001586:	b918      	cbnz	r0, 8001590 <vTaskDelay+0xc>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8001588:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 800158c:	f000 b886 	b.w	800169c <vPortYield>


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
 8001590:	4b0b      	ldr	r3, [pc, #44]	; (80015c0 <vTaskDelay+0x3c>)
 8001592:	681b      	ldr	r3, [r3, #0]
 8001594:	b113      	cbz	r3, 800159c <vTaskDelay+0x18>
 8001596:	f000 f88d 	bl	80016b4 <ulPortSetInterruptMask>
 800159a:	e7fe      	b.n	800159a <vTaskDelay+0x16>
			vTaskSuspendAll();
 800159c:	f7ff fef6 	bl	800138c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 80015a0:	4b08      	ldr	r3, [pc, #32]	; (80015c4 <vTaskDelay+0x40>)
 80015a2:	681b      	ldr	r3, [r3, #0]
 80015a4:	18c4      	adds	r4, r0, r3

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80015a6:	4b08      	ldr	r3, [pc, #32]	; (80015c8 <vTaskDelay+0x44>)
 80015a8:	6818      	ldr	r0, [r3, #0]
 80015aa:	3004      	adds	r0, #4
 80015ac:	f7ff fda5 	bl	80010fa <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 80015b0:	4620      	mov	r0, r4
 80015b2:	f7ff fdcf 	bl	8001154 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 80015b6:	f7ff ff7f 	bl	80014b8 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 80015ba:	2800      	cmp	r0, #0
 80015bc:	d0e4      	beq.n	8001588 <vTaskDelay+0x4>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 80015be:	bd10      	pop	{r4, pc}
 80015c0:	2000072c 	.word	0x2000072c
 80015c4:	20000748 	.word	0x20000748
 80015c8:	20000730 	.word	0x20000730

080015cc <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80015cc:	4b17      	ldr	r3, [pc, #92]	; (800162c <vTaskSwitchContext+0x60>)

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 80015ce:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80015d0:	681a      	ldr	r2, [r3, #0]
 80015d2:	4b17      	ldr	r3, [pc, #92]	; (8001630 <vTaskSwitchContext+0x64>)
 80015d4:	b10a      	cbz	r2, 80015da <vTaskSwitchContext+0xe>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 80015d6:	2201      	movs	r2, #1
 80015d8:	e026      	b.n	8001628 <vTaskSwitchContext+0x5c>
	}
	else
	{
		xYieldPending = pdFALSE;
 80015da:	601a      	str	r2, [r3, #0]
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
 80015dc:	4815      	ldr	r0, [pc, #84]	; (8001634 <vTaskSwitchContext+0x68>)
 80015de:	4b16      	ldr	r3, [pc, #88]	; (8001638 <vTaskSwitchContext+0x6c>)
 80015e0:	2414      	movs	r4, #20
 80015e2:	681a      	ldr	r2, [r3, #0]
 80015e4:	4913      	ldr	r1, [pc, #76]	; (8001634 <vTaskSwitchContext+0x68>)
 80015e6:	4362      	muls	r2, r4
 80015e8:	5882      	ldr	r2, [r0, r2]
 80015ea:	b942      	cbnz	r2, 80015fe <vTaskSwitchContext+0x32>
 80015ec:	681a      	ldr	r2, [r3, #0]
 80015ee:	b912      	cbnz	r2, 80015f6 <vTaskSwitchContext+0x2a>
 80015f0:	f000 f860 	bl	80016b4 <ulPortSetInterruptMask>
 80015f4:	e7fe      	b.n	80015f4 <vTaskSwitchContext+0x28>
 80015f6:	681a      	ldr	r2, [r3, #0]
 80015f8:	3a01      	subs	r2, #1
 80015fa:	601a      	str	r2, [r3, #0]
 80015fc:	e7f1      	b.n	80015e2 <vTaskSwitchContext+0x16>
 80015fe:	4b0e      	ldr	r3, [pc, #56]	; (8001638 <vTaskSwitchContext+0x6c>)
 8001600:	681a      	ldr	r2, [r3, #0]
 8001602:	2314      	movs	r3, #20
 8001604:	4353      	muls	r3, r2
 8001606:	18c8      	adds	r0, r1, r3
 8001608:	6844      	ldr	r4, [r0, #4]
 800160a:	3308      	adds	r3, #8
 800160c:	6864      	ldr	r4, [r4, #4]
 800160e:	440b      	add	r3, r1
 8001610:	429c      	cmp	r4, r3
 8001612:	bf08      	it	eq
 8001614:	6863      	ldreq	r3, [r4, #4]
 8001616:	6044      	str	r4, [r0, #4]
 8001618:	bf08      	it	eq
 800161a:	6043      	streq	r3, [r0, #4]
 800161c:	2314      	movs	r3, #20
 800161e:	fb03 1202 	mla	r2, r3, r2, r1
 8001622:	6853      	ldr	r3, [r2, #4]
 8001624:	68da      	ldr	r2, [r3, #12]
 8001626:	4b05      	ldr	r3, [pc, #20]	; (800163c <vTaskSwitchContext+0x70>)
 8001628:	601a      	str	r2, [r3, #0]
 800162a:	bd10      	pop	{r4, pc}
 800162c:	2000072c 	.word	0x2000072c
 8001630:	20000770 	.word	0x20000770
 8001634:	200006c8 	.word	0x200006c8
 8001638:	2000076c 	.word	0x2000076c
 800163c:	20000730 	.word	0x20000730

08001640 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8001640:	4805      	ldr	r0, [pc, #20]	; (8001658 <prvPortStartFirstTask+0x18>)
 8001642:	6800      	ldr	r0, [r0, #0]
 8001644:	6800      	ldr	r0, [r0, #0]
 8001646:	f380 8808 	msr	MSP, r0
 800164a:	b662      	cpsie	i
 800164c:	f3bf 8f4f 	dsb	sy
 8001650:	f3bf 8f6f 	isb	sy
 8001654:	df00      	svc	0
 8001656:	bf00      	nop
 8001658:	e000ed08 	.word	0xe000ed08

0800165c <pxPortInitialiseStack>:
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800165c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 8001660:	e900 000a 	stmdb	r0, {r1, r3}
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8001664:	4b03      	ldr	r3, [pc, #12]	; (8001674 <pxPortInitialiseStack+0x18>)
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8001666:	f840 2c20 	str.w	r2, [r0, #-32]
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 800166a:	f840 3c0c 	str.w	r3, [r0, #-12]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
 800166e:	3840      	subs	r0, #64	; 0x40
 8001670:	4770      	bx	lr
 8001672:	bf00      	nop
 8001674:	080016c5 	.word	0x080016c5

08001678 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8001678:	4b07      	ldr	r3, [pc, #28]	; (8001698 <pxCurrentTCBConst2>)
 800167a:	6819      	ldr	r1, [r3, #0]
 800167c:	6808      	ldr	r0, [r1, #0]
 800167e:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001682:	f380 8809 	msr	PSP, r0
 8001686:	f3bf 8f6f 	isb	sy
 800168a:	f04f 0000 	mov.w	r0, #0
 800168e:	f380 8811 	msr	BASEPRI, r0
 8001692:	f04e 0e0d 	orr.w	lr, lr, #13
 8001696:	4770      	bx	lr

08001698 <pxCurrentTCBConst2>:
 8001698:	20000730 	.word	0x20000730

0800169c <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800169c:	4b04      	ldr	r3, [pc, #16]	; (80016b0 <vPortYield+0x14>)
 800169e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80016a2:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 80016a4:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 80016a8:	f3bf 8f6f 	isb	sy
 80016ac:	4770      	bx	lr
 80016ae:	bf00      	nop
 80016b0:	e000ed04 	.word	0xe000ed04

080016b4 <ulPortSetInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) uint32_t ulPortSetInterruptMask( void )
{
	__asm volatile														\
 80016b4:	f3ef 8011 	mrs	r0, BASEPRI
 80016b8:	f04f 01ff 	mov.w	r1, #255	; 0xff
 80016bc:	f381 8811 	msr	BASEPRI, r1
 80016c0:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
}
 80016c2:	2000      	movs	r0, #0

080016c4 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 80016c4:	b508      	push	{r3, lr}
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 80016c6:	4b05      	ldr	r3, [pc, #20]	; (80016dc <prvTaskExitError+0x18>)
 80016c8:	681b      	ldr	r3, [r3, #0]
 80016ca:	3301      	adds	r3, #1
 80016cc:	d002      	beq.n	80016d4 <prvTaskExitError+0x10>
 80016ce:	f7ff fff1 	bl	80016b4 <ulPortSetInterruptMask>
 80016d2:	e7fe      	b.n	80016d2 <prvTaskExitError+0xe>
	portDISABLE_INTERRUPTS();
 80016d4:	f7ff ffee 	bl	80016b4 <ulPortSetInterruptMask>
 80016d8:	e7fe      	b.n	80016d8 <prvTaskExitError+0x14>
 80016da:	bf00      	nop
 80016dc:	2000001c 	.word	0x2000001c

080016e0 <vPortEnterCritical>:
	__asm volatile( "isb" );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 80016e0:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
 80016e2:	f7ff ffe7 	bl	80016b4 <ulPortSetInterruptMask>
	uxCriticalNesting++;
 80016e6:	4a04      	ldr	r2, [pc, #16]	; (80016f8 <vPortEnterCritical+0x18>)
 80016e8:	6813      	ldr	r3, [r2, #0]
 80016ea:	3301      	adds	r3, #1
 80016ec:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
 80016ee:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 80016f2:	f3bf 8f6f 	isb	sy
 80016f6:	bd08      	pop	{r3, pc}
 80016f8:	2000001c 	.word	0x2000001c

080016fc <vPortClearInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( uint32_t ulNewMaskValue )
{
	__asm volatile													\
 80016fc:	f380 8811 	msr	BASEPRI, r0
 8001700:	4770      	bx	lr
	...

08001704 <vPortExitCritical>:
	__asm volatile( "isb" );
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8001704:	b508      	push	{r3, lr}
	configASSERT( uxCriticalNesting );
 8001706:	4b07      	ldr	r3, [pc, #28]	; (8001724 <vPortExitCritical+0x20>)
 8001708:	6818      	ldr	r0, [r3, #0]
 800170a:	b910      	cbnz	r0, 8001712 <vPortExitCritical+0xe>
 800170c:	f7ff ffd2 	bl	80016b4 <ulPortSetInterruptMask>
 8001710:	e7fe      	b.n	8001710 <vPortExitCritical+0xc>
	uxCriticalNesting--;
 8001712:	3801      	subs	r0, #1
 8001714:	6018      	str	r0, [r3, #0]
	if( uxCriticalNesting == 0 )
 8001716:	b918      	cbnz	r0, 8001720 <vPortExitCritical+0x1c>
	{
		portENABLE_INTERRUPTS();
	}
}
 8001718:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
	if( uxCriticalNesting == 0 )
	{
		portENABLE_INTERRUPTS();
 800171c:	f7ff bfee 	b.w	80016fc <vPortClearInterruptMask>
 8001720:	bd08      	pop	{r3, pc}
 8001722:	bf00      	nop
 8001724:	2000001c 	.word	0x2000001c

08001728 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8001728:	f3ef 8009 	mrs	r0, PSP
 800172c:	f3bf 8f6f 	isb	sy
 8001730:	4b0d      	ldr	r3, [pc, #52]	; (8001768 <pxCurrentTCBConst>)
 8001732:	681a      	ldr	r2, [r3, #0]
 8001734:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001738:	6010      	str	r0, [r2, #0]
 800173a:	e92d 4008 	stmdb	sp!, {r3, lr}
 800173e:	f04f 00ff 	mov.w	r0, #255	; 0xff
 8001742:	f380 8811 	msr	BASEPRI, r0
 8001746:	f7ff ff41 	bl	80015cc <vTaskSwitchContext>
 800174a:	f04f 0000 	mov.w	r0, #0
 800174e:	f380 8811 	msr	BASEPRI, r0
 8001752:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8001756:	6819      	ldr	r1, [r3, #0]
 8001758:	6808      	ldr	r0, [r1, #0]
 800175a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800175e:	f380 8809 	msr	PSP, r0
 8001762:	f3bf 8f6f 	isb	sy
 8001766:	4770      	bx	lr

08001768 <pxCurrentTCBConst>:
 8001768:	20000730 	.word	0x20000730

0800176c <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 800176c:	b508      	push	{r3, lr}
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
 800176e:	f7ff ffa1 	bl	80016b4 <ulPortSetInterruptMask>
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8001772:	f7ff fe13 	bl	800139c <xTaskIncrementTick>
 8001776:	b118      	cbz	r0, 8001780 <SysTick_Handler+0x14>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8001778:	4b04      	ldr	r3, [pc, #16]	; (800178c <SysTick_Handler+0x20>)
 800177a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800177e:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8001780:	2000      	movs	r0, #0
}
 8001782:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8001786:	f7ff bfb9 	b.w	80016fc <vPortClearInterruptMask>
 800178a:	bf00      	nop
 800178c:	e000ed04 	.word	0xe000ed04

08001790 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8001790:	4b06      	ldr	r3, [pc, #24]	; (80017ac <vPortSetupTimerInterrupt+0x1c>)
 8001792:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8001796:	681b      	ldr	r3, [r3, #0]
 8001798:	fbb3 f3f2 	udiv	r3, r3, r2
 800179c:	4a04      	ldr	r2, [pc, #16]	; (80017b0 <vPortSetupTimerInterrupt+0x20>)
 800179e:	3b01      	subs	r3, #1
 80017a0:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 80017a2:	4b04      	ldr	r3, [pc, #16]	; (80017b4 <vPortSetupTimerInterrupt+0x24>)
 80017a4:	2207      	movs	r2, #7
 80017a6:	601a      	str	r2, [r3, #0]
 80017a8:	4770      	bx	lr
 80017aa:	bf00      	nop
 80017ac:	20000014 	.word	0x20000014
 80017b0:	e000e014 	.word	0xe000e014
 80017b4:	e000e010 	.word	0xe000e010

080017b8 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 80017b8:	b513      	push	{r0, r1, r4, lr}
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 80017ba:	4b1e      	ldr	r3, [pc, #120]	; (8001834 <xPortStartScheduler+0x7c>)
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80017bc:	2100      	movs	r1, #0
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 80017be:	781a      	ldrb	r2, [r3, #0]
 80017c0:	b2d2      	uxtb	r2, r2
 80017c2:	9201      	str	r2, [sp, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 80017c4:	22ff      	movs	r2, #255	; 0xff
 80017c6:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 80017c8:	781b      	ldrb	r3, [r3, #0]
 80017ca:	b2db      	uxtb	r3, r3
 80017cc:	f88d 3003 	strb.w	r3, [sp, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80017d0:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80017d4:	4b18      	ldr	r3, [pc, #96]	; (8001838 <xPortStartScheduler+0x80>)
 80017d6:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80017d8:	4b18      	ldr	r3, [pc, #96]	; (800183c <xPortStartScheduler+0x84>)
 80017da:	2207      	movs	r2, #7
 80017dc:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80017de:	f89d 0003 	ldrb.w	r0, [sp, #3]
 80017e2:	1e54      	subs	r4, r2, #1
 80017e4:	0600      	lsls	r0, r0, #24
 80017e6:	d508      	bpl.n	80017fa <xPortStartScheduler+0x42>
		{
			ulMaxPRIGROUPValue--;
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 80017e8:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80017ec:	2101      	movs	r1, #1
 80017ee:	0052      	lsls	r2, r2, #1
 80017f0:	b2d2      	uxtb	r2, r2
 80017f2:	f88d 2003 	strb.w	r2, [sp, #3]
 80017f6:	4622      	mov	r2, r4
 80017f8:	e7f1      	b.n	80017de <xPortStartScheduler+0x26>
 80017fa:	b101      	cbz	r1, 80017fe <xPortStartScheduler+0x46>
 80017fc:	601a      	str	r2, [r3, #0]
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 80017fe:	681a      	ldr	r2, [r3, #0]
 8001800:	0212      	lsls	r2, r2, #8
 8001802:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8001806:	601a      	str	r2, [r3, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8001808:	9b01      	ldr	r3, [sp, #4]
 800180a:	4a0a      	ldr	r2, [pc, #40]	; (8001834 <xPortStartScheduler+0x7c>)
 800180c:	b2db      	uxtb	r3, r3
 800180e:	7013      	strb	r3, [r2, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8001810:	4b0b      	ldr	r3, [pc, #44]	; (8001840 <xPortStartScheduler+0x88>)
 8001812:	681a      	ldr	r2, [r3, #0]
 8001814:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8001818:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 800181a:	681a      	ldr	r2, [r3, #0]
 800181c:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 8001820:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 8001822:	f7ff ffb5 	bl	8001790 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8001826:	4b07      	ldr	r3, [pc, #28]	; (8001844 <xPortStartScheduler+0x8c>)
 8001828:	2200      	movs	r2, #0
 800182a:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 800182c:	f7ff ff08 	bl	8001640 <prvPortStartFirstTask>

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
 8001830:	f7ff ff48 	bl	80016c4 <prvTaskExitError>
 8001834:	e000e400 	.word	0xe000e400
 8001838:	20000774 	.word	0x20000774
 800183c:	20000778 	.word	0x20000778
 8001840:	e000ed20 	.word	0xe000ed20
 8001844:	2000001c 	.word	0x2000001c

08001848 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8001848:	b538      	push	{r3, r4, r5, lr}
 800184a:	4604      	mov	r4, r0
void *pvReturn = NULL;
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 800184c:	0743      	lsls	r3, r0, #29
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800184e:	bf1c      	itt	ne
 8001850:	f020 0407 	bicne.w	r4, r0, #7
 8001854:	3408      	addne	r4, #8
		}
	#endif

	vTaskSuspendAll();
 8001856:	f7ff fd99 	bl	800138c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 800185a:	4a0c      	ldr	r2, [pc, #48]	; (800188c <pvPortMalloc+0x44>)
 800185c:	6813      	ldr	r3, [r2, #0]
 800185e:	b91b      	cbnz	r3, 8001868 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
 8001860:	4b0b      	ldr	r3, [pc, #44]	; (8001890 <pvPortMalloc+0x48>)
 8001862:	f023 0307 	bic.w	r3, r3, #7
 8001866:	6013      	str	r3, [r2, #0]
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8001868:	490a      	ldr	r1, [pc, #40]	; (8001894 <pvPortMalloc+0x4c>)
 800186a:	680b      	ldr	r3, [r1, #0]
 800186c:	441c      	add	r4, r3
 800186e:	f5b4 6fff 	cmp.w	r4, #2040	; 0x7f8
 8001872:	d205      	bcs.n	8001880 <pvPortMalloc+0x38>
 8001874:	42a3      	cmp	r3, r4
 8001876:	d203      	bcs.n	8001880 <pvPortMalloc+0x38>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 8001878:	6815      	ldr	r5, [r2, #0]
			xNextFreeByte += xWantedSize;
 800187a:	600c      	str	r4, [r1, #0]
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 800187c:	441d      	add	r5, r3
 800187e:	e000      	b.n	8001882 <pvPortMalloc+0x3a>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 8001880:	2500      	movs	r5, #0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}	
	xTaskResumeAll();
 8001882:	f7ff fe19 	bl	80014b8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 8001886:	4628      	mov	r0, r5
 8001888:	bd38      	pop	{r3, r4, r5, pc}
 800188a:	bf00      	nop
 800188c:	20000780 	.word	0x20000780
 8001890:	2000078c 	.word	0x2000078c
 8001894:	2000077c 	.word	0x2000077c

08001898 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 8001898:	b508      	push	{r3, lr}
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
 800189a:	b110      	cbz	r0, 80018a2 <vPortFree+0xa>
 800189c:	f7ff ff0a 	bl	80016b4 <ulPortSetInterruptMask>
 80018a0:	e7fe      	b.n	80018a0 <vPortFree+0x8>
 80018a2:	bd08      	pop	{r3, pc}

080018a4 <str_cmp>:
	}

	return 0;
}

int32_t str_cmp(const int8_t *str1, const int8_t *str2) {
 80018a4:	1e42      	subs	r2, r0, #1
 80018a6:	3901      	subs	r1, #1
	while (*str1 == *str2) {
 80018a8:	f912 0f01 	ldrsb.w	r0, [r2, #1]!
 80018ac:	f911 3f01 	ldrsb.w	r3, [r1, #1]!
 80018b0:	4298      	cmp	r0, r3
 80018b2:	d102      	bne.n	80018ba <str_cmp+0x16>
		if (*str1 == '\0' || *str2 == '\0')
 80018b4:	2800      	cmp	r0, #0
 80018b6:	d1f7      	bne.n	80018a8 <str_cmp+0x4>
 80018b8:	e007      	b.n	80018ca <str_cmp+0x26>
			break;
		str1++;
		str2++;
	}

	if (*str1 == '\0' && *str2 == '\0')
 80018ba:	b920      	cbnz	r0, 80018c6 <str_cmp+0x22>
 80018bc:	1c18      	adds	r0, r3, #0
 80018be:	bf18      	it	ne
 80018c0:	2001      	movne	r0, #1
 80018c2:	4240      	negs	r0, r0
 80018c4:	4770      	bx	lr
		return 0;
	else
		return -1;
 80018c6:	f04f 30ff 	mov.w	r0, #4294967295
}
 80018ca:	4770      	bx	lr

080018cc <xputc>:

static uint8_t dymc_print_type = DYMC_UART_SHELL_TYPE;

void xputc(x_stream_t* s, uint8_t c) {
	(void)s;
	if (CR_CRLF && (c == (uint8_t)'\n')) {
 80018cc:	290a      	cmp	r1, #10
/* pointer to the output  stream (external) */
void (*xfunc_out)(uint8_t);

static uint8_t dymc_print_type = DYMC_UART_SHELL_TYPE;

void xputc(x_stream_t* s, uint8_t c) {
 80018ce:	b570      	push	{r4, r5, r6, lr}
 80018d0:	460c      	mov	r4, r1
 80018d2:	4d06      	ldr	r5, [pc, #24]	; (80018ec <xputc+0x20>)
	(void)s;
	if (CR_CRLF && (c == (uint8_t)'\n')) {
 80018d4:	d102      	bne.n	80018dc <xputc+0x10>
		xfunc_out('\r');
 80018d6:	682b      	ldr	r3, [r5, #0]
 80018d8:	200d      	movs	r0, #13
 80018da:	4798      	blx	r3
	}
	if (xfunc_out) {
 80018dc:	682b      	ldr	r3, [r5, #0]
 80018de:	b11b      	cbz	r3, 80018e8 <xputc+0x1c>
		xfunc_out(c);
 80018e0:	4620      	mov	r0, r4
	}
}
 80018e2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	(void)s;
	if (CR_CRLF && (c == (uint8_t)'\n')) {
		xfunc_out('\r');
	}
	if (xfunc_out) {
		xfunc_out(c);
 80018e6:	4718      	bx	r3
 80018e8:	bd70      	pop	{r4, r5, r6, pc}
 80018ea:	bf00      	nop
 80018ec:	20001050 	.word	0x20001050

080018f0 <xstream>:
void sxputc(x_stream_t* s, uint8_t c) {
	*s->outstr++ = c;
	s->indexstr++;
}

int xstream(x_stream_t* stream, const char *fmt, va_list va_args) {
 80018f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80018f4:	4604      	mov	r4, r0
 80018f6:	460f      	mov	r7, r1
 80018f8:	4616      	mov	r6, r2
 80018fa:	b085      	sub	sp, #20
						}
					} else {
						base = 16;
					}
					for (digit = 0; digit < sizeof(num_stack);) {
						num_stack[digit++] = num%base;
 80018fc:	f10d 0804 	add.w	r8, sp, #4
	uint32_t base;
	uint32_t minus;
	uint8_t num_stack[11];
	uint8_t* ps;

	while (*fmt) {
 8001900:	7839      	ldrb	r1, [r7, #0]
 8001902:	2900      	cmp	r1, #0
 8001904:	f000 8086 	beq.w	8001a14 <xstream+0x124>
		switch (*fmt) {
 8001908:	2925      	cmp	r1, #37	; 0x25
 800190a:	d17e      	bne.n	8001a0a <xstream+0x11a>
		case '%':
			zero_padding = 0;
			if (fmt[1] == '0') {
 800190c:	787b      	ldrb	r3, [r7, #1]
				zero_padding = 1;
				++fmt;
			}
			format_lenght = 0;
 800190e:	2200      	movs	r2, #0

	while (*fmt) {
		switch (*fmt) {
		case '%':
			zero_padding = 0;
			if (fmt[1] == '0') {
 8001910:	2b30      	cmp	r3, #48	; 0x30
				zero_padding = 1;
				++fmt;
 8001912:	bf06      	itte	eq
 8001914:	3701      	addeq	r7, #1
	while (*fmt) {
		switch (*fmt) {
		case '%':
			zero_padding = 0;
			if (fmt[1] == '0') {
				zero_padding = 1;
 8001916:	f04f 0e01 	moveq.w	lr, #1
	uint8_t* ps;

	while (*fmt) {
		switch (*fmt) {
		case '%':
			zero_padding = 0;
 800191a:	f04f 0e00 	movne.w	lr, #0
					}
					goto next_loop;

				default:
					if (*fmt >= '0' && *fmt <= '9') {
						format_lenght = format_lenght*10 + (*fmt-'0');
 800191e:	230a      	movs	r3, #10
			if (fmt[1] == '0') {
				zero_padding = 1;
				++fmt;
			}
			format_lenght = 0;
			while (*++fmt) {
 8001920:	f817 1f01 	ldrb.w	r1, [r7, #1]!
 8001924:	2900      	cmp	r1, #0
 8001926:	d075      	beq.n	8001a14 <xstream+0x124>
				switch (*fmt) {
 8001928:	2963      	cmp	r1, #99	; 0x63
 800192a:	d00b      	beq.n	8001944 <xstream+0x54>
 800192c:	d803      	bhi.n	8001936 <xstream+0x46>
 800192e:	2925      	cmp	r1, #37	; 0x25
 8001930:	d06b      	beq.n	8001a0a <xstream+0x11a>
 8001932:	2958      	cmp	r1, #88	; 0x58
 8001934:	e004      	b.n	8001940 <xstream+0x50>
 8001936:	2973      	cmp	r1, #115	; 0x73
 8001938:	d056      	beq.n	80019e8 <xstream+0xf8>
 800193a:	2978      	cmp	r1, #120	; 0x78
 800193c:	d008      	beq.n	8001950 <xstream+0x60>
 800193e:	2964      	cmp	r1, #100	; 0x64
 8001940:	d15c      	bne.n	80019fc <xstream+0x10c>
 8001942:	e005      	b.n	8001950 <xstream+0x60>
				case '%':
					stream->xputc(stream, *fmt);
					goto next_loop;

				case 'c':
					stream->xputc(stream, va_arg(va_args, int32_t));
 8001944:	7831      	ldrb	r1, [r6, #0]
 8001946:	68a2      	ldr	r2, [r4, #8]
 8001948:	4620      	mov	r0, r4
 800194a:	3604      	adds	r6, #4
 800194c:	4790      	blx	r2
					goto next_loop;
 800194e:	e05f      	b.n	8001a10 <xstream+0x120>
				case 'd':
				case 'X':
				case 'x':
					minus = 0;
					num = va_arg(va_args, uint32_t);
					if (*fmt == 'd') {
 8001950:	2964      	cmp	r1, #100	; 0x64

				case 'd':
				case 'X':
				case 'x':
					minus = 0;
					num = va_arg(va_args, uint32_t);
 8001952:	6833      	ldr	r3, [r6, #0]
 8001954:	f106 0604 	add.w	r6, r6, #4
					if (*fmt == 'd') {
 8001958:	d104      	bne.n	8001964 <xstream+0x74>
						base = 10;
						if (num & (uint32_t)0x80000000) {
 800195a:	2b00      	cmp	r3, #0
 800195c:	da05      	bge.n	800196a <xstream+0x7a>
							num = -(int32_t)num;
 800195e:	425b      	negs	r3, r3
							minus = 1;
 8001960:	2001      	movs	r0, #1
 8001962:	e003      	b.n	800196c <xstream+0x7c>
					goto next_loop;

				case 'd':
				case 'X':
				case 'x':
					minus = 0;
 8001964:	2000      	movs	r0, #0
						if (num & (uint32_t)0x80000000) {
							num = -(int32_t)num;
							minus = 1;
						}
					} else {
						base = 16;
 8001966:	2110      	movs	r1, #16
 8001968:	e001      	b.n	800196e <xstream+0x7e>
					goto next_loop;

				case 'd':
				case 'X':
				case 'x':
					minus = 0;
 800196a:	2000      	movs	r0, #0
					num = va_arg(va_args, uint32_t);
					if (*fmt == 'd') {
						base = 10;
 800196c:	210a      	movs	r1, #10
							minus = 1;
						}
					} else {
						base = 16;
					}
					for (digit = 0; digit < sizeof(num_stack);) {
 800196e:	2500      	movs	r5, #0
						num_stack[digit++] = num%base;
 8001970:	fbb3 fcf1 	udiv	ip, r3, r1
 8001974:	fb01 331c 	mls	r3, r1, ip, r3
 8001978:	3501      	adds	r5, #1
 800197a:	eb08 0905 	add.w	r9, r8, r5
 800197e:	f809 3c01 	strb.w	r3, [r9, #-1]
						num /= base;
						if (num == 0) break;
 8001982:	4663      	mov	r3, ip
 8001984:	b10b      	cbz	r3, 800198a <xstream+0x9a>
							minus = 1;
						}
					} else {
						base = 16;
					}
					for (digit = 0; digit < sizeof(num_stack);) {
 8001986:	2d0b      	cmp	r5, #11
 8001988:	d1f2      	bne.n	8001970 <xstream+0x80>
						num_stack[digit++] = num%base;
						num /= base;
						if (num == 0) break;
					}
					if (minus) num_stack[digit++] = 0x7F;
 800198a:	b128      	cbz	r0, 8001998 <xstream+0xa8>
 800198c:	ab04      	add	r3, sp, #16
 800198e:	442b      	add	r3, r5
 8001990:	217f      	movs	r1, #127	; 0x7f
 8001992:	f803 1c0c 	strb.w	r1, [r3, #-12]
 8001996:	3501      	adds	r5, #1
					if (format_lenght > digit) {
 8001998:	4295      	cmp	r5, r2
 800199a:	d21b      	bcs.n	80019d4 <xstream+0xe4>
						int8_t paddingint8_t = ' ';
						format_lenght -= digit;
						if (zero_padding)
							paddingint8_t = '0';
 800199c:	f1be 0f00 	cmp.w	lr, #0
						if (num == 0) break;
					}
					if (minus) num_stack[digit++] = 0x7F;
					if (format_lenght > digit) {
						int8_t paddingint8_t = ' ';
						format_lenght -= digit;
 80019a0:	ebc5 0a02 	rsb	sl, r5, r2
						num /= base;
						if (num == 0) break;
					}
					if (minus) num_stack[digit++] = 0x7F;
					if (format_lenght > digit) {
						int8_t paddingint8_t = ' ';
 80019a4:	f04f 0900 	mov.w	r9, #0
						format_lenght -= digit;
						if (zero_padding)
							paddingint8_t = '0';
						while (format_lenght--) {
							stream->xputc(stream, paddingint8_t);
 80019a8:	bf14      	ite	ne
 80019aa:	f04f 0b30 	movne.w	fp, #48	; 0x30
 80019ae:	f04f 0b20 	moveq.w	fp, #32
					if (format_lenght > digit) {
						int8_t paddingint8_t = ' ';
						format_lenght -= digit;
						if (zero_padding)
							paddingint8_t = '0';
						while (format_lenght--) {
 80019b2:	45ca      	cmp	sl, r9
 80019b4:	d00e      	beq.n	80019d4 <xstream+0xe4>
							stream->xputc(stream, paddingint8_t);
 80019b6:	68a3      	ldr	r3, [r4, #8]
 80019b8:	4659      	mov	r1, fp
 80019ba:	4620      	mov	r0, r4
 80019bc:	4798      	blx	r3
 80019be:	f109 0901 	add.w	r9, r9, #1
 80019c2:	e7f6      	b.n	80019b2 <xstream+0xc2>
						}
					}
					for (i = digit-1; i >= 0; i--) {
						if (num_stack[i] == 0x7F) {
 80019c4:	f818 1005 	ldrb.w	r1, [r8, r5]
 80019c8:	68a3      	ldr	r3, [r4, #8]
 80019ca:	297f      	cmp	r1, #127	; 0x7f
 80019cc:	d106      	bne.n	80019dc <xstream+0xec>
							stream->xputc(stream, '-');
 80019ce:	212d      	movs	r1, #45	; 0x2d
						} else if (num_stack[i] > 9) {
							stream->xputc(stream, num_stack[i]-10 + 'A');
						} else {
							stream->xputc(stream, num_stack[i] + '0');
 80019d0:	4620      	mov	r0, r4
 80019d2:	4798      	blx	r3
							paddingint8_t = '0';
						while (format_lenght--) {
							stream->xputc(stream, paddingint8_t);
						}
					}
					for (i = digit-1; i >= 0; i--) {
 80019d4:	3d01      	subs	r5, #1
 80019d6:	2d00      	cmp	r5, #0
 80019d8:	daf4      	bge.n	80019c4 <xstream+0xd4>
 80019da:	e019      	b.n	8001a10 <xstream+0x120>
						if (num_stack[i] == 0x7F) {
							stream->xputc(stream, '-');
						} else if (num_stack[i] > 9) {
 80019dc:	2909      	cmp	r1, #9
							stream->xputc(stream, num_stack[i]-10 + 'A');
 80019de:	bf8c      	ite	hi
 80019e0:	3137      	addhi	r1, #55	; 0x37
						} else {
							stream->xputc(stream, num_stack[i] + '0');
 80019e2:	3130      	addls	r1, #48	; 0x30
 80019e4:	b2c9      	uxtb	r1, r1
 80019e6:	e7f3      	b.n	80019d0 <xstream+0xe0>
 80019e8:	6835      	ldr	r5, [r6, #0]
 80019ea:	3604      	adds	r6, #4
 80019ec:	3d01      	subs	r5, #1
					}
					goto next_loop;

				case 's':
					ps = va_arg(va_args, uint8_t*);
					while(*ps) {
 80019ee:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80019f2:	b169      	cbz	r1, 8001a10 <xstream+0x120>
						stream->xputc(stream, *ps++);
 80019f4:	68a3      	ldr	r3, [r4, #8]
 80019f6:	4620      	mov	r0, r4
 80019f8:	4798      	blx	r3
 80019fa:	e7f8      	b.n	80019ee <xstream+0xfe>
					}
					goto next_loop;

				default:
					if (*fmt >= '0' && *fmt <= '9') {
 80019fc:	3930      	subs	r1, #48	; 0x30
 80019fe:	b2c8      	uxtb	r0, r1
 8001a00:	2809      	cmp	r0, #9
 8001a02:	d807      	bhi.n	8001a14 <xstream+0x124>
						format_lenght = format_lenght*10 + (*fmt-'0');
 8001a04:	fb03 1202 	mla	r2, r3, r2, r1
 8001a08:	e78a      	b.n	8001920 <xstream+0x30>
			if (*fmt == 0) {
				goto exit;
			}

		default:
			stream->xputc(stream, *fmt);
 8001a0a:	68a3      	ldr	r3, [r4, #8]
 8001a0c:	4620      	mov	r0, r4
 8001a0e:	4798      	blx	r3
			break;
		}
next_loop:
		fmt++;
 8001a10:	3701      	adds	r7, #1
 8001a12:	e775      	b.n	8001900 <xstream+0x10>
	}
exit:
	va_end(va_args);
	return stream->indexstr;
}
 8001a14:	6820      	ldr	r0, [r4, #0]
 8001a16:	b005      	add	sp, #20
 8001a18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001a1c <xprintf>:

void xprintf(const char *fmt, ...) {
 8001a1c:	b40f      	push	{r0, r1, r2, r3}
 8001a1e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8001a20:	aa06      	add	r2, sp, #24
 8001a22:	f852 1b04 	ldr.w	r1, [r2], #4
	x_stream_t xprintf_stream;
	va_list va;

	va_start(va,fmt);
	xprintf_stream.xputc = xputc;
 8001a26:	4b05      	ldr	r3, [pc, #20]	; (8001a3c <xprintf+0x20>)
	xstream(&xprintf_stream, fmt, va);
 8001a28:	a801      	add	r0, sp, #4

void xprintf(const char *fmt, ...) {
	x_stream_t xprintf_stream;
	va_list va;

	va_start(va,fmt);
 8001a2a:	9200      	str	r2, [sp, #0]
	xprintf_stream.xputc = xputc;
 8001a2c:	9303      	str	r3, [sp, #12]
	xstream(&xprintf_stream, fmt, va);
 8001a2e:	f7ff ff5f 	bl	80018f0 <xstream>
	va_end(va);
}
 8001a32:	b005      	add	sp, #20
 8001a34:	f85d eb04 	ldr.w	lr, [sp], #4
 8001a38:	b004      	add	sp, #16
 8001a3a:	4770      	bx	lr
 8001a3c:	080018cd 	.word	0x080018cd

08001a40 <cmd_line_parser>:

#include "cmd_line.h"
#include "../common/utils.h"
#include "../common/xprintf.h"

uint8_t cmd_line_parser(cmd_line_t* cmd_table, uint8_t* command){
 8001a40:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8001a44:	460d      	mov	r5, r1
	uint8_t     cmd[MAX_CMD_SIZE];
	uint8_t*    p_command = command;
	uint8_t     cmd_index = 0;
	uint8_t     indexCheck = 0;

	if (cmd_table == (cmd_line_t*)0) {
 8001a46:	4604      	mov	r4, r0
 8001a48:	b390      	cbz	r0, 8001ab0 <cmd_line_parser+0x70>
		return CMD_TBL_NOT_FOUND;
	}

	/* get cmd */
	while(*p_command) {
		if (*p_command == ' ' || *p_command == '\r' || *p_command == '\n') {
 8001a4a:	481b      	ldr	r0, [pc, #108]	; (8001ab8 <cmd_line_parser+0x78>)
 8001a4c:	2300      	movs	r3, #0
	if (cmd_table == (cmd_line_t*)0) {
		return CMD_TBL_NOT_FOUND;
	}

	/* get cmd */
	while(*p_command) {
 8001a4e:	5ce9      	ldrb	r1, [r5, r3]
 8001a50:	b181      	cbz	r1, 8001a74 <cmd_line_parser+0x34>
		if (*p_command == ' ' || *p_command == '\r' || *p_command == '\n') {
 8001a52:	f1a1 020a 	sub.w	r2, r1, #10
 8001a56:	b2d2      	uxtb	r2, r2
 8001a58:	2a16      	cmp	r2, #22
 8001a5a:	d80f      	bhi.n	8001a7c <cmd_line_parser+0x3c>
 8001a5c:	fa20 f202 	lsr.w	r2, r0, r2
 8001a60:	f002 0201 	and.w	r2, r2, #1
 8001a64:	f082 0601 	eor.w	r6, r2, #1
 8001a68:	b142      	cbz	r2, 8001a7c <cmd_line_parser+0x3c>
			cmd[cmd_index] = 0;
 8001a6a:	b2db      	uxtb	r3, r3
 8001a6c:	aa04      	add	r2, sp, #16
 8001a6e:	4413      	add	r3, r2
 8001a70:	f803 6c0c 	strb.w	r6, [r3, #-12]
 8001a74:	2600      	movs	r6, #0
			}
		}
	}

	/* find respective command in command table */
	while(cmd_table[indexCheck].cmd){
 8001a76:	f04f 080c 	mov.w	r8, #12
 8001a7a:	e006      	b.n	8001a8a <cmd_line_parser+0x4a>
		if (*p_command == ' ' || *p_command == '\r' || *p_command == '\n') {
			cmd[cmd_index] = 0;
			break;
		}
		else {
			cmd[cmd_index++] = *(p_command++);
 8001a7c:	aa01      	add	r2, sp, #4
 8001a7e:	5499      	strb	r1, [r3, r2]
 8001a80:	3301      	adds	r3, #1
			if (cmd_index >= MAX_CMD_SIZE) {
 8001a82:	2b0c      	cmp	r3, #12
 8001a84:	d1e3      	bne.n	8001a4e <cmd_line_parser+0xe>
				return CMD_TOO_LONG;
 8001a86:	2003      	movs	r0, #3
 8001a88:	e012      	b.n	8001ab0 <cmd_line_parser+0x70>
			}
		}
	}

	/* find respective command in command table */
	while(cmd_table[indexCheck].cmd){
 8001a8a:	b2f3      	uxtb	r3, r6
 8001a8c:	fb08 f303 	mul.w	r3, r8, r3
 8001a90:	58e0      	ldr	r0, [r4, r3]
 8001a92:	18e7      	adds	r7, r4, r3
 8001a94:	b150      	cbz	r0, 8001aac <cmd_line_parser+0x6c>

		if (str_cmp(cmd_table[indexCheck].cmd, (const int8_t*)cmd) == 0) {
 8001a96:	a901      	add	r1, sp, #4
 8001a98:	f7ff ff04 	bl	80018a4 <str_cmp>
 8001a9c:	3601      	adds	r6, #1
 8001a9e:	2800      	cmp	r0, #0
 8001aa0:	d1f3      	bne.n	8001a8a <cmd_line_parser+0x4a>

			/* perform respective function */
			cmd_table[indexCheck].func(command);
 8001aa2:	687b      	ldr	r3, [r7, #4]
 8001aa4:	4628      	mov	r0, r5
 8001aa6:	4798      	blx	r3

			/* return success */
			return CMD_SUCCESS;
 8001aa8:	2001      	movs	r0, #1
 8001aaa:	e001      	b.n	8001ab0 <cmd_line_parser+0x70>
		}

		indexCheck++;
	}

	return CMD_NOT_FOUND;  /* command not found */
 8001aac:	2002      	movs	r0, #2
 8001aae:	e7ff      	b.n	8001ab0 <cmd_line_parser+0x70>
}
 8001ab0:	b004      	add	sp, #16
 8001ab2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001ab6:	bf00      	nop
 8001ab8:	00400009 	.word	0x00400009

08001abc <xputchar>:

	xfunc_out = xputchar;
}

void xputchar(uint8_t c) {
	USART_SendData(USART1, (uint8_t)c);
 8001abc:	4601      	mov	r1, r0
	USART_Cmd(USARTx, ENABLE);

	xfunc_out = xputchar;
}

void xputchar(uint8_t c) {
 8001abe:	b508      	push	{r3, lr}
	USART_SendData(USART1, (uint8_t)c);
 8001ac0:	4804      	ldr	r0, [pc, #16]	; (8001ad4 <xputchar+0x18>)
 8001ac2:	f7ff f82b 	bl	8000b1c <USART_SendData>
	while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
 8001ac6:	2180      	movs	r1, #128	; 0x80
 8001ac8:	4802      	ldr	r0, [pc, #8]	; (8001ad4 <xputchar+0x18>)
 8001aca:	f7ff f8a9 	bl	8000c20 <USART_GetFlagStatus>
 8001ace:	2800      	cmp	r0, #0
 8001ad0:	d0f9      	beq.n	8001ac6 <xputchar+0xa>
}
 8001ad2:	bd08      	pop	{r3, pc}
 8001ad4:	40013800 	.word	0x40013800

08001ad8 <sys_cfg_console>:
#include "common/xprintf.h"
#include "common/cmd_line.h"

extern cmd_line_t lgn_cmd_table[];

void sys_cfg_console() {
 8001ad8:	b530      	push	{r4, r5, lr}
	USART_InitTypeDef USART_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Enable GPIO clock */
	RCC_APB2PeriphClockCmd(USARTx_TX_GPIO_CLK | USARTx_RX_GPIO_CLK, ENABLE);
 8001ada:	2101      	movs	r1, #1
#include "common/xprintf.h"
#include "common/cmd_line.h"

extern cmd_line_t lgn_cmd_table[];

void sys_cfg_console() {
 8001adc:	b087      	sub	sp, #28
	USART_InitTypeDef USART_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Enable GPIO clock */
	RCC_APB2PeriphClockCmd(USARTx_TX_GPIO_CLK | USARTx_RX_GPIO_CLK, ENABLE);
 8001ade:	2004      	movs	r0, #4
 8001ae0:	f7fe fe52 	bl	8000788 <RCC_APB2PeriphClockCmd>

	/* Enable USART clock */
	RCC_APB2PeriphClockCmd(USARTx_CLK, ENABLE);
 8001ae4:	2101      	movs	r1, #1
 8001ae6:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8001aea:	f7fe fe4d 	bl	8000788 <RCC_APB2PeriphClockCmd>

	/* Configure USART Tx and Rx as alternate function push-pull */
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 8001aee:	2318      	movs	r3, #24
 8001af0:	f88d 3003 	strb.w	r3, [sp, #3]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 8001af4:	2302      	movs	r3, #2
	GPIO_InitStructure.GPIO_Pin = USARTx_TX_PIN;
 8001af6:	ac06      	add	r4, sp, #24
	/* Enable USART clock */
	RCC_APB2PeriphClockCmd(USARTx_CLK, ENABLE);

	/* Configure USART Tx and Rx as alternate function push-pull */
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 8001af8:	f88d 3002 	strb.w	r3, [sp, #2]
	GPIO_InitStructure.GPIO_Pin = USARTx_TX_PIN;
	GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStructure);
 8001afc:	4d26      	ldr	r5, [pc, #152]	; (8001b98 <sys_cfg_console+0xc0>)
	RCC_APB2PeriphClockCmd(USARTx_CLK, ENABLE);

	/* Configure USART Tx and Rx as alternate function push-pull */
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_InitStructure.GPIO_Pin = USARTx_TX_PIN;
 8001afe:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001b02:	f824 3d18 	strh.w	r3, [r4, #-24]!
	GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStructure);
 8001b06:	4621      	mov	r1, r4
 8001b08:	4628      	mov	r0, r5
 8001b0a:	f7fe fba7 	bl	800025c <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin = USARTx_RX_PIN;
 8001b0e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001b12:	f8ad 3000 	strh.w	r3, [sp]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
	GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStructure);
 8001b16:	4621      	mov	r1, r4
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_InitStructure.GPIO_Pin = USARTx_TX_PIN;
	GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = USARTx_RX_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
 8001b18:	2328      	movs	r3, #40	; 0x28
	GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStructure);
 8001b1a:	4628      	mov	r0, r5
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_InitStructure.GPIO_Pin = USARTx_TX_PIN;
	GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = USARTx_RX_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
 8001b1c:	f88d 3003 	strb.w	r3, [sp, #3]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
	USART_Init(USARTx, &USART_InitStructure);
 8001b20:	f505 5540 	add.w	r5, r5, #12288	; 0x3000
	GPIO_InitStructure.GPIO_Pin = USARTx_TX_PIN;
	GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = USARTx_RX_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
	GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStructure);
 8001b24:	f7fe fb9a 	bl	800025c <GPIO_Init>

	/* USARTx configuration */
	USART_InitStructure.USART_BaudRate = 115200;
 8001b28:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8001b2c:	2400      	movs	r4, #0
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
	USART_Init(USARTx, &USART_InitStructure);
 8001b2e:	a902      	add	r1, sp, #8
	GPIO_InitStructure.GPIO_Pin = USARTx_RX_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
	GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStructure);

	/* USARTx configuration */
	USART_InitStructure.USART_BaudRate = 115200;
 8001b30:	9302      	str	r3, [sp, #8]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
	USART_Init(USARTx, &USART_InitStructure);
 8001b32:	4628      	mov	r0, r5
	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8001b34:	230c      	movs	r3, #12
 8001b36:	f8ad 3012 	strh.w	r3, [sp, #18]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
	GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStructure);

	/* USARTx configuration */
	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8001b3a:	f8ad 400c 	strh.w	r4, [sp, #12]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8001b3e:	f8ad 400e 	strh.w	r4, [sp, #14]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 8001b42:	f8ad 4010 	strh.w	r4, [sp, #16]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8001b46:	f8ad 4014 	strh.w	r4, [sp, #20]
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
	USART_Init(USARTx, &USART_InitStructure);
 8001b4a:	f7fe fef1 	bl	8000930 <USART_Init>

	/* NVIC configuration */
	/* Configure the Priority Group to 2 bits */
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
 8001b4e:	f44f 60a0 	mov.w	r0, #1280	; 0x500
 8001b52:	f7fe fc75 	bl	8000440 <NVIC_PriorityGroupConfig>

	/* Enable the USARTx Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USARTx_IRQn;
 8001b56:	2325      	movs	r3, #37	; 0x25
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8001b58:	f88d 4005 	strb.w	r4, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 8001b5c:	f88d 4006 	strb.w	r4, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 8001b60:	a801      	add	r0, sp, #4

	/* Enable the USARTx Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USARTx_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8001b62:	2401      	movs	r4, #1
	/* NVIC configuration */
	/* Configure the Priority Group to 2 bits */
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);

	/* Enable the USARTx Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USARTx_IRQn;
 8001b64:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8001b68:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 8001b6c:	f7fe fc72 	bl	8000454 <NVIC_Init>

	USART_ClearITPendingBit(USARTx,USART_IT_RXNE);
 8001b70:	4628      	mov	r0, r5
 8001b72:	f240 5125 	movw	r1, #1317	; 0x525
 8001b76:	f7ff f881 	bl	8000c7c <USART_ClearITPendingBit>
	USART_ITConfig(USARTx, USART_IT_RXNE, ENABLE);
 8001b7a:	4622      	mov	r2, r4
 8001b7c:	4628      	mov	r0, r5
 8001b7e:	f240 5125 	movw	r1, #1317	; 0x525
 8001b82:	f7fe ff65 	bl	8000a50 <USART_ITConfig>

	/* Enable USART */
	USART_Cmd(USARTx, ENABLE);
 8001b86:	4621      	mov	r1, r4
 8001b88:	4628      	mov	r0, r5
 8001b8a:	f7fe ff53 	bl	8000a34 <USART_Cmd>

	xfunc_out = xputchar;
 8001b8e:	4a03      	ldr	r2, [pc, #12]	; (8001b9c <sys_cfg_console+0xc4>)
 8001b90:	4b03      	ldr	r3, [pc, #12]	; (8001ba0 <sys_cfg_console+0xc8>)
 8001b92:	601a      	str	r2, [r3, #0]
}
 8001b94:	b007      	add	sp, #28
 8001b96:	bd30      	pop	{r4, r5, pc}
 8001b98:	40010800 	.word	0x40010800
 8001b9c:	08001abd 	.word	0x08001abd
 8001ba0:	20001050 	.word	0x20001050

08001ba4 <sys_ctrl_shell_get_char>:
void xputchar(uint8_t c) {
	USART_SendData(USART1, (uint8_t)c);
	while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
}

uint8_t sys_ctrl_shell_get_char() {
 8001ba4:	b508      	push	{r3, lr}
	uint8_t c = 0;
	if(USART_GetITStatus(USARTx, USART_IT_RXNE) == SET) {
 8001ba6:	f240 5125 	movw	r1, #1317	; 0x525
 8001baa:	4806      	ldr	r0, [pc, #24]	; (8001bc4 <sys_ctrl_shell_get_char+0x20>)
 8001bac:	f7ff f842 	bl	8000c34 <USART_GetITStatus>
 8001bb0:	2801      	cmp	r0, #1
 8001bb2:	d104      	bne.n	8001bbe <sys_ctrl_shell_get_char+0x1a>
		c = (uint8_t)USART_ReceiveData(USARTx);
 8001bb4:	4803      	ldr	r0, [pc, #12]	; (8001bc4 <sys_ctrl_shell_get_char+0x20>)
 8001bb6:	f7fe ffb5 	bl	8000b24 <USART_ReceiveData>
 8001bba:	b2c0      	uxtb	r0, r0
 8001bbc:	bd08      	pop	{r3, pc}
	USART_SendData(USART1, (uint8_t)c);
	while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
}

uint8_t sys_ctrl_shell_get_char() {
	uint8_t c = 0;
 8001bbe:	2000      	movs	r0, #0
	if(USART_GetITStatus(USARTx, USART_IT_RXNE) == SET) {
		c = (uint8_t)USART_ReceiveData(USARTx);
	}
	return c;
}
 8001bc0:	bd08      	pop	{r3, pc}
 8001bc2:	bf00      	nop
 8001bc4:	40013800 	.word	0x40013800

08001bc8 <sys_irq_shell>:

void sys_irq_shell() {
 8001bc8:	b508      	push	{r3, lr}
	uint8_t c = 0;
	c = sys_ctrl_shell_get_char();
 8001bca:	f7ff ffeb 	bl	8001ba4 <sys_ctrl_shell_get_char>
	if (shell.index < SHELL_BUFFER_LENGHT - 1) {
 8001bce:	4910      	ldr	r1, [pc, #64]	; (8001c10 <sys_irq_shell+0x48>)
 8001bd0:	780b      	ldrb	r3, [r1, #0]
 8001bd2:	460a      	mov	r2, r1
 8001bd4:	2b1e      	cmp	r3, #30
 8001bd6:	d817      	bhi.n	8001c08 <sys_irq_shell+0x40>
		if (c == '\r' || c == '\n') {
 8001bd8:	280d      	cmp	r0, #13
 8001bda:	d001      	beq.n	8001be0 <sys_irq_shell+0x18>
 8001bdc:	280a      	cmp	r0, #10
 8001bde:	d108      	bne.n	8001bf2 <sys_irq_shell+0x2a>
			shell.data[shell.index] = c;
 8001be0:	4413      	add	r3, r2
			shell.data[shell.index + 1] = 0;
 8001be2:	2100      	movs	r1, #0
void sys_irq_shell() {
	uint8_t c = 0;
	c = sys_ctrl_shell_get_char();
	if (shell.index < SHELL_BUFFER_LENGHT - 1) {
		if (c == '\r' || c == '\n') {
			shell.data[shell.index] = c;
 8001be4:	7058      	strb	r0, [r3, #1]
			shell.data[shell.index + 1] = 0;
 8001be6:	7099      	strb	r1, [r3, #2]
			shell.index = 0;

			cmd_flag = 1;
 8001be8:	4b0a      	ldr	r3, [pc, #40]	; (8001c14 <sys_irq_shell+0x4c>)
	c = sys_ctrl_shell_get_char();
	if (shell.index < SHELL_BUFFER_LENGHT - 1) {
		if (c == '\r' || c == '\n') {
			shell.data[shell.index] = c;
			shell.data[shell.index + 1] = 0;
			shell.index = 0;
 8001bea:	7011      	strb	r1, [r2, #0]

			cmd_flag = 1;
 8001bec:	2201      	movs	r2, #1
 8001bee:	701a      	strb	r2, [r3, #0]
 8001bf0:	bd08      	pop	{r3, pc}
		}
		else if (c == 8) {
 8001bf2:	2808      	cmp	r0, #8
 8001bf4:	d103      	bne.n	8001bfe <sys_irq_shell+0x36>
			if (shell.index) {
 8001bf6:	b14b      	cbz	r3, 8001c0c <sys_irq_shell+0x44>
				shell.index--;
 8001bf8:	1e5a      	subs	r2, r3, #1
 8001bfa:	700a      	strb	r2, [r1, #0]
 8001bfc:	bd08      	pop	{r3, pc}
			}
		}
		else {
			shell.data[shell.index++] = c;
 8001bfe:	1c5a      	adds	r2, r3, #1
 8001c00:	440b      	add	r3, r1
 8001c02:	700a      	strb	r2, [r1, #0]
 8001c04:	7058      	strb	r0, [r3, #1]
 8001c06:	bd08      	pop	{r3, pc}
		}
	}
	else {
		shell.index = 0;
 8001c08:	2300      	movs	r3, #0
 8001c0a:	700b      	strb	r3, [r1, #0]
 8001c0c:	bd08      	pop	{r3, pc}
 8001c0e:	bf00      	nop
 8001c10:	2000102d 	.word	0x2000102d
 8001c14:	2000068c 	.word	0x2000068c

08001c18 <task_shell>:
	}
}

void task_shell(uint8_t *msg) {
 8001c18:	b510      	push	{r4, lr}
 8001c1a:	4601      	mov	r1, r0

	uint8_t fist_char = *msg;
 8001c1c:	7804      	ldrb	r4, [r0, #0]

	switch (cmd_line_parser(lgn_cmd_table, msg)) {
 8001c1e:	480d      	ldr	r0, [pc, #52]	; (8001c54 <task_shell+0x3c>)
 8001c20:	f7ff ff0e 	bl	8001a40 <cmd_line_parser>
 8001c24:	2803      	cmp	r0, #3
 8001c26:	d80d      	bhi.n	8001c44 <task_shell+0x2c>
 8001c28:	e8df f000 	tbb	[pc, r0]
 8001c2c:	08020f0a 	.word	0x08020f0a
	case CMD_SUCCESS:
		break;

	case CMD_NOT_FOUND:
		if (fist_char != '\r' &&
 8001c30:	2c0d      	cmp	r4, #13
 8001c32:	d00a      	beq.n	8001c4a <task_shell+0x32>
 8001c34:	2c0a      	cmp	r4, #10
 8001c36:	d008      	beq.n	8001c4a <task_shell+0x32>
				fist_char != '\n') {
			xprintf("cmd unknown\n");
 8001c38:	4807      	ldr	r0, [pc, #28]	; (8001c58 <task_shell+0x40>)
 8001c3a:	e004      	b.n	8001c46 <task_shell+0x2e>
		}
		break;

	case CMD_TOO_LONG:
		xprintf("cmd too long\n");
 8001c3c:	4807      	ldr	r0, [pc, #28]	; (8001c5c <task_shell+0x44>)
 8001c3e:	e002      	b.n	8001c46 <task_shell+0x2e>
		break;

	case CMD_TBL_NOT_FOUND:
		xprintf("cmd table not found\n");
 8001c40:	4807      	ldr	r0, [pc, #28]	; (8001c60 <task_shell+0x48>)
 8001c42:	e000      	b.n	8001c46 <task_shell+0x2e>
		break;

	default:
		xprintf("cmd error\n");
 8001c44:	4807      	ldr	r0, [pc, #28]	; (8001c64 <task_shell+0x4c>)
 8001c46:	f7ff fee9 	bl	8001a1c <xprintf>
		break;
	}

	xprintf("#");
}
 8001c4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	default:
		xprintf("cmd error\n");
		break;
	}

	xprintf("#");
 8001c4e:	4806      	ldr	r0, [pc, #24]	; (8001c68 <task_shell+0x50>)
 8001c50:	f7ff bee4 	b.w	8001a1c <xprintf>
 8001c54:	20000020 	.word	0x20000020
 8001c58:	080021a9 	.word	0x080021a9
 8001c5c:	080021b6 	.word	0x080021b6
 8001c60:	080021c4 	.word	0x080021c4
 8001c64:	080021d9 	.word	0x080021d9
 8001c68:	080021e4 	.word	0x080021e4

08001c6c <shell_reboot>:
int32_t shell_help(uint8_t* argv) {
	return 0;
}

int32_t shell_reboot(uint8_t* argv) {
}
 8001c6c:	4770      	bx	lr

08001c6e <shell_ram>:
	return 0;
}
\
int32_t shell_ram(uint8_t* argv) {
	return 0;
}
 8001c6e:	2000      	movs	r0, #0
 8001c70:	4770      	bx	lr
	...

08001c74 <shell_fatal>:
	(void)argv;
	xprintf("app ver 1.0\n");
	return 0;
}

int32_t shell_fatal(uint8_t* argv) {
 8001c74:	b508      	push	{r3, lr}
	xprintf("fatal not support\n");
 8001c76:	4802      	ldr	r0, [pc, #8]	; (8001c80 <shell_fatal+0xc>)
 8001c78:	f7ff fed0 	bl	8001a1c <xprintf>
	return 0;
}
 8001c7c:	2000      	movs	r0, #0
 8001c7e:	bd08      	pop	{r3, pc}
 8001c80:	080021e6 	.word	0x080021e6

08001c84 <shell_ver>:
	(void)argv;
	xprintf("\033[2J\r");
	return 0;
}

int32_t shell_ver(uint8_t* argv) {
 8001c84:	b508      	push	{r3, lr}
	(void)argv;
	xprintf("app ver 1.0\n");
 8001c86:	4802      	ldr	r0, [pc, #8]	; (8001c90 <shell_ver+0xc>)
 8001c88:	f7ff fec8 	bl	8001a1c <xprintf>
	return 0;
}
 8001c8c:	2000      	movs	r0, #0
 8001c8e:	bd08      	pop	{r3, pc}
 8001c90:	080021f9 	.word	0x080021f9

08001c94 <shell_reset>:

/*****************************************************************************/
/*  command function definaion
 */
/*****************************************************************************/
int32_t shell_reset(uint8_t* argv) {
 8001c94:	b508      	push	{r3, lr}
	(void)argv;
	xprintf("\033[2J\r");
 8001c96:	4802      	ldr	r0, [pc, #8]	; (8001ca0 <shell_reset+0xc>)
 8001c98:	f7ff fec0 	bl	8001a1c <xprintf>
	return 0;
}
 8001c9c:	2000      	movs	r0, #0
 8001c9e:	bd08      	pop	{r3, pc}
 8001ca0:	08002206 	.word	0x08002206

08001ca4 <shell_set_calib>:
 8001ca4:	2000      	movs	r0, #0
 8001ca6:	4770      	bx	lr

08001ca8 <shell_help>:
 8001ca8:	2000      	movs	r0, #0
 8001caa:	4770      	bx	lr

08001cac <shell_flash>:
 8001cac:	2000      	movs	r0, #0
 8001cae:	4770      	bx	lr

08001cb0 <shell_pop>:
 8001cb0:	2000      	movs	r0, #0
 8001cb2:	4770      	bx	lr

08001cb4 <shell_out>:
 8001cb4:	2000      	movs	r0, #0
 8001cb6:	4770      	bx	lr

08001cb8 <shell_mode>:
 8001cb8:	2000      	movs	r0, #0
 8001cba:	4770      	bx	lr

08001cbc <shell_sensor>:
 8001cbc:	2000      	movs	r0, #0
 8001cbe:	4770      	bx	lr

08001cc0 <shell_cfg>:
 8001cc0:	2000      	movs	r0, #0
 8001cc2:	4770      	bx	lr

08001cc4 <shell_modbus_rs485>:

int32_t shell_set_calib(uint8_t* argv){
	return 0;
}

int32_t shell_modbus_rs485(uint8_t* argv) {
 8001cc4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
/*****************************************************************************/
/*  parser function definaion
 */
/*****************************************************************************/
uint8_t str_parser(char* str) {
	strcpy(cmd_buffer, str);
 8001cc8:	4601      	mov	r1, r0

	uint8_t i = 0;
	uint8_t str_list_index = 0;
	uint8_t flag_insert_str = 1;

	while (cmd_buffer[i] != 0 && cmd_buffer[i] != '\n' && cmd_buffer[i] != '\r') {
 8001cca:	4f44      	ldr	r7, [pc, #272]	; (8001ddc <shell_modbus_rs485+0x118>)
/*****************************************************************************/
/*  parser function definaion
 */
/*****************************************************************************/
uint8_t str_parser(char* str) {
	strcpy(cmd_buffer, str);
 8001ccc:	4843      	ldr	r0, [pc, #268]	; (8001ddc <shell_modbus_rs485+0x118>)
 8001cce:	f000 f8a3 	bl	8001e18 <strcpy>
	str_list_len = 0;
 8001cd2:	2000      	movs	r0, #0

	uint8_t i = 0;
	uint8_t str_list_index = 0;
 8001cd4:	4601      	mov	r1, r0
 8001cd6:	46be      	mov	lr, r7
	uint8_t flag_insert_str = 1;

	while (cmd_buffer[i] != 0 && cmd_buffer[i] != '\n' && cmd_buffer[i] != '\r') {
		if (cmd_buffer[i] == ' ') {
			cmd_buffer[i] = 0;
 8001cd8:	4684      	mov	ip, r0

	uint8_t i = 0;
	uint8_t str_list_index = 0;
	uint8_t flag_insert_str = 1;

	while (cmd_buffer[i] != 0 && cmd_buffer[i] != '\n' && cmd_buffer[i] != '\r') {
 8001cda:	f242 4801 	movw	r8, #9217	; 0x2401
 8001cde:	4d40      	ldr	r5, [pc, #256]	; (8001de0 <shell_modbus_rs485+0x11c>)
		if (cmd_buffer[i] == ' ') {
			cmd_buffer[i] = 0;
			flag_insert_str = 1;
		}
		else if (flag_insert_str) {
			str_list[str_list_index++] = &cmd_buffer[i];
 8001ce0:	f8df 9104 	ldr.w	r9, [pc, #260]	; 8001de8 <shell_modbus_rs485+0x124>
	strcpy(cmd_buffer, str);
	str_list_len = 0;

	uint8_t i = 0;
	uint8_t str_list_index = 0;
	uint8_t flag_insert_str = 1;
 8001ce4:	2601      	movs	r6, #1

	while (cmd_buffer[i] != 0 && cmd_buffer[i] != '\n' && cmd_buffer[i] != '\r') {
 8001ce6:	b2c2      	uxtb	r2, r0
 8001ce8:	5cbb      	ldrb	r3, [r7, r2]
 8001cea:	2b0d      	cmp	r3, #13
 8001cec:	d86d      	bhi.n	8001dca <shell_modbus_rs485+0x106>
 8001cee:	fa28 f303 	lsr.w	r3, r8, r3
 8001cf2:	f003 0301 	and.w	r3, r3, #1
 8001cf6:	f083 0401 	eor.w	r4, r3, #1
 8001cfa:	b943      	cbnz	r3, 8001d0e <shell_modbus_rs485+0x4a>
		if (cmd_buffer[i] == ' ') {
			cmd_buffer[i] = 0;
			flag_insert_str = 1;
		}
		else if (flag_insert_str) {
 8001cfc:	b12e      	cbz	r6, 8001d0a <shell_modbus_rs485+0x46>
			str_list[str_list_index++] = &cmd_buffer[i];
 8001cfe:	1c4b      	adds	r3, r1, #1
 8001d00:	4472      	add	r2, lr
 8001d02:	f849 2021 	str.w	r2, [r9, r1, lsl #2]
			flag_insert_str = 0;
 8001d06:	2600      	movs	r6, #0
		if (cmd_buffer[i] == ' ') {
			cmd_buffer[i] = 0;
			flag_insert_str = 1;
		}
		else if (flag_insert_str) {
			str_list[str_list_index++] = &cmd_buffer[i];
 8001d08:	b2d9      	uxtb	r1, r3
 8001d0a:	3001      	adds	r0, #1
 8001d0c:	e7eb      	b.n	8001ce6 <shell_modbus_rs485+0x22>
			flag_insert_str = 0;
		}
		i++;
	}

	cmd_buffer[i] = 0;
 8001d0e:	4b33      	ldr	r3, [pc, #204]	; (8001ddc <shell_modbus_rs485+0x118>)
	char*	cmd;
	int8_t	addr = 0;
	uint16_t	value = 0;
	uint8_t slaveid = 0;

	switch (num_str) {
 8001d10:	2905      	cmp	r1, #5
			flag_insert_str = 0;
		}
		i++;
	}

	cmd_buffer[i] = 0;
 8001d12:	549c      	strb	r4, [r3, r2]

	str_list_len = str_list_index;
 8001d14:	7029      	strb	r1, [r5, #0]
	char*	cmd;
	int8_t	addr = 0;
	uint16_t	value = 0;
	uint8_t slaveid = 0;

	switch (num_str) {
 8001d16:	d142      	bne.n	8001d9e <shell_modbus_rs485+0xda>

	case 5: {
		xprintf("MODBUS_DBG_WRITE_SINGLE_REGISTER_REQ\n");
 8001d18:	4832      	ldr	r0, [pc, #200]	; (8001de4 <shell_modbus_rs485+0x120>)
 8001d1a:	f7ff fe7f 	bl	8001a1c <xprintf>
	str_list_len = str_list_index;
	return str_list_len;
}

char* str_parser_get_attr(uint8_t index) {
	if (index < str_list_len) {
 8001d1e:	4b30      	ldr	r3, [pc, #192]	; (8001de0 <shell_modbus_rs485+0x11c>)
 8001d20:	781a      	ldrb	r2, [r3, #0]
 8001d22:	2a02      	cmp	r2, #2
 8001d24:	d905      	bls.n	8001d32 <shell_modbus_rs485+0x6e>
		return str_list[index];
 8001d26:	4b30      	ldr	r3, [pc, #192]	; (8001de8 <shell_modbus_rs485+0x124>)
	str_list_len = str_list_index;
	return str_list_len;
}

char* str_parser_get_attr(uint8_t index) {
	if (index < str_list_len) {
 8001d28:	2a03      	cmp	r2, #3
		return str_list[index];
 8001d2a:	689e      	ldr	r6, [r3, #8]
	str_list_len = str_list_index;
	return str_list_len;
}

char* str_parser_get_attr(uint8_t index) {
	if (index < str_list_len) {
 8001d2c:	d004      	beq.n	8001d38 <shell_modbus_rs485+0x74>
		return str_list[index];
 8001d2e:	68d8      	ldr	r0, [r3, #12]
 8001d30:	e003      	b.n	8001d3a <shell_modbus_rs485+0x76>
	}
	return NULL;
 8001d32:	4626      	mov	r6, r4
 8001d34:	4620      	mov	r0, r4
 8001d36:	e000      	b.n	8001d3a <shell_modbus_rs485+0x76>
 8001d38:	4620      	mov	r0, r4

	case 5: {
		xprintf("MODBUS_DBG_WRITE_SINGLE_REGISTER_REQ\n");

		cmd		= str_parser_get_attr(2);
		addr	= atoi(str_parser_get_attr(3)); // check addrs
 8001d3a:	f000 f869 	bl	8001e10 <atoi>
 8001d3e:	4604      	mov	r4, r0
	str_list_len = str_list_index;
	return str_list_len;
}

char* str_parser_get_attr(uint8_t index) {
	if (index < str_list_len) {
 8001d40:	782b      	ldrb	r3, [r5, #0]

		cmd		= str_parser_get_attr(2);
		addr	= atoi(str_parser_get_attr(3)); // check addrs
		slaveid = atoi(str_parser_get_attr(1));

		if ((addr < 0) || (addr > 12)) {
 8001d42:	b2e4      	uxtb	r4, r4
	str_list_len = str_list_index;
	return str_list_len;
}

char* str_parser_get_attr(uint8_t index) {
	if (index < str_list_len) {
 8001d44:	2b01      	cmp	r3, #1
		return str_list[index];
 8001d46:	bf8a      	itet	hi
 8001d48:	4b27      	ldrhi	r3, [pc, #156]	; (8001de8 <shell_modbus_rs485+0x124>)
	}
	return NULL;
 8001d4a:	2000      	movls	r0, #0
	return str_list_len;
}

char* str_parser_get_attr(uint8_t index) {
	if (index < str_list_len) {
		return str_list[index];
 8001d4c:	6858      	ldrhi	r0, [r3, #4]
	case 5: {
		xprintf("MODBUS_DBG_WRITE_SINGLE_REGISTER_REQ\n");

		cmd		= str_parser_get_attr(2);
		addr	= atoi(str_parser_get_attr(3)); // check addrs
		slaveid = atoi(str_parser_get_attr(1));
 8001d4e:	f000 f85f 	bl	8001e10 <atoi>

		if ((addr < 0) || (addr > 12)) {
 8001d52:	2c0c      	cmp	r4, #12
 8001d54:	d823      	bhi.n	8001d9e <shell_modbus_rs485+0xda>
			goto exception;
		}

		if (strcmp((const char *)cmd, (const char *)"w") == 0) {
 8001d56:	4925      	ldr	r1, [pc, #148]	; (8001dec <shell_modbus_rs485+0x128>)
 8001d58:	4630      	mov	r0, r6
 8001d5a:	f7fe ff97 	bl	8000c8c <strcmp>
 8001d5e:	b950      	cbnz	r0, 8001d76 <shell_modbus_rs485+0xb2>
	str_list_len = str_list_index;
	return str_list_len;
}

char* str_parser_get_attr(uint8_t index) {
	if (index < str_list_len) {
 8001d60:	782b      	ldrb	r3, [r5, #0]
 8001d62:	2b04      	cmp	r3, #4
		return str_list[index];
 8001d64:	bf84      	itt	hi
 8001d66:	4b20      	ldrhi	r3, [pc, #128]	; (8001de8 <shell_modbus_rs485+0x124>)
 8001d68:	6918      	ldrhi	r0, [r3, #16]
		if ((addr < 0) || (addr > 12)) {
			goto exception;
		}

		if (strcmp((const char *)cmd, (const char *)"w") == 0) {
			value	= atoi(str_parser_get_attr(4));
 8001d6a:	f000 f851 	bl	8001e10 <atoi>

			if ((value < 0) || (value > 1) ) {
 8001d6e:	b280      	uxth	r0, r0
 8001d70:	2801      	cmp	r0, #1
 8001d72:	d814      	bhi.n	8001d9e <shell_modbus_rs485+0xda>
 8001d74:	e02f      	b.n	8001dd6 <shell_modbus_rs485+0x112>

			{
				;
			}
		}
		else if (strcmp((const char *)cmd, (const char *)"t") == 0) {
 8001d76:	491e      	ldr	r1, [pc, #120]	; (8001df0 <shell_modbus_rs485+0x12c>)
 8001d78:	4630      	mov	r0, r6
 8001d7a:	f7fe ff87 	bl	8000c8c <strcmp>
 8001d7e:	4604      	mov	r4, r0
 8001d80:	b968      	cbnz	r0, 8001d9e <shell_modbus_rs485+0xda>
			xprintf("modbus reset single coil\n");
 8001d82:	481c      	ldr	r0, [pc, #112]	; (8001df4 <shell_modbus_rs485+0x130>)
 8001d84:	f7ff fe4a 	bl	8001a1c <xprintf>
	str_list_len = str_list_index;
	return str_list_len;
}

char* str_parser_get_attr(uint8_t index) {
	if (index < str_list_len) {
 8001d88:	782b      	ldrb	r3, [r5, #0]
 8001d8a:	2b04      	cmp	r3, #4
		return str_list[index];
 8001d8c:	bf8a      	itet	hi
 8001d8e:	4b16      	ldrhi	r3, [pc, #88]	; (8001de8 <shell_modbus_rs485+0x124>)
	}
	return NULL;
 8001d90:	4620      	movls	r0, r4
	return str_list_len;
}

char* str_parser_get_attr(uint8_t index) {
	if (index < str_list_len) {
		return str_list[index];
 8001d92:	6918      	ldrhi	r0, [r3, #16]
				;
			}
		}
		else if (strcmp((const char *)cmd, (const char *)"t") == 0) {
			xprintf("modbus reset single coil\n");
			value	= atoi(str_parser_get_attr(4));
 8001d94:	f000 f83c 	bl	8001e10 <atoi>
			uint16_t reg_data;

			if(value < 50 || value > 100000) {
 8001d98:	b280      	uxth	r0, r0
 8001d9a:	2831      	cmp	r0, #49	; 0x31
 8001d9c:	d81b      	bhi.n	8001dd6 <shell_modbus_rs485+0x112>
			goto exception;
	}
		break;
exception:
	default:
		xprintf("\n");
 8001d9e:	4816      	ldr	r0, [pc, #88]	; (8001df8 <shell_modbus_rs485+0x134>)
 8001da0:	f7ff fe3c 	bl	8001a1c <xprintf>
		xprintf("mbs i to get slave list info\n");
 8001da4:	4815      	ldr	r0, [pc, #84]	; (8001dfc <shell_modbus_rs485+0x138>)
 8001da6:	f7ff fe39 	bl	8001a1c <xprintf>
		xprintf("mbs r to read all status coil\n");
 8001daa:	4815      	ldr	r0, [pc, #84]	; (8001e00 <shell_modbus_rs485+0x13c>)
 8001dac:	f7ff fe36 	bl	8001a1c <xprintf>
		xprintf("mbs <slave addr>  w  < reg >  < value >  1:on 0:off\n");
 8001db0:	4814      	ldr	r0, [pc, #80]	; (8001e04 <shell_modbus_rs485+0x140>)
 8001db2:	f7ff fe33 	bl	8001a1c <xprintf>
		xprintf("mbs <slave addr>  t  < reg >  < (50ms < (time_toggle)  < 500000ms) > \n");
 8001db6:	4814      	ldr	r0, [pc, #80]	; (8001e08 <shell_modbus_rs485+0x144>)
 8001db8:	f7ff fe30 	bl	8001a1c <xprintf>
		xprintf("mbs <slave addr>  s  restart modbus slave\n");
 8001dbc:	4813      	ldr	r0, [pc, #76]	; (8001e0c <shell_modbus_rs485+0x148>)
 8001dbe:	f7ff fe2d 	bl	8001a1c <xprintf>
		xprintf("\n");
 8001dc2:	480d      	ldr	r0, [pc, #52]	; (8001df8 <shell_modbus_rs485+0x134>)
 8001dc4:	f7ff fe2a 	bl	8001a1c <xprintf>
		break;
	}
	return 0;
 8001dc8:	e005      	b.n	8001dd6 <shell_modbus_rs485+0x112>
	uint8_t i = 0;
	uint8_t str_list_index = 0;
	uint8_t flag_insert_str = 1;

	while (cmd_buffer[i] != 0 && cmd_buffer[i] != '\n' && cmd_buffer[i] != '\r') {
		if (cmd_buffer[i] == ' ') {
 8001dca:	2b20      	cmp	r3, #32
 8001dcc:	d196      	bne.n	8001cfc <shell_modbus_rs485+0x38>
			cmd_buffer[i] = 0;
 8001dce:	f807 c002 	strb.w	ip, [r7, r2]
			flag_insert_str = 1;
 8001dd2:	2601      	movs	r6, #1
 8001dd4:	e799      	b.n	8001d0a <shell_modbus_rs485+0x46>
		xprintf("mbs <slave addr>  s  restart modbus slave\n");
		xprintf("\n");
		break;
	}
	return 0;
}
 8001dd6:	2000      	movs	r0, #0
 8001dd8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8001ddc:	20000fad 	.word	0x20000fad
 8001de0:	20000fac 	.word	0x20000fac
 8001de4:	0800220c 	.word	0x0800220c
 8001de8:	20000f84 	.word	0x20000f84
 8001dec:	08002232 	.word	0x08002232
 8001df0:	08002336 	.word	0x08002336
 8001df4:	08002234 	.word	0x08002234
 8001df8:	08002305 	.word	0x08002305
 8001dfc:	0800224e 	.word	0x0800224e
 8001e00:	0800226c 	.word	0x0800226c
 8001e04:	0800228b 	.word	0x0800228b
 8001e08:	080022c0 	.word	0x080022c0
 8001e0c:	08002307 	.word	0x08002307

08001e10 <atoi>:
 8001e10:	220a      	movs	r2, #10
 8001e12:	2100      	movs	r1, #0
 8001e14:	f000 b8fa 	b.w	800200c <strtol>

08001e18 <strcpy>:
 8001e18:	ea80 0201 	eor.w	r2, r0, r1
 8001e1c:	4684      	mov	ip, r0
 8001e1e:	f012 0f03 	tst.w	r2, #3
 8001e22:	d14f      	bne.n	8001ec4 <strcpy+0xac>
 8001e24:	f011 0f03 	tst.w	r1, #3
 8001e28:	d132      	bne.n	8001e90 <strcpy+0x78>
 8001e2a:	f84d 4d04 	str.w	r4, [sp, #-4]!
 8001e2e:	f011 0f04 	tst.w	r1, #4
 8001e32:	f851 3b04 	ldr.w	r3, [r1], #4
 8001e36:	d00b      	beq.n	8001e50 <strcpy+0x38>
 8001e38:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8001e3c:	439a      	bics	r2, r3
 8001e3e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8001e42:	bf04      	itt	eq
 8001e44:	f84c 3b04 	streq.w	r3, [ip], #4
 8001e48:	f851 3b04 	ldreq.w	r3, [r1], #4
 8001e4c:	d116      	bne.n	8001e7c <strcpy+0x64>
 8001e4e:	bf00      	nop
 8001e50:	f851 4b04 	ldr.w	r4, [r1], #4
 8001e54:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8001e58:	439a      	bics	r2, r3
 8001e5a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8001e5e:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 8001e62:	d10b      	bne.n	8001e7c <strcpy+0x64>
 8001e64:	f84c 3b04 	str.w	r3, [ip], #4
 8001e68:	43a2      	bics	r2, r4
 8001e6a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8001e6e:	bf04      	itt	eq
 8001e70:	f851 3b04 	ldreq.w	r3, [r1], #4
 8001e74:	f84c 4b04 	streq.w	r4, [ip], #4
 8001e78:	d0ea      	beq.n	8001e50 <strcpy+0x38>
 8001e7a:	4623      	mov	r3, r4
 8001e7c:	f80c 3b01 	strb.w	r3, [ip], #1
 8001e80:	f013 0fff 	tst.w	r3, #255	; 0xff
 8001e84:	ea4f 2333 	mov.w	r3, r3, ror #8
 8001e88:	d1f8      	bne.n	8001e7c <strcpy+0x64>
 8001e8a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001e8e:	4770      	bx	lr
 8001e90:	f011 0f01 	tst.w	r1, #1
 8001e94:	d006      	beq.n	8001ea4 <strcpy+0x8c>
 8001e96:	f811 2b01 	ldrb.w	r2, [r1], #1
 8001e9a:	f80c 2b01 	strb.w	r2, [ip], #1
 8001e9e:	2a00      	cmp	r2, #0
 8001ea0:	bf08      	it	eq
 8001ea2:	4770      	bxeq	lr
 8001ea4:	f011 0f02 	tst.w	r1, #2
 8001ea8:	d0bf      	beq.n	8001e2a <strcpy+0x12>
 8001eaa:	f831 2b02 	ldrh.w	r2, [r1], #2
 8001eae:	f012 0fff 	tst.w	r2, #255	; 0xff
 8001eb2:	bf16      	itet	ne
 8001eb4:	f82c 2b02 	strhne.w	r2, [ip], #2
 8001eb8:	f88c 2000 	strbeq.w	r2, [ip]
 8001ebc:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
 8001ec0:	d1b3      	bne.n	8001e2a <strcpy+0x12>
 8001ec2:	4770      	bx	lr
 8001ec4:	f811 2b01 	ldrb.w	r2, [r1], #1
 8001ec8:	f80c 2b01 	strb.w	r2, [ip], #1
 8001ecc:	2a00      	cmp	r2, #0
 8001ece:	d1f9      	bne.n	8001ec4 <strcpy+0xac>
 8001ed0:	4770      	bx	lr
 8001ed2:	bf00      	nop

08001ed4 <_strtol_l.isra.0>:
 8001ed4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001ed8:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
 8001edc:	460f      	mov	r7, r1
 8001ede:	4680      	mov	r8, r0
 8001ee0:	4616      	mov	r6, r2
 8001ee2:	461d      	mov	r5, r3
 8001ee4:	468b      	mov	fp, r1
 8001ee6:	e000      	b.n	8001eea <_strtol_l.isra.0+0x16>
 8001ee8:	46a3      	mov	fp, r4
 8001eea:	465c      	mov	r4, fp
 8001eec:	4648      	mov	r0, r9
 8001eee:	f814 ab01 	ldrb.w	sl, [r4], #1
 8001ef2:	f000 f8c5 	bl	8002080 <__locale_ctype_ptr_l>
 8001ef6:	4450      	add	r0, sl
 8001ef8:	7841      	ldrb	r1, [r0, #1]
 8001efa:	f001 0108 	and.w	r1, r1, #8
 8001efe:	f001 0cff 	and.w	ip, r1, #255	; 0xff
 8001f02:	2900      	cmp	r1, #0
 8001f04:	d1f0      	bne.n	8001ee8 <_strtol_l.isra.0+0x14>
 8001f06:	4652      	mov	r2, sl
 8001f08:	2a2d      	cmp	r2, #45	; 0x2d
 8001f0a:	d061      	beq.n	8001fd0 <_strtol_l.isra.0+0xfc>
 8001f0c:	2a2b      	cmp	r2, #43	; 0x2b
 8001f0e:	bf04      	itt	eq
 8001f10:	f89b 2001 	ldrbeq.w	r2, [fp, #1]
 8001f14:	f10b 0402 	addeq.w	r4, fp, #2
 8001f18:	2d00      	cmp	r5, #0
 8001f1a:	d043      	beq.n	8001fa4 <_strtol_l.isra.0+0xd0>
 8001f1c:	2d10      	cmp	r5, #16
 8001f1e:	d065      	beq.n	8001fec <_strtol_l.isra.0+0x118>
 8001f20:	46a9      	mov	r9, r5
 8001f22:	f1bc 0f00 	cmp.w	ip, #0
 8001f26:	bf0c      	ite	eq
 8001f28:	f06f 4a00 	mvneq.w	sl, #2147483648	; 0x80000000
 8001f2c:	f04f 4a00 	movne.w	sl, #2147483648	; 0x80000000
 8001f30:	fbba fef9 	udiv	lr, sl, r9
 8001f34:	2100      	movs	r1, #0
 8001f36:	4608      	mov	r0, r1
 8001f38:	fb09 aa1e 	mls	sl, r9, lr, sl
 8001f3c:	e005      	b.n	8001f4a <_strtol_l.isra.0+0x76>
 8001f3e:	d029      	beq.n	8001f94 <_strtol_l.isra.0+0xc0>
 8001f40:	fb09 3000 	mla	r0, r9, r0, r3
 8001f44:	2101      	movs	r1, #1
 8001f46:	f814 2b01 	ldrb.w	r2, [r4], #1
 8001f4a:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8001f4e:	2b09      	cmp	r3, #9
 8001f50:	d905      	bls.n	8001f5e <_strtol_l.isra.0+0x8a>
 8001f52:	f1a2 0341 	sub.w	r3, r2, #65	; 0x41
 8001f56:	2b19      	cmp	r3, #25
 8001f58:	d80a      	bhi.n	8001f70 <_strtol_l.isra.0+0x9c>
 8001f5a:	f1a2 0337 	sub.w	r3, r2, #55	; 0x37
 8001f5e:	429d      	cmp	r5, r3
 8001f60:	dd0e      	ble.n	8001f80 <_strtol_l.isra.0+0xac>
 8001f62:	1c4a      	adds	r2, r1, #1
 8001f64:	d0ef      	beq.n	8001f46 <_strtol_l.isra.0+0x72>
 8001f66:	4586      	cmp	lr, r0
 8001f68:	d2e9      	bcs.n	8001f3e <_strtol_l.isra.0+0x6a>
 8001f6a:	f04f 31ff 	mov.w	r1, #4294967295
 8001f6e:	e7ea      	b.n	8001f46 <_strtol_l.isra.0+0x72>
 8001f70:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 8001f74:	2b19      	cmp	r3, #25
 8001f76:	d803      	bhi.n	8001f80 <_strtol_l.isra.0+0xac>
 8001f78:	f1a2 0357 	sub.w	r3, r2, #87	; 0x57
 8001f7c:	429d      	cmp	r5, r3
 8001f7e:	dcf0      	bgt.n	8001f62 <_strtol_l.isra.0+0x8e>
 8001f80:	1c4b      	adds	r3, r1, #1
 8001f82:	d015      	beq.n	8001fb0 <_strtol_l.isra.0+0xdc>
 8001f84:	f1bc 0f00 	cmp.w	ip, #0
 8001f88:	d110      	bne.n	8001fac <_strtol_l.isra.0+0xd8>
 8001f8a:	b14e      	cbz	r6, 8001fa0 <_strtol_l.isra.0+0xcc>
 8001f8c:	b9e1      	cbnz	r1, 8001fc8 <_strtol_l.isra.0+0xf4>
 8001f8e:	6037      	str	r7, [r6, #0]
 8001f90:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001f94:	459a      	cmp	sl, r3
 8001f96:	dad3      	bge.n	8001f40 <_strtol_l.isra.0+0x6c>
 8001f98:	4670      	mov	r0, lr
 8001f9a:	f04f 31ff 	mov.w	r1, #4294967295
 8001f9e:	e7d2      	b.n	8001f46 <_strtol_l.isra.0+0x72>
 8001fa0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001fa4:	2a30      	cmp	r2, #48	; 0x30
 8001fa6:	d01a      	beq.n	8001fde <_strtol_l.isra.0+0x10a>
 8001fa8:	250a      	movs	r5, #10
 8001faa:	e7b9      	b.n	8001f20 <_strtol_l.isra.0+0x4c>
 8001fac:	4240      	negs	r0, r0
 8001fae:	e7ec      	b.n	8001f8a <_strtol_l.isra.0+0xb6>
 8001fb0:	f1bc 0f00 	cmp.w	ip, #0
 8001fb4:	f04f 0322 	mov.w	r3, #34	; 0x22
 8001fb8:	bf0c      	ite	eq
 8001fba:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8001fbe:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 8001fc2:	f8c8 3000 	str.w	r3, [r8]
 8001fc6:	b1f6      	cbz	r6, 8002006 <_strtol_l.isra.0+0x132>
 8001fc8:	1e67      	subs	r7, r4, #1
 8001fca:	6037      	str	r7, [r6, #0]
 8001fcc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001fd0:	f10b 0402 	add.w	r4, fp, #2
 8001fd4:	f89b 2001 	ldrb.w	r2, [fp, #1]
 8001fd8:	f04f 0c01 	mov.w	ip, #1
 8001fdc:	e79c      	b.n	8001f18 <_strtol_l.isra.0+0x44>
 8001fde:	7823      	ldrb	r3, [r4, #0]
 8001fe0:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8001fe4:	2b58      	cmp	r3, #88	; 0x58
 8001fe6:	d008      	beq.n	8001ffa <_strtol_l.isra.0+0x126>
 8001fe8:	2508      	movs	r5, #8
 8001fea:	e799      	b.n	8001f20 <_strtol_l.isra.0+0x4c>
 8001fec:	2a30      	cmp	r2, #48	; 0x30
 8001fee:	d197      	bne.n	8001f20 <_strtol_l.isra.0+0x4c>
 8001ff0:	7823      	ldrb	r3, [r4, #0]
 8001ff2:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8001ff6:	2b58      	cmp	r3, #88	; 0x58
 8001ff8:	d192      	bne.n	8001f20 <_strtol_l.isra.0+0x4c>
 8001ffa:	f04f 0910 	mov.w	r9, #16
 8001ffe:	7862      	ldrb	r2, [r4, #1]
 8002000:	464d      	mov	r5, r9
 8002002:	3402      	adds	r4, #2
 8002004:	e78d      	b.n	8001f22 <_strtol_l.isra.0+0x4e>
 8002006:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800200a:	bf00      	nop

0800200c <strtol>:
 800200c:	4b08      	ldr	r3, [pc, #32]	; (8002030 <strtol+0x24>)
 800200e:	b570      	push	{r4, r5, r6, lr}
 8002010:	681d      	ldr	r5, [r3, #0]
 8002012:	4e08      	ldr	r6, [pc, #32]	; (8002034 <strtol+0x28>)
 8002014:	6b6c      	ldr	r4, [r5, #52]	; 0x34
 8002016:	b082      	sub	sp, #8
 8002018:	2c00      	cmp	r4, #0
 800201a:	bf08      	it	eq
 800201c:	4634      	moveq	r4, r6
 800201e:	4613      	mov	r3, r2
 8002020:	9400      	str	r4, [sp, #0]
 8002022:	460a      	mov	r2, r1
 8002024:	4601      	mov	r1, r0
 8002026:	4628      	mov	r0, r5
 8002028:	f7ff ff54 	bl	8001ed4 <_strtol_l.isra.0>
 800202c:	b002      	add	sp, #8
 800202e:	bd70      	pop	{r4, r5, r6, pc}
 8002030:	20000500 	.word	0x20000500
 8002034:	20000504 	.word	0x20000504

08002038 <register_fini>:
 8002038:	4b02      	ldr	r3, [pc, #8]	; (8002044 <register_fini+0xc>)
 800203a:	b113      	cbz	r3, 8002042 <register_fini+0xa>
 800203c:	4802      	ldr	r0, [pc, #8]	; (8002048 <register_fini+0x10>)
 800203e:	f000 b805 	b.w	800204c <atexit>
 8002042:	4770      	bx	lr
 8002044:	00000000 	.word	0x00000000
 8002048:	08002059 	.word	0x08002059

0800204c <atexit>:
 800204c:	2300      	movs	r3, #0
 800204e:	4601      	mov	r1, r0
 8002050:	461a      	mov	r2, r3
 8002052:	4618      	mov	r0, r3
 8002054:	f000 b83c 	b.w	80020d0 <__register_exitproc>

08002058 <__libc_fini_array>:
 8002058:	b538      	push	{r3, r4, r5, lr}
 800205a:	4d07      	ldr	r5, [pc, #28]	; (8002078 <__libc_fini_array+0x20>)
 800205c:	4c07      	ldr	r4, [pc, #28]	; (800207c <__libc_fini_array+0x24>)
 800205e:	1b2c      	subs	r4, r5, r4
 8002060:	10a4      	asrs	r4, r4, #2
 8002062:	d005      	beq.n	8002070 <__libc_fini_array+0x18>
 8002064:	3c01      	subs	r4, #1
 8002066:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 800206a:	4798      	blx	r3
 800206c:	2c00      	cmp	r4, #0
 800206e:	d1f9      	bne.n	8002064 <__libc_fini_array+0xc>
 8002070:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8002074:	f000 b884 	b.w	8002180 <_fini>
 8002078:	08002580 	.word	0x08002580
 800207c:	0800257c 	.word	0x0800257c

08002080 <__locale_ctype_ptr_l>:
 8002080:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 8002084:	4770      	bx	lr
 8002086:	bf00      	nop

08002088 <__ascii_mbtowc>:
 8002088:	b082      	sub	sp, #8
 800208a:	b149      	cbz	r1, 80020a0 <__ascii_mbtowc+0x18>
 800208c:	b15a      	cbz	r2, 80020a6 <__ascii_mbtowc+0x1e>
 800208e:	b16b      	cbz	r3, 80020ac <__ascii_mbtowc+0x24>
 8002090:	7813      	ldrb	r3, [r2, #0]
 8002092:	600b      	str	r3, [r1, #0]
 8002094:	7812      	ldrb	r2, [r2, #0]
 8002096:	1c10      	adds	r0, r2, #0
 8002098:	bf18      	it	ne
 800209a:	2001      	movne	r0, #1
 800209c:	b002      	add	sp, #8
 800209e:	4770      	bx	lr
 80020a0:	a901      	add	r1, sp, #4
 80020a2:	2a00      	cmp	r2, #0
 80020a4:	d1f3      	bne.n	800208e <__ascii_mbtowc+0x6>
 80020a6:	4610      	mov	r0, r2
 80020a8:	b002      	add	sp, #8
 80020aa:	4770      	bx	lr
 80020ac:	f06f 0001 	mvn.w	r0, #1
 80020b0:	e7f4      	b.n	800209c <__ascii_mbtowc+0x14>
 80020b2:	bf00      	nop

080020b4 <__ascii_wctomb>:
 80020b4:	b121      	cbz	r1, 80020c0 <__ascii_wctomb+0xc>
 80020b6:	2aff      	cmp	r2, #255	; 0xff
 80020b8:	d804      	bhi.n	80020c4 <__ascii_wctomb+0x10>
 80020ba:	700a      	strb	r2, [r1, #0]
 80020bc:	2001      	movs	r0, #1
 80020be:	4770      	bx	lr
 80020c0:	4608      	mov	r0, r1
 80020c2:	4770      	bx	lr
 80020c4:	238a      	movs	r3, #138	; 0x8a
 80020c6:	6003      	str	r3, [r0, #0]
 80020c8:	f04f 30ff 	mov.w	r0, #4294967295
 80020cc:	4770      	bx	lr
 80020ce:	bf00      	nop

080020d0 <__register_exitproc>:
 80020d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80020d4:	4c25      	ldr	r4, [pc, #148]	; (800216c <__register_exitproc+0x9c>)
 80020d6:	4606      	mov	r6, r0
 80020d8:	6825      	ldr	r5, [r4, #0]
 80020da:	4688      	mov	r8, r1
 80020dc:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
 80020e0:	4692      	mov	sl, r2
 80020e2:	4699      	mov	r9, r3
 80020e4:	b3c4      	cbz	r4, 8002158 <__register_exitproc+0x88>
 80020e6:	6860      	ldr	r0, [r4, #4]
 80020e8:	281f      	cmp	r0, #31
 80020ea:	dc17      	bgt.n	800211c <__register_exitproc+0x4c>
 80020ec:	1c41      	adds	r1, r0, #1
 80020ee:	b176      	cbz	r6, 800210e <__register_exitproc+0x3e>
 80020f0:	eb04 0380 	add.w	r3, r4, r0, lsl #2
 80020f4:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
 80020f8:	f8d4 5188 	ldr.w	r5, [r4, #392]	; 0x188
 80020fc:	2201      	movs	r2, #1
 80020fe:	4082      	lsls	r2, r0
 8002100:	4315      	orrs	r5, r2
 8002102:	2e02      	cmp	r6, #2
 8002104:	f8c4 5188 	str.w	r5, [r4, #392]	; 0x188
 8002108:	f8c3 9108 	str.w	r9, [r3, #264]	; 0x108
 800210c:	d01e      	beq.n	800214c <__register_exitproc+0x7c>
 800210e:	1c83      	adds	r3, r0, #2
 8002110:	6061      	str	r1, [r4, #4]
 8002112:	2000      	movs	r0, #0
 8002114:	f844 8023 	str.w	r8, [r4, r3, lsl #2]
 8002118:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800211c:	4b14      	ldr	r3, [pc, #80]	; (8002170 <__register_exitproc+0xa0>)
 800211e:	b303      	cbz	r3, 8002162 <__register_exitproc+0x92>
 8002120:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8002124:	f3af 8000 	nop.w
 8002128:	4604      	mov	r4, r0
 800212a:	b1d0      	cbz	r0, 8002162 <__register_exitproc+0x92>
 800212c:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
 8002130:	2700      	movs	r7, #0
 8002132:	e884 0088 	stmia.w	r4, {r3, r7}
 8002136:	4638      	mov	r0, r7
 8002138:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 800213c:	2101      	movs	r1, #1
 800213e:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
 8002142:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
 8002146:	2e00      	cmp	r6, #0
 8002148:	d0e1      	beq.n	800210e <__register_exitproc+0x3e>
 800214a:	e7d1      	b.n	80020f0 <__register_exitproc+0x20>
 800214c:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
 8002150:	431a      	orrs	r2, r3
 8002152:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
 8002156:	e7da      	b.n	800210e <__register_exitproc+0x3e>
 8002158:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
 800215c:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8002160:	e7c1      	b.n	80020e6 <__register_exitproc+0x16>
 8002162:	f04f 30ff 	mov.w	r0, #4294967295
 8002166:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800216a:	bf00      	nop
 800216c:	08002458 	.word	0x08002458
 8002170:	00000000 	.word	0x00000000

08002174 <_init>:
 8002174:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002176:	bf00      	nop
 8002178:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800217a:	bc08      	pop	{r3}
 800217c:	469e      	mov	lr, r3
 800217e:	4770      	bx	lr

08002180 <_fini>:
 8002180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002182:	bf00      	nop
 8002184:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002186:	bc08      	pop	{r3}
 8002188:	469e      	mov	lr, r3
 800218a:	4770      	bx	lr
