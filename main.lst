
main.elf:     file format elf32-littlearm

SYMBOL TABLE:
08000000 l    d  .isr_vector	00000000 .isr_vector
0800010c l    d  .text	00000000 .text
080012a8 l    d  .rodata	00000000 .rodata
080012bc l    d  .init_array	00000000 .init_array
080012c4 l    d  .fini_array	00000000 .fini_array
20000000 l    d  .data	00000000 .data
20000448 l    d  .bss	00000000 .bss
20001558 l    d  ._user_heap_stack	00000000 ._user_heap_stack
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 /tmp/ccu5132f.o
f108f85f l       *ABS*	00000000 BootRAM
0800095c l       .text	00000000 LoopCopyDataInit
08000954 l       .text	00000000 CopyDataInit
08000970 l       .text	00000000 LoopFillZerobss
0800096a l       .text	00000000 FillZerobss
08000994 l       .text	00000000 Infinite_Loop
00000000 l    df *ABS*	00000000 crtstuff.c
08001290 l     O .text	00000000 __EH_FRAME_BEGIN__
0800010c l     F .text	00000000 __do_global_dtors_aux
20000448 l       .bss	00000000 completed.8603
080012c4 l     O .fini_array	00000000 __do_global_dtors_aux_fini_array_entry
08000130 l     F .text	00000000 frame_dummy
2000044c l       .bss	00000000 object.8608
080012c0 l     O .init_array	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 stm32f10x_gpio.c
00000000 l    df *ABS*	00000000 stm32f10x_rcc.c
20000000 l     O .data	00000010 APBAHBPrescTable
20000010 l     O .data	00000004 ADCPrescTable
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 stm32f10x_it.c
00000000 l    df *ABS*	00000000 system_stm32f10x.c
00000000 l    df *ABS*	00000000 stm32f1xx_nucleo.c
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 tasks.c
08000a1c l     F .text	00000014 prvIdleTask
08000a30 l     F .text	00000024 prvResetNextTaskUnblockTime
08000a54 l     F .text	00000050 prvAddCurrentTaskToDelayedList
20000464 l     O .bss	00000004 xNumOfOverflows
20000468 l     O .bss	00000004 pxDelayedTaskList
2000046c l     O .bss	00000004 xSchedulerRunning
20000470 l     O .bss	00000014 xDelayedTaskList1
20000484 l     O .bss	00000014 xDelayedTaskList2
20000498 l     O .bss	00000004 uxPendedTicks
2000049c l     O .bss	00000064 pxReadyTasksLists
20000500 l     O .bss	00000004 uxSchedulerSuspended
20000508 l     O .bss	00000014 xPendingReadyList
2000051c l     O .bss	00000004 xTickCount
20000520 l     O .bss	00000004 pxOverflowDelayedTaskList
20000524 l     O .bss	00000004 uxTaskNumber
20000528 l     O .bss	00000004 uxCurrentNumberOfTasks
20000018 l     O .data	00000004 xNextTaskUnblockTime
2000052c l     O .bss	00000014 xSuspendedTaskList
20000540 l     O .bss	00000004 uxTopReadyPriority
20000544 l     O .bss	00000004 xYieldPending
00000000 l    df *ABS*	00000000 port.c
08000f40 l     F .text	00000018 prvPortStartFirstTask
08000fc4 l     F .text	0000001c prvTaskExitError
08000f98 l       .text	00000000 pxCurrentTCBConst2
08001068 l       .text	00000000 pxCurrentTCBConst
20000548 l     O .bss	00000001 ucMaxSysCallPriority
2000054c l     O .bss	00000004 ulMaxPRIGROUPValue
2000001c l     O .data	00000004 uxCriticalNesting
00000000 l    df *ABS*	00000000 heap_1.c
20000550 l     O .bss	00000004 xNextFreeByte
20000554 l     O .bss	00000004 pucAlignedHeap.4761
20000558 l     O .bss	00001000 ucHeap
00000000 l    df *ABS*	00000000 __call_atexit.c
080011a4 l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 /home/fanning/workspace/tools/gcc-arm-none-eabi-5_4-2016q3/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7-m/crti.o
00000000 l    df *ABS*	00000000 /home/fanning/workspace/tools/gcc-arm-none-eabi-5_4-2016q3/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7-m/crtn.o
00000000 l    df *ABS*	00000000 impure.c
20000020 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 
080012c8 l       .fini_array	00000000 __fini_array_end
20000448 l       .bss	00000000 __bss_start__
20001558 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
080012c4 l       .fini_array	00000000 __fini_array_start
080012c4 l       .init_array	00000000 __init_array_end
00000000 l       *UND*	00000000 hardware_init_hook
080012bc l       .init_array	00000000 __preinit_array_end
00000000 l       *UND*	00000000 __stack
080012bc l       .init_array	00000000 __init_array_start
00000000 l       *UND*	00000000 _exit
080012bc l       .init_array	00000000 __preinit_array_start
00000000 l       *UND*	00000000 free
08000994  w    F .text	00000002 EXTI2_IRQHandler
08000500 g     F .text	0000000c RCC_HSICmd
08000520 g     F .text	0000000c RCC_PLLCmd
08000374 g     F .text	0000001c GPIO_EventOutputConfig
08000994  w    F .text	00000002 DebugMon_Handler
080007b0 g     F .text	0000000c RCC_ClearITPendingBit
08001004 g     F .text	00000024 vPortExitCritical
08000338 g     F .text	0000000c GPIO_ReadOutputDataBit
08000994  w    F .text	00000002 TIM1_CC_IRQHandler
08000810 g     F .text	00000002 HardFault_Handler
08000fb4 g     F .text	00000010 ulPortSetInterruptMask
00000080 g       *ABS*	00000000 _Min_Stack_Size
0800106c g     F .text	00000024 SysTick_Handler
0800074c g     F .text	0000000c RCC_MCOConfig
08000994  w    F .text	00000002 PVD_IRQHandler
080012c8 g       *ABS*	00000000 _sidata
08001028 g     F .text	00000044 PendSV_Handler
0800080e g     F .text	00000002 NMI_Handler
080012bc g       .init_array	00000000 __exidx_end
08000994  w    F .text	00000002 EXTI3_IRQHandler
0800058c g     F .text	0000001c RCC_ITConfig
20000504 g     O .bss	00000004 pxCurrentTCB
080012a8 g       .text	00000000 _etext
20000448 g       .bss	00000000 _sbss
0800052c g     F .text	00000014 RCC_SYSCLKConfig
080004b8 g     F .text	00000034 RCC_WaitForHSEStartUp
08000390 g     F .text	0000000c GPIO_EventOutputCmd
08000734 g     F .text	0000000c RCC_BackupResetCmd
080010b8 g     F .text	00000090 xPortStartScheduler
08000aa4 g     F .text	00000194 xTaskGenericCreate
0800039c g     F .text	0000006c GPIO_PinRemapConfig
08001090  w    F .text	00000028 vPortSetupTimerInterrupt
08000740 g     F .text	0000000c RCC_ClockSecuritySystemCmd
08000994  w    F .text	00000002 EXTI0_IRQHandler
08000994  w    F .text	00000002 I2C2_EV_IRQHandler
0800078c g     F .text	00000010 RCC_ClearFlag
08001198 g     F .text	0000000c vPortFree
20000014 g     O .data	00000004 SystemCoreClock
08000480 g     F .text	00000038 RCC_HSEConfig
00000000  w      *UND*	00000000 malloc
080007bc g     F .text	00000018 blinkyTask
08000994  w    F .text	00000002 UsageFault_Handler
080006c4 g     F .text	0000001c RCC_APB2PeriphClockCmd
080009b2 g     F .text	00000018 vListInsertEnd
08000994  w    F .text	00000002 ADC1_2_IRQHandler
0800025c g     F .text	000000b8 GPIO_Init
0800050c g     F .text	00000014 RCC_PLLConfig
080005b4 g     F .text	00000014 RCC_ADCCLKConfig
20000000 g       .data	00000000 _sdata
08000994  w    F .text	00000002 SPI1_IRQHandler
08000244 g     F .text	00000016 GPIO_AFIODeInit
08000994  w    F .text	00000002 TAMPER_IRQHandler
08000360 g     F .text	00000004 GPIO_Write
08000344 g     F .text	00000006 GPIO_ReadOutputData
080009ac g     F .text	00000006 vListInitialiseItem
080005c8 g     F .text	00000020 RCC_LSEConfig
08000604 g     F .text	0000000c RCC_RTCCLKCmd
08000ffc g     F .text	00000006 vPortClearInterruptMask
080006e0 g     F .text	0000001c RCC_APB1PeriphClockCmd
0800079c g     F .text	00000014 RCC_GetITStatus
080012bc g       .init_array	00000000 __exidx_start
080012b8 g     O .rodata	00000004 _global_impure_ptr
080006a8 g     F .text	0000001c RCC_AHBPeriphClockCmd
08000994  w    F .text	00000002 DMA1_Channel4_IRQHandler
08001148 g     F .text	00000050 pvPortMalloc
080007d4 g     F .text	00000028 vTaskInit
08001290 g     F .text	00000000 _init
08000996 g     F .text	00000016 vListInitialise
08000994  w    F .text	00000002 USART3_IRQHandler
080011c4 g     F .text	00000028 __libc_fini_array
08000994  w    F .text	00000002 RTC_IRQHandler
20001558 g       .bss	00000000 _ebss
08000938 g     F .text	0000000c led_life_on
08000994  w    F .text	00000002 DMA1_Channel7_IRQHandler
08000950  w    F .text	00000030 Reset_Handler
08000330 g     F .text	00000006 GPIO_ReadInputData
08000994  w    F .text	00000002 CAN1_RX1_IRQHandler
08000908 g     F .text	00000030 led_life_init
08000758 g     F .text	00000034 RCC_GetFlagStatus
0800034c g     F .text	00000004 GPIO_SetBits
08000994  w    F .text	00000002 TIM4_IRQHandler
08000540 g     F .text	00000010 RCC_GetSYSCLKSource
08000354 g     F .text	0000000a GPIO_WriteBit
00000000  w      *UND*	00000000 __deregister_frame_info
08000994  w    F .text	00000002 I2C1_EV_IRQHandler
08000434 g     F .text	0000000c GPIO_ETH_MediaInterfaceConfig
08000610 g     F .text	00000098 RCC_GetClocksFreq
08000994  w    F .text	00000002 DMA1_Channel6_IRQHandler
08000994  w    F .text	00000002 TIM3_IRQHandler
08000994  w    F .text	00000002 RCC_IRQHandler
08000994  w    F .text	00000002 TIM1_TRG_COM_IRQHandler
00000000 g       *ABS*	00000000 _Min_Heap_Size
08000994  w    F .text	00000002 DMA1_Channel1_IRQHandler
08000994 g       .text	00000002 Default_Handler
08000c8c g     F .text	00000010 vTaskSuspendAll
080005f4 g     F .text	00000010 RCC_RTCCLKConfig
080009fa g     F .text	00000020 uxListRemove
08000994  w    F .text	00000002 EXTI15_10_IRQHandler
080011ec g     F .text	000000a4 __register_exitproc
08000ecc g     F .text	00000074 vTaskSwitchContext
08000350 g     F .text	00000004 GPIO_ResetBits
08000994  w    F .text	00000002 EXTI9_5_IRQHandler
08000408 g     F .text	0000002c GPIO_EXTILineConfig
08000944 g     F .text	0000000c led_life_off
08000f9c g     F .text	00000018 vPortYield
08000994  w    F .text	00000002 SPI2_IRQHandler
08000994  w    F .text	00000002 MemManage_Handler
080004ec g     F .text	00000014 RCC_AdjustHSICalibrationValue
080007fc g     F .text	00000012 main
080009ca g     F .text	00000030 vListInsert
08000f78 g     F .text	00000024 SVC_Handler
08000564 g     F .text	00000014 RCC_PCLK1Config
00000000  w      *UND*	00000000 __libc_fini
08000994  w    F .text	00000002 DMA1_Channel5_IRQHandler
080005a8 g     F .text	0000000c RCC_USBCLKConfig
08000994  w    F .text	00000002 EXTI4_IRQHandler
08000994  w    F .text	00000002 USB_LP_CAN1_RX0_IRQHandler
08000578 g     F .text	00000014 RCC_PCLK2Config
08000814 g     F .text	000000f4 SystemInit
08000168 g     F .text	000000dc GPIO_DeInit
0800129c g     F .text	00000000 _fini
08000db8 g     F .text	000000cc xTaskResumeAll
08000994  w    F .text	00000002 USB_HP_CAN1_TX_IRQHandler
08000c38 g     F .text	00000054 vTaskStartScheduler
08000440 g     F .text	00000040 RCC_DeInit
080011b8 g     F .text	0000000c atexit
08000994  w    F .text	00000002 DMA1_Channel3_IRQHandler
08000994  w    F .text	00000002 TIM1_UP_IRQHandler
08000994  w    F .text	00000002 WWDG_IRQHandler
08000718 g     F .text	0000001c RCC_APB1PeriphResetCmd
08000994  w    F .text	00000002 TIM2_IRQHandler
08000314 g     F .text	00000010 GPIO_StructInit
08000c9c g     F .text	0000011c xTaskIncrementTick
08000994  w    F .text	00000002 TIM1_BRK_IRQHandler
20002000 g       *ABS*	00000000 _estack
08000994  w    F .text	00000002 EXTI1_IRQHandler
20000448 g       .data	00000000 _edata
08000994  w    F .text	00000002 RTCAlarm_IRQHandler
08000994  w    F .text	00000002 USART2_IRQHandler
08000000 g     O .isr_vector	00000000 g_pfnVectors
08000994  w    F .text	00000002 I2C2_ER_IRQHandler
08000e84 g     F .text	00000048 vTaskDelay
08000994  w    F .text	00000002 DMA1_Channel2_IRQHandler
08000994  w    F .text	00000002 CAN1_SCE_IRQHandler
08000994  w    F .text	00000002 FLASH_IRQHandler
08000364 g     F .text	00000010 GPIO_PinLockConfig
08000994  w    F .text	00000002 BusFault_Handler
08000994  w    F .text	00000002 USART1_IRQHandler
080005e8 g     F .text	0000000c RCC_LSICmd
08000f5c g     F .text	0000001c pxPortInitialiseStack
080006fc g     F .text	0000001c RCC_APB2PeriphResetCmd
08000994  w    F .text	00000002 I2C1_ER_IRQHandler
08000fe0 g     F .text	0000001c vPortEnterCritical
00000000  w      *UND*	00000000 _Jv_RegisterClasses
08000324 g     F .text	0000000c GPIO_ReadInputDataBit
00000000  w      *UND*	00000000 __register_frame_info
08000994  w    F .text	00000002 USBWakeUp_IRQHandler
08000550 g     F .text	00000014 RCC_HCLKConfig



Disassembly of section .text:

0800010c <__do_global_dtors_aux>:
 800010c:	b510      	push	{r4, lr}
 800010e:	4c05      	ldr	r4, [pc, #20]	; (8000124 <__do_global_dtors_aux+0x18>)
 8000110:	7823      	ldrb	r3, [r4, #0]
 8000112:	b933      	cbnz	r3, 8000122 <__do_global_dtors_aux+0x16>
 8000114:	4b04      	ldr	r3, [pc, #16]	; (8000128 <__do_global_dtors_aux+0x1c>)
 8000116:	b113      	cbz	r3, 800011e <__do_global_dtors_aux+0x12>
 8000118:	4804      	ldr	r0, [pc, #16]	; (800012c <__do_global_dtors_aux+0x20>)
 800011a:	f3af 8000 	nop.w
 800011e:	2301      	movs	r3, #1
 8000120:	7023      	strb	r3, [r4, #0]
 8000122:	bd10      	pop	{r4, pc}
 8000124:	20000448 	.word	0x20000448
 8000128:	00000000 	.word	0x00000000
 800012c:	08001290 	.word	0x08001290

08000130 <frame_dummy>:
 8000130:	4b08      	ldr	r3, [pc, #32]	; (8000154 <frame_dummy+0x24>)
 8000132:	b510      	push	{r4, lr}
 8000134:	b11b      	cbz	r3, 800013e <frame_dummy+0xe>
 8000136:	4908      	ldr	r1, [pc, #32]	; (8000158 <frame_dummy+0x28>)
 8000138:	4808      	ldr	r0, [pc, #32]	; (800015c <frame_dummy+0x2c>)
 800013a:	f3af 8000 	nop.w
 800013e:	4808      	ldr	r0, [pc, #32]	; (8000160 <frame_dummy+0x30>)
 8000140:	6803      	ldr	r3, [r0, #0]
 8000142:	b903      	cbnz	r3, 8000146 <frame_dummy+0x16>
 8000144:	bd10      	pop	{r4, pc}
 8000146:	4b07      	ldr	r3, [pc, #28]	; (8000164 <frame_dummy+0x34>)
 8000148:	2b00      	cmp	r3, #0
 800014a:	d0fb      	beq.n	8000144 <frame_dummy+0x14>
 800014c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8000150:	4718      	bx	r3
 8000152:	bf00      	nop
 8000154:	00000000 	.word	0x00000000
 8000158:	2000044c 	.word	0x2000044c
 800015c:	08001290 	.word	0x08001290
 8000160:	20000448 	.word	0x20000448
 8000164:	00000000 	.word	0x00000000

08000168 <GPIO_DeInit>:
  * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8000168:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  if (GPIOx == GPIOA)
 800016a:	4b2f      	ldr	r3, [pc, #188]	; (8000228 <GPIO_DeInit+0xc0>)
 800016c:	4298      	cmp	r0, r3
 800016e:	d01e      	beq.n	80001ae <GPIO_DeInit+0x46>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
 8000170:	4b2e      	ldr	r3, [pc, #184]	; (800022c <GPIO_DeInit+0xc4>)
 8000172:	4298      	cmp	r0, r3
 8000174:	d025      	beq.n	80001c2 <GPIO_DeInit+0x5a>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
 8000176:	4b2e      	ldr	r3, [pc, #184]	; (8000230 <GPIO_DeInit+0xc8>)
 8000178:	4298      	cmp	r0, r3
 800017a:	d02c      	beq.n	80001d6 <GPIO_DeInit+0x6e>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
 800017c:	4b2d      	ldr	r3, [pc, #180]	; (8000234 <GPIO_DeInit+0xcc>)
 800017e:	4298      	cmp	r0, r3
 8000180:	d033      	beq.n	80001ea <GPIO_DeInit+0x82>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
  }    
  else if (GPIOx == GPIOE)
 8000182:	4b2d      	ldr	r3, [pc, #180]	; (8000238 <GPIO_DeInit+0xd0>)
 8000184:	4298      	cmp	r0, r3
 8000186:	d03a      	beq.n	80001fe <GPIO_DeInit+0x96>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
  } 
  else if (GPIOx == GPIOF)
 8000188:	4b2c      	ldr	r3, [pc, #176]	; (800023c <GPIO_DeInit+0xd4>)
 800018a:	4298      	cmp	r0, r3
 800018c:	d041      	beq.n	8000212 <GPIO_DeInit+0xaa>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
  }
  else
  {
    if (GPIOx == GPIOG)
 800018e:	4b2c      	ldr	r3, [pc, #176]	; (8000240 <GPIO_DeInit+0xd8>)
 8000190:	4298      	cmp	r0, r3
 8000192:	d000      	beq.n	8000196 <GPIO_DeInit+0x2e>
 8000194:	bd08      	pop	{r3, pc}
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
 8000196:	2101      	movs	r1, #1
 8000198:	f44f 7080 	mov.w	r0, #256	; 0x100
 800019c:	f000 faae 	bl	80006fc <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80001a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if (GPIOx == GPIOG)
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
 80001a4:	2100      	movs	r1, #0
 80001a6:	f44f 7080 	mov.w	r0, #256	; 0x100
 80001aa:	f000 baa7 	b.w	80006fc <RCC_APB2PeriphResetCmd>
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  if (GPIOx == GPIOA)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
 80001ae:	2101      	movs	r1, #1
 80001b0:	2004      	movs	r0, #4
 80001b2:	f000 faa3 	bl	80006fc <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80001b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  if (GPIOx == GPIOA)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
 80001ba:	2100      	movs	r1, #0
 80001bc:	2004      	movs	r0, #4
 80001be:	f000 ba9d 	b.w	80006fc <RCC_APB2PeriphResetCmd>
  }
  else if (GPIOx == GPIOB)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
 80001c2:	2101      	movs	r1, #1
 80001c4:	2008      	movs	r0, #8
 80001c6:	f000 fa99 	bl	80006fc <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80001ca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
 80001ce:	2100      	movs	r1, #0
 80001d0:	2008      	movs	r0, #8
 80001d2:	f000 ba93 	b.w	80006fc <RCC_APB2PeriphResetCmd>
  }
  else if (GPIOx == GPIOC)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
 80001d6:	2101      	movs	r1, #1
 80001d8:	2010      	movs	r0, #16
 80001da:	f000 fa8f 	bl	80006fc <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80001de:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
 80001e2:	2100      	movs	r1, #0
 80001e4:	2010      	movs	r0, #16
 80001e6:	f000 ba89 	b.w	80006fc <RCC_APB2PeriphResetCmd>
  }
  else if (GPIOx == GPIOD)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
 80001ea:	2101      	movs	r1, #1
 80001ec:	2020      	movs	r0, #32
 80001ee:	f000 fa85 	bl	80006fc <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80001f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
 80001f6:	2100      	movs	r1, #0
 80001f8:	2020      	movs	r0, #32
 80001fa:	f000 ba7f 	b.w	80006fc <RCC_APB2PeriphResetCmd>
  }    
  else if (GPIOx == GPIOE)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
 80001fe:	2101      	movs	r1, #1
 8000200:	2040      	movs	r0, #64	; 0x40
 8000202:	f000 fa7b 	bl	80006fc <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 8000206:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
  }    
  else if (GPIOx == GPIOE)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
 800020a:	2100      	movs	r1, #0
 800020c:	2040      	movs	r0, #64	; 0x40
 800020e:	f000 ba75 	b.w	80006fc <RCC_APB2PeriphResetCmd>
  } 
  else if (GPIOx == GPIOF)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
 8000212:	2101      	movs	r1, #1
 8000214:	2080      	movs	r0, #128	; 0x80
 8000216:	f000 fa71 	bl	80006fc <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 800021a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
  } 
  else if (GPIOx == GPIOF)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
 800021e:	2100      	movs	r1, #0
 8000220:	2080      	movs	r0, #128	; 0x80
 8000222:	f000 ba6b 	b.w	80006fc <RCC_APB2PeriphResetCmd>
 8000226:	bf00      	nop
 8000228:	40010800 	.word	0x40010800
 800022c:	40010c00 	.word	0x40010c00
 8000230:	40011000 	.word	0x40011000
 8000234:	40011400 	.word	0x40011400
 8000238:	40011800 	.word	0x40011800
 800023c:	40011c00 	.word	0x40011c00
 8000240:	40012000 	.word	0x40012000

08000244 <GPIO_AFIODeInit>:
  *   and EXTI configuration) registers to their default reset values.
  * @param  None
  * @retval None
  */
void GPIO_AFIODeInit(void)
{
 8000244:	b508      	push	{r3, lr}
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
 8000246:	2101      	movs	r1, #1
 8000248:	4608      	mov	r0, r1
 800024a:	f000 fa57 	bl	80006fc <RCC_APB2PeriphResetCmd>
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
}
 800024e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void GPIO_AFIODeInit(void)
{
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
 8000252:	2100      	movs	r1, #0
 8000254:	2001      	movs	r0, #1
 8000256:	f000 ba51 	b.w	80006fc <RCC_APB2PeriphResetCmd>
 800025a:	bf00      	nop

0800025c <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *         contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 800025c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 8000260:	78cc      	ldrb	r4, [r1, #3]
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 8000262:	06e3      	lsls	r3, r4, #27
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8000264:	bf48      	it	mi
 8000266:	788b      	ldrbmi	r3, [r1, #2]
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8000268:	8809      	ldrh	r1, [r1, #0]
 800026a:	f004 070f 	and.w	r7, r4, #15
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 800026e:	bf48      	it	mi
 8000270:	431f      	orrmi	r7, r3
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8000272:	f011 0fff 	tst.w	r1, #255	; 0xff
 8000276:	d021      	beq.n	80002bc <GPIO_Init+0x60>
  {
    tmpreg = GPIOx->CRL;
 8000278:	6806      	ldr	r6, [r0, #0]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 800027a:	2300      	movs	r3, #0
    {
      pos = ((uint32_t)0x01) << pinpos;
 800027c:	f04f 0e01 	mov.w	lr, #1
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8000280:	f04f 080f 	mov.w	r8, #15
 8000284:	e002      	b.n	800028c <GPIO_Init+0x30>
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8000286:	3301      	adds	r3, #1
 8000288:	2b08      	cmp	r3, #8
 800028a:	d016      	beq.n	80002ba <GPIO_Init+0x5e>
    {
      pos = ((uint32_t)0x01) << pinpos;
 800028c:	fa0e f203 	lsl.w	r2, lr, r3
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
 8000290:	ea32 0501 	bics.w	r5, r2, r1
 8000294:	d1f7      	bne.n	8000286 <GPIO_Init+0x2a>
      {
        pos = pinpos << 2;
 8000296:	009d      	lsls	r5, r3, #2
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8000298:	fa08 fc05 	lsl.w	ip, r8, r5
 800029c:	ea26 060c 	bic.w	r6, r6, ip
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80002a0:	fa07 f505 	lsl.w	r5, r7, r5
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80002a4:	2c28      	cmp	r4, #40	; 0x28
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80002a6:	ea46 0605 	orr.w	r6, r6, r5
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80002aa:	d031      	beq.n	8000310 <GPIO_Init+0xb4>
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 80002ac:	2c48      	cmp	r4, #72	; 0x48
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80002ae:	f103 0301 	add.w	r3, r3, #1
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 80002b2:	bf08      	it	eq
 80002b4:	6102      	streq	r2, [r0, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80002b6:	2b08      	cmp	r3, #8
 80002b8:	d1e8      	bne.n	800028c <GPIO_Init+0x30>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 80002ba:	6006      	str	r6, [r0, #0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 80002bc:	29ff      	cmp	r1, #255	; 0xff
 80002be:	d923      	bls.n	8000308 <GPIO_Init+0xac>
  {
    tmpreg = GPIOx->CRH;
 80002c0:	6846      	ldr	r6, [r0, #4]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80002c2:	2300      	movs	r3, #0
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 80002c4:	f04f 0e01 	mov.w	lr, #1
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80002c8:	f04f 080f 	mov.w	r8, #15
 80002cc:	e002      	b.n	80002d4 <GPIO_Init+0x78>
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80002ce:	3301      	adds	r3, #1
 80002d0:	2b08      	cmp	r3, #8
 80002d2:	d018      	beq.n	8000306 <GPIO_Init+0xaa>
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 80002d4:	f103 0208 	add.w	r2, r3, #8
 80002d8:	fa0e f202 	lsl.w	r2, lr, r2
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
 80002dc:	ea32 0501 	bics.w	r5, r2, r1
 80002e0:	d1f5      	bne.n	80002ce <GPIO_Init+0x72>
      {
        pos = pinpos << 2;
 80002e2:	009d      	lsls	r5, r3, #2
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80002e4:	fa08 fc05 	lsl.w	ip, r8, r5
 80002e8:	ea26 060c 	bic.w	r6, r6, ip
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80002ec:	fa07 f505 	lsl.w	r5, r7, r5
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80002f0:	2c28      	cmp	r4, #40	; 0x28
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80002f2:	ea46 0605 	orr.w	r6, r6, r5
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80002f6:	d009      	beq.n	800030c <GPIO_Init+0xb0>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 80002f8:	2c48      	cmp	r4, #72	; 0x48
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80002fa:	f103 0301 	add.w	r3, r3, #1
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 80002fe:	bf08      	it	eq
 8000300:	6102      	streq	r2, [r0, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8000302:	2b08      	cmp	r3, #8
 8000304:	d1e6      	bne.n	80002d4 <GPIO_Init+0x78>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 8000306:	6046      	str	r6, [r0, #4]
 8000308:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 800030c:	6142      	str	r2, [r0, #20]
 800030e:	e7de      	b.n	80002ce <GPIO_Init+0x72>
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 8000310:	6142      	str	r2, [r0, #20]
 8000312:	e7b8      	b.n	8000286 <GPIO_Init+0x2a>

08000314 <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8000314:	f64f 71ff 	movw	r1, #65535	; 0xffff
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8000318:	2202      	movs	r2, #2
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 800031a:	2304      	movs	r3, #4
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 800031c:	8001      	strh	r1, [r0, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 800031e:	7082      	strb	r2, [r0, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8000320:	70c3      	strb	r3, [r0, #3]
 8000322:	4770      	bx	lr

08000324 <GPIO_ReadInputDataBit>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8000324:	6883      	ldr	r3, [r0, #8]
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
 8000326:	4219      	tst	r1, r3
}
 8000328:	bf14      	ite	ne
 800032a:	2001      	movne	r0, #1
 800032c:	2000      	moveq	r0, #0
 800032e:	4770      	bx	lr

08000330 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  return ((uint16_t)GPIOx->IDR);
 8000330:	6880      	ldr	r0, [r0, #8]
}
 8000332:	b280      	uxth	r0, r0
 8000334:	4770      	bx	lr
 8000336:	bf00      	nop

08000338 <GPIO_ReadOutputDataBit>:
  uint8_t bitstatus = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8000338:	68c3      	ldr	r3, [r0, #12]
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
 800033a:	4219      	tst	r1, r3
}
 800033c:	bf14      	ite	ne
 800033e:	2001      	movne	r0, #1
 8000340:	2000      	moveq	r0, #0
 8000342:	4770      	bx	lr

08000344 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    
  return ((uint16_t)GPIOx->ODR);
 8000344:	68c0      	ldr	r0, [r0, #12]
}
 8000346:	b280      	uxth	r0, r0
 8000348:	4770      	bx	lr
 800034a:	bf00      	nop

0800034c <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 800034c:	6101      	str	r1, [r0, #16]
 800034e:	4770      	bx	lr

08000350 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 8000350:	6141      	str	r1, [r0, #20]
 8000352:	4770      	bx	lr

08000354 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
 8000354:	b90a      	cbnz	r2, 800035a <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
 8000356:	6141      	str	r1, [r0, #20]
 8000358:	4770      	bx	lr
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
  {
    GPIOx->BSRR = GPIO_Pin;
 800035a:	6101      	str	r1, [r0, #16]
 800035c:	4770      	bx	lr
 800035e:	bf00      	nop

08000360 <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  GPIOx->ODR = PortVal;
 8000360:	60c1      	str	r1, [r0, #12]
 8000362:	4770      	bx	lr

08000364 <GPIO_PinLockConfig>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  tmp |= GPIO_Pin;
 8000364:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8000368:	6183      	str	r3, [r0, #24]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 800036a:	6181      	str	r1, [r0, #24]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 800036c:	6183      	str	r3, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 800036e:	6983      	ldr	r3, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8000370:	6983      	ldr	r3, [r0, #24]
 8000372:	4770      	bx	lr

08000374 <GPIO_EventOutputConfig>:
  * @param  GPIO_PinSource: specifies the pin for the Event output.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 8000374:	f64f 7380 	movw	r3, #65408	; 0xff80
  uint32_t tmpreg = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
 8000378:	4a04      	ldr	r2, [pc, #16]	; (800038c <GPIO_EventOutputConfig+0x18>)
  * @param  GPIO_PinSource: specifies the pin for the Event output.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 800037a:	b410      	push	{r4}
  uint32_t tmpreg = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
 800037c:	6814      	ldr	r4, [r2, #0]
 800037e:	4023      	ands	r3, r4
 8000380:	4319      	orrs	r1, r3
  /* Clear the PORT[6:4] and PIN[3:0] bits */
  tmpreg &= EVCR_PORTPINCONFIG_MASK;
  tmpreg |= (uint32_t)GPIO_PortSource << 0x04;
  tmpreg |= GPIO_PinSource;
 8000382:	ea41 1000 	orr.w	r0, r1, r0, lsl #4
  AFIO->EVCR = tmpreg;
 8000386:	6010      	str	r0, [r2, #0]
}
 8000388:	bc10      	pop	{r4}
 800038a:	4770      	bx	lr
 800038c:	40010000 	.word	0x40010000

08000390 <GPIO_EventOutputCmd>:
void GPIO_EventOutputCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) EVCR_EVOE_BB = (uint32_t)NewState;
 8000390:	4b01      	ldr	r3, [pc, #4]	; (8000398 <GPIO_EventOutputCmd+0x8>)
 8000392:	6018      	str	r0, [r3, #0]
 8000394:	4770      	bx	lr
 8000396:	bf00      	nop
 8000398:	4220001c 	.word	0x4220001c

0800039c <GPIO_PinRemapConfig>:

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
 800039c:	2800      	cmp	r0, #0
  {
    tmpreg = AFIO->MAPR2;
 800039e:	4b19      	ldr	r3, [pc, #100]	; (8000404 <GPIO_PinRemapConfig+0x68>)
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80003a0:	f400 1240 	and.w	r2, r0, #3145728	; 0x300000
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    tmpreg = AFIO->MAPR2;
 80003a4:	bfb4      	ite	lt
 80003a6:	69db      	ldrlt	r3, [r3, #28]
  }
  else
  {
    tmpreg = AFIO->MAPR;
 80003a8:	685b      	ldrge	r3, [r3, #4]
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80003aa:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
  * @param  NewState: new state of the port pin remapping.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
{
 80003ae:	b430      	push	{r4, r5}
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;
 80003b0:	b284      	uxth	r4, r0

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80003b2:	d01e      	beq.n	80003f2 <GPIO_PinRemapConfig+0x56>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 80003b4:	02c2      	lsls	r2, r0, #11
 80003b6:	d513      	bpl.n	80003e0 <GPIO_PinRemapConfig+0x44>
  {
    tmp1 = ((uint32_t)0x03) << tmpmask;
    tmpreg &= ~tmp1;
 80003b8:	f3c0 4503 	ubfx	r5, r0, #16, #4
 80003bc:	2203      	movs	r2, #3
 80003be:	40aa      	lsls	r2, r5
 80003c0:	ea23 0302 	bic.w	r3, r3, r2
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 80003c4:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }

  if (NewState != DISABLE)
 80003c8:	b119      	cbz	r1, 80003d2 <GPIO_PinRemapConfig+0x36>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
 80003ca:	0d42      	lsrs	r2, r0, #21
 80003cc:	0112      	lsls	r2, r2, #4
 80003ce:	4094      	lsls	r4, r2
 80003d0:	4323      	orrs	r3, r4
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    AFIO->MAPR2 = tmpreg;
 80003d2:	4a0c      	ldr	r2, [pc, #48]	; (8000404 <GPIO_PinRemapConfig+0x68>)
  if (NewState != DISABLE)
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
 80003d4:	2800      	cmp	r0, #0
  {
    AFIO->MAPR2 = tmpreg;
 80003d6:	bfb4      	ite	lt
 80003d8:	61d3      	strlt	r3, [r2, #28]
  }
  else
  {
    AFIO->MAPR = tmpreg;
 80003da:	6053      	strge	r3, [r2, #4]
  }  
}
 80003dc:	bc30      	pop	{r4, r5}
 80003de:	4770      	bx	lr
    tmpreg &= ~tmp1;
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 80003e0:	0d42      	lsrs	r2, r0, #21
 80003e2:	0112      	lsls	r2, r2, #4
 80003e4:	fa04 f202 	lsl.w	r2, r4, r2
 80003e8:	ea23 0302 	bic.w	r3, r3, r2
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 80003ec:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
 80003f0:	e7ea      	b.n	80003c8 <GPIO_PinRemapConfig+0x2c>
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 80003f2:	4d04      	ldr	r5, [pc, #16]	; (8000404 <GPIO_PinRemapConfig+0x68>)
  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
 80003f4:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 80003f8:	686a      	ldr	r2, [r5, #4]
 80003fa:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 80003fe:	606a      	str	r2, [r5, #4]
 8000400:	e7e2      	b.n	80003c8 <GPIO_PinRemapConfig+0x2c>
 8000402:	bf00      	nop
 8000404:	40010000 	.word	0x40010000

08000408 <GPIO_EXTILineConfig>:
  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 8000408:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 800040c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8000410:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
  uint32_t tmp = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 8000414:	f001 0103 	and.w	r1, r1, #3
  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 8000418:	b410      	push	{r4}
  uint32_t tmp = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 800041a:	0089      	lsls	r1, r1, #2
  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
 800041c:	689c      	ldr	r4, [r3, #8]
 800041e:	220f      	movs	r2, #15
 8000420:	408a      	lsls	r2, r1
 8000422:	ea24 0202 	bic.w	r2, r4, r2
 8000426:	609a      	str	r2, [r3, #8]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
 8000428:	689a      	ldr	r2, [r3, #8]
 800042a:	4088      	lsls	r0, r1
 800042c:	4310      	orrs	r0, r2
 800042e:	6098      	str	r0, [r3, #8]
}
 8000430:	bc10      	pop	{r4}
 8000432:	4770      	bx	lr

08000434 <GPIO_ETH_MediaInterfaceConfig>:
void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface) 
{ 
  assert_param(IS_GPIO_ETH_MEDIA_INTERFACE(GPIO_ETH_MediaInterface)); 

  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) MAPR_MII_RMII_SEL_BB = GPIO_ETH_MediaInterface; 
 8000434:	4b01      	ldr	r3, [pc, #4]	; (800043c <GPIO_ETH_MediaInterfaceConfig+0x8>)
 8000436:	6018      	str	r0, [r3, #0]
 8000438:	4770      	bx	lr
 800043a:	bf00      	nop
 800043c:	422000dc 	.word	0x422000dc

08000440 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000440:	4b0d      	ldr	r3, [pc, #52]	; (8000478 <RCC_DeInit+0x38>)

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8000442:	4a0e      	ldr	r2, [pc, #56]	; (800047c <RCC_DeInit+0x3c>)
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000444:	6819      	ldr	r1, [r3, #0]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8000446:	f44f 001f 	mov.w	r0, #10420224	; 0x9f0000
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800044a:	f041 0101 	orr.w	r1, r1, #1
 800044e:	6019      	str	r1, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8000450:	6859      	ldr	r1, [r3, #4]
 8000452:	400a      	ands	r2, r1
 8000454:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000456:	681a      	ldr	r2, [r3, #0]
 8000458:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 800045c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000460:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000462:	681a      	ldr	r2, [r3, #0]
 8000464:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000468:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 800046a:	685a      	ldr	r2, [r3, #4]
 800046c:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8000470:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8000472:	6098      	str	r0, [r3, #8]
 8000474:	4770      	bx	lr
 8000476:	bf00      	nop
 8000478:	40021000 	.word	0x40021000
 800047c:	f8ff0000 	.word	0xf8ff0000

08000480 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 8000480:	4b0c      	ldr	r3, [pc, #48]	; (80004b4 <RCC_HSEConfig+0x34>)
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 8000482:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 8000486:	681a      	ldr	r2, [r3, #0]
 8000488:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800048c:	601a      	str	r2, [r3, #0]
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
 800048e:	681a      	ldr	r2, [r3, #0]
 8000490:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000494:	601a      	str	r2, [r3, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 8000496:	d008      	beq.n	80004aa <RCC_HSEConfig+0x2a>
 8000498:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 800049c:	d104      	bne.n	80004a8 <RCC_HSEConfig+0x28>
      RCC->CR |= CR_HSEON_Set;
      break;
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 800049e:	681a      	ldr	r2, [r3, #0]
 80004a0:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 80004a4:	601a      	str	r2, [r3, #0]
 80004a6:	4770      	bx	lr
 80004a8:	4770      	bx	lr
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
 80004aa:	681a      	ldr	r2, [r3, #0]
 80004ac:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80004b0:	601a      	str	r2, [r3, #0]
      break;
 80004b2:	4770      	bx	lr
 80004b4:	40021000 	.word	0x40021000

080004b8 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 80004b8:	b082      	sub	sp, #8
  __IO uint32_t StartUpCounter = 0;
 80004ba:	2300      	movs	r3, #0

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 80004bc:	4a0a      	ldr	r2, [pc, #40]	; (80004e8 <RCC_WaitForHSEStartUp+0x30>)
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
  __IO uint32_t StartUpCounter = 0;
 80004be:	9301      	str	r3, [sp, #4]
 80004c0:	e002      	b.n	80004c8 <RCC_WaitForHSEStartUp+0x10>
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    StartUpCounter++;  
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 80004c2:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80004c6:	d008      	beq.n	80004da <RCC_WaitForHSEStartUp+0x22>

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 80004c8:	6813      	ldr	r3, [r2, #0]
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 80004ca:	f413 3f00 	tst.w	r3, #131072	; 0x20000
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    StartUpCounter++;  
 80004ce:	9b01      	ldr	r3, [sp, #4]
 80004d0:	f103 0301 	add.w	r3, r3, #1
 80004d4:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 80004d6:	9b01      	ldr	r3, [sp, #4]
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 80004d8:	d0f3      	beq.n	80004c2 <RCC_WaitForHSEStartUp+0xa>

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 80004da:	4b03      	ldr	r3, [pc, #12]	; (80004e8 <RCC_WaitForHSEStartUp+0x30>)
 80004dc:	6818      	ldr	r0, [r3, #0]
  }
  else
  {
    status = ERROR;
  }  
  return (status);
 80004de:	f3c0 4040 	ubfx	r0, r0, #17, #1
}
 80004e2:	b002      	add	sp, #8
 80004e4:	4770      	bx	lr
 80004e6:	bf00      	nop
 80004e8:	40021000 	.word	0x40021000

080004ec <RCC_AdjustHSICalibrationValue>:
void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
  tmpreg = RCC->CR;
 80004ec:	4a03      	ldr	r2, [pc, #12]	; (80004fc <RCC_AdjustHSICalibrationValue+0x10>)
 80004ee:	6813      	ldr	r3, [r2, #0]
  /* Clear HSITRIM[4:0] bits */
  tmpreg &= CR_HSITRIM_Mask;
 80004f0:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 80004f4:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
  /* Store the new value */
  RCC->CR = tmpreg;
 80004f8:	6010      	str	r0, [r2, #0]
 80004fa:	4770      	bx	lr
 80004fc:	40021000 	.word	0x40021000

08000500 <RCC_HSICmd>:
  */
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 8000500:	4b01      	ldr	r3, [pc, #4]	; (8000508 <RCC_HSICmd+0x8>)
 8000502:	6018      	str	r0, [r3, #0]
 8000504:	4770      	bx	lr
 8000506:	bf00      	nop
 8000508:	42420000 	.word	0x42420000

0800050c <RCC_PLLConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 800050c:	4a03      	ldr	r2, [pc, #12]	; (800051c <RCC_PLLConfig+0x10>)
 800050e:	6853      	ldr	r3, [r2, #4]
 8000510:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8000514:	4319      	orrs	r1, r3
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 8000516:	4308      	orrs	r0, r1
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8000518:	6050      	str	r0, [r2, #4]
 800051a:	4770      	bx	lr
 800051c:	40021000 	.word	0x40021000

08000520 <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8000520:	4b01      	ldr	r3, [pc, #4]	; (8000528 <RCC_PLLCmd+0x8>)
 8000522:	6018      	str	r0, [r3, #0]
 8000524:	4770      	bx	lr
 8000526:	bf00      	nop
 8000528:	42420060 	.word	0x42420060

0800052c <RCC_SYSCLKConfig>:
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 800052c:	4a03      	ldr	r2, [pc, #12]	; (800053c <RCC_SYSCLKConfig+0x10>)
 800052e:	6853      	ldr	r3, [r2, #4]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 8000530:	f023 0303 	bic.w	r3, r3, #3
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8000534:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8000536:	6050      	str	r0, [r2, #4]
 8000538:	4770      	bx	lr
 800053a:	bf00      	nop
 800053c:	40021000 	.word	0x40021000

08000540 <RCC_GetSYSCLKSource>:
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 8000540:	4b02      	ldr	r3, [pc, #8]	; (800054c <RCC_GetSYSCLKSource+0xc>)
 8000542:	6858      	ldr	r0, [r3, #4]
}
 8000544:	f000 000c 	and.w	r0, r0, #12
 8000548:	4770      	bx	lr
 800054a:	bf00      	nop
 800054c:	40021000 	.word	0x40021000

08000550 <RCC_HCLKConfig>:
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 8000550:	4a03      	ldr	r2, [pc, #12]	; (8000560 <RCC_HCLKConfig+0x10>)
 8000552:	6853      	ldr	r3, [r2, #4]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 8000554:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8000558:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800055a:	6050      	str	r0, [r2, #4]
 800055c:	4770      	bx	lr
 800055e:	bf00      	nop
 8000560:	40021000 	.word	0x40021000

08000564 <RCC_PCLK1Config>:
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8000564:	4a03      	ldr	r2, [pc, #12]	; (8000574 <RCC_PCLK1Config+0x10>)
 8000566:	6853      	ldr	r3, [r2, #4]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 8000568:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 800056c:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800056e:	6050      	str	r0, [r2, #4]
 8000570:	4770      	bx	lr
 8000572:	bf00      	nop
 8000574:	40021000 	.word	0x40021000

08000578 <RCC_PCLK2Config>:
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8000578:	4a03      	ldr	r2, [pc, #12]	; (8000588 <RCC_PCLK2Config+0x10>)
 800057a:	6853      	ldr	r3, [r2, #4]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 800057c:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8000580:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8000584:	6050      	str	r0, [r2, #4]
 8000586:	4770      	bx	lr
 8000588:	40021000 	.word	0x40021000

0800058c <RCC_ITConfig>:
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800058c:	b929      	cbnz	r1, 800059a <RCC_ITConfig+0xe>
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
  }
  else
  {
    /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 800058e:	4a05      	ldr	r2, [pc, #20]	; (80005a4 <RCC_ITConfig+0x18>)
 8000590:	7813      	ldrb	r3, [r2, #0]
 8000592:	ea23 0000 	bic.w	r0, r3, r0
 8000596:	7010      	strb	r0, [r2, #0]
 8000598:	4770      	bx	lr
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 800059a:	4b02      	ldr	r3, [pc, #8]	; (80005a4 <RCC_ITConfig+0x18>)
 800059c:	781a      	ldrb	r2, [r3, #0]
 800059e:	4310      	orrs	r0, r2
 80005a0:	7018      	strb	r0, [r3, #0]
 80005a2:	4770      	bx	lr
 80005a4:	40021009 	.word	0x40021009

080005a8 <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 80005a8:	4b01      	ldr	r3, [pc, #4]	; (80005b0 <RCC_USBCLKConfig+0x8>)
 80005aa:	6018      	str	r0, [r3, #0]
 80005ac:	4770      	bx	lr
 80005ae:	bf00      	nop
 80005b0:	424200d8 	.word	0x424200d8

080005b4 <RCC_ADCCLKConfig>:
void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
  tmpreg = RCC->CFGR;
 80005b4:	4a03      	ldr	r2, [pc, #12]	; (80005c4 <RCC_ADCCLKConfig+0x10>)
 80005b6:	6853      	ldr	r3, [r2, #4]
  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
 80005b8:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
 80005bc:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80005be:	6050      	str	r0, [r2, #4]
 80005c0:	4770      	bx	lr
 80005c2:	bf00      	nop
 80005c4:	40021000 	.word	0x40021000

080005c8 <RCC_LSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80005c8:	4b06      	ldr	r3, [pc, #24]	; (80005e4 <RCC_LSEConfig+0x1c>)
 80005ca:	2200      	movs	r2, #0
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 80005cc:	2801      	cmp	r0, #1
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80005ce:	701a      	strb	r2, [r3, #0]
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80005d0:	701a      	strb	r2, [r3, #0]
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 80005d2:	d005      	beq.n	80005e0 <RCC_LSEConfig+0x18>
 80005d4:	2804      	cmp	r0, #4
 80005d6:	d102      	bne.n	80005de <RCC_LSEConfig+0x16>
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
      break;
      
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 80005d8:	2205      	movs	r2, #5
 80005da:	701a      	strb	r2, [r3, #0]
 80005dc:	4770      	bx	lr
 80005de:	4770      	bx	lr
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 80005e0:	7018      	strb	r0, [r3, #0]
      break;
 80005e2:	4770      	bx	lr
 80005e4:	40021020 	.word	0x40021020

080005e8 <RCC_LSICmd>:
  */
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 80005e8:	4b01      	ldr	r3, [pc, #4]	; (80005f0 <RCC_LSICmd+0x8>)
 80005ea:	6018      	str	r0, [r3, #0]
 80005ec:	4770      	bx	lr
 80005ee:	bf00      	nop
 80005f0:	42420480 	.word	0x42420480

080005f4 <RCC_RTCCLKConfig>:
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 80005f4:	4a02      	ldr	r2, [pc, #8]	; (8000600 <RCC_RTCCLKConfig+0xc>)
 80005f6:	6a13      	ldr	r3, [r2, #32]
 80005f8:	4318      	orrs	r0, r3
 80005fa:	6210      	str	r0, [r2, #32]
 80005fc:	4770      	bx	lr
 80005fe:	bf00      	nop
 8000600:	40021000 	.word	0x40021000

08000604 <RCC_RTCCLKCmd>:
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8000604:	4b01      	ldr	r3, [pc, #4]	; (800060c <RCC_RTCCLKCmd+0x8>)
 8000606:	6018      	str	r0, [r3, #0]
 8000608:	4770      	bx	lr
 800060a:	bf00      	nop
 800060c:	4242043c 	.word	0x4242043c

08000610 <RCC_GetClocksFreq>:
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8000610:	4a21      	ldr	r2, [pc, #132]	; (8000698 <RCC_GetClocksFreq+0x88>)
  * @note   The result of this function could be not correct when using 
  *         fractional value for HSE crystal.  
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8000612:	b410      	push	{r4}
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8000614:	6853      	ldr	r3, [r2, #4]
  
  switch (tmp)
 8000616:	f003 030c 	and.w	r3, r3, #12
 800061a:	2b04      	cmp	r3, #4
 800061c:	d006      	beq.n	800062c <RCC_GetClocksFreq+0x1c>
 800061e:	2b08      	cmp	r3, #8
 8000620:	d025      	beq.n	800066e <RCC_GetClocksFreq+0x5e>
 8000622:	b11b      	cbz	r3, 800062c <RCC_GetClocksFreq+0x1c>
      }
#endif /* STM32F10X_CL */ 
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8000624:	4a1d      	ldr	r2, [pc, #116]	; (800069c <RCC_GetClocksFreq+0x8c>)
      break;
 8000626:	4613      	mov	r3, r2
      }
#endif /* STM32F10X_CL */ 
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8000628:	6002      	str	r2, [r0, #0]
      break;
 800062a:	e001      	b.n	8000630 <RCC_GetClocksFreq+0x20>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 800062c:	4b1b      	ldr	r3, [pc, #108]	; (800069c <RCC_GetClocksFreq+0x8c>)
 800062e:	6003      	str	r3, [r0, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8000630:	4a19      	ldr	r2, [pc, #100]	; (8000698 <RCC_GetClocksFreq+0x88>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 8000632:	491b      	ldr	r1, [pc, #108]	; (80006a0 <RCC_GetClocksFreq+0x90>)
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8000634:	6854      	ldr	r4, [r2, #4]
  tmp = tmp >> 4;
 8000636:	f3c4 1403 	ubfx	r4, r4, #4, #4
  presc = APBAHBPrescTable[tmp];
 800063a:	5d0c      	ldrb	r4, [r1, r4]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800063c:	40e3      	lsrs	r3, r4
 800063e:	6043      	str	r3, [r0, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 8000640:	6854      	ldr	r4, [r2, #4]
  tmp = tmp >> 8;
 8000642:	f3c4 2402 	ubfx	r4, r4, #8, #3
  presc = APBAHBPrescTable[tmp];
 8000646:	5d0c      	ldrb	r4, [r1, r4]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8000648:	fa23 f404 	lsr.w	r4, r3, r4
 800064c:	6084      	str	r4, [r0, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 800064e:	6854      	ldr	r4, [r2, #4]
  tmp = tmp >> 11;
 8000650:	f3c4 24c2 	ubfx	r4, r4, #11, #3
  presc = APBAHBPrescTable[tmp];
 8000654:	5d0c      	ldrb	r4, [r1, r4]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8000656:	40e3      	lsrs	r3, r4
 8000658:	60c3      	str	r3, [r0, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 800065a:	6852      	ldr	r2, [r2, #4]
  tmp = tmp >> 14;
  presc = ADCPrescTable[tmp];
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
}
 800065c:	bc10      	pop	{r4}
  presc = APBAHBPrescTable[tmp];
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
  tmp = tmp >> 14;
 800065e:	f3c2 3281 	ubfx	r2, r2, #14, #2
  presc = ADCPrescTable[tmp];
 8000662:	440a      	add	r2, r1
 8000664:	7c12      	ldrb	r2, [r2, #16]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 8000666:	fbb3 f3f2 	udiv	r3, r3, r2
 800066a:	6103      	str	r3, [r0, #16]
}
 800066c:	4770      	bx	lr
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
      break;
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 800066e:	6853      	ldr	r3, [r2, #4]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 8000670:	6851      	ldr	r1, [r2, #4]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 8000672:	f3c3 4383 	ubfx	r3, r3, #18, #4
      
      if (pllsource == 0x00)
 8000676:	03c9      	lsls	r1, r1, #15
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 8000678:	f103 0302 	add.w	r3, r3, #2
      
      if (pllsource == 0x00)
 800067c:	d507      	bpl.n	800068e <RCC_GetClocksFreq+0x7e>
       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
       /* HSE oscillator clock selected as PREDIV1 clock entry */
       RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
 800067e:	6852      	ldr	r2, [r2, #4]
 8000680:	0392      	lsls	r2, r2, #14
 8000682:	d404      	bmi.n	800068e <RCC_GetClocksFreq+0x7e>
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
 8000684:	4a05      	ldr	r2, [pc, #20]	; (800069c <RCC_GetClocksFreq+0x8c>)
 8000686:	fb02 f303 	mul.w	r3, r2, r3
 800068a:	6003      	str	r3, [r0, #0]
 800068c:	e7d0      	b.n	8000630 <RCC_GetClocksFreq+0x20>
       RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
 800068e:	4a05      	ldr	r2, [pc, #20]	; (80006a4 <RCC_GetClocksFreq+0x94>)
 8000690:	fb02 f303 	mul.w	r3, r2, r3
 8000694:	6003      	str	r3, [r0, #0]
 8000696:	e7cb      	b.n	8000630 <RCC_GetClocksFreq+0x20>
 8000698:	40021000 	.word	0x40021000
 800069c:	007a1200 	.word	0x007a1200
 80006a0:	20000000 	.word	0x20000000
 80006a4:	003d0900 	.word	0x003d0900

080006a8 <RCC_AHBPeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80006a8:	b929      	cbnz	r1, 80006b6 <RCC_AHBPeriphClockCmd+0xe>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 80006aa:	4a05      	ldr	r2, [pc, #20]	; (80006c0 <RCC_AHBPeriphClockCmd+0x18>)
 80006ac:	6953      	ldr	r3, [r2, #20]
 80006ae:	ea23 0000 	bic.w	r0, r3, r0
 80006b2:	6150      	str	r0, [r2, #20]
 80006b4:	4770      	bx	lr
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 80006b6:	4b02      	ldr	r3, [pc, #8]	; (80006c0 <RCC_AHBPeriphClockCmd+0x18>)
 80006b8:	695a      	ldr	r2, [r3, #20]
 80006ba:	4310      	orrs	r0, r2
 80006bc:	6158      	str	r0, [r3, #20]
 80006be:	4770      	bx	lr
 80006c0:	40021000 	.word	0x40021000

080006c4 <RCC_APB2PeriphClockCmd>:
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80006c4:	b929      	cbnz	r1, 80006d2 <RCC_APB2PeriphClockCmd+0xe>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 80006c6:	4a05      	ldr	r2, [pc, #20]	; (80006dc <RCC_APB2PeriphClockCmd+0x18>)
 80006c8:	6993      	ldr	r3, [r2, #24]
 80006ca:	ea23 0000 	bic.w	r0, r3, r0
 80006ce:	6190      	str	r0, [r2, #24]
 80006d0:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80006d2:	4b02      	ldr	r3, [pc, #8]	; (80006dc <RCC_APB2PeriphClockCmd+0x18>)
 80006d4:	699a      	ldr	r2, [r3, #24]
 80006d6:	4310      	orrs	r0, r2
 80006d8:	6198      	str	r0, [r3, #24]
 80006da:	4770      	bx	lr
 80006dc:	40021000 	.word	0x40021000

080006e0 <RCC_APB1PeriphClockCmd>:
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80006e0:	b929      	cbnz	r1, 80006ee <RCC_APB1PeriphClockCmd+0xe>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 80006e2:	4a05      	ldr	r2, [pc, #20]	; (80006f8 <RCC_APB1PeriphClockCmd+0x18>)
 80006e4:	69d3      	ldr	r3, [r2, #28]
 80006e6:	ea23 0000 	bic.w	r0, r3, r0
 80006ea:	61d0      	str	r0, [r2, #28]
 80006ec:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80006ee:	4b02      	ldr	r3, [pc, #8]	; (80006f8 <RCC_APB1PeriphClockCmd+0x18>)
 80006f0:	69da      	ldr	r2, [r3, #28]
 80006f2:	4310      	orrs	r0, r2
 80006f4:	61d8      	str	r0, [r3, #28]
 80006f6:	4770      	bx	lr
 80006f8:	40021000 	.word	0x40021000

080006fc <RCC_APB2PeriphResetCmd>:
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80006fc:	b929      	cbnz	r1, 800070a <RCC_APB2PeriphResetCmd+0xe>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 80006fe:	4a05      	ldr	r2, [pc, #20]	; (8000714 <RCC_APB2PeriphResetCmd+0x18>)
 8000700:	68d3      	ldr	r3, [r2, #12]
 8000702:	ea23 0000 	bic.w	r0, r3, r0
 8000706:	60d0      	str	r0, [r2, #12]
 8000708:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 800070a:	4b02      	ldr	r3, [pc, #8]	; (8000714 <RCC_APB2PeriphResetCmd+0x18>)
 800070c:	68da      	ldr	r2, [r3, #12]
 800070e:	4310      	orrs	r0, r2
 8000710:	60d8      	str	r0, [r3, #12]
 8000712:	4770      	bx	lr
 8000714:	40021000 	.word	0x40021000

08000718 <RCC_APB1PeriphResetCmd>:
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000718:	b929      	cbnz	r1, 8000726 <RCC_APB1PeriphResetCmd+0xe>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 800071a:	4a05      	ldr	r2, [pc, #20]	; (8000730 <RCC_APB1PeriphResetCmd+0x18>)
 800071c:	6913      	ldr	r3, [r2, #16]
 800071e:	ea23 0000 	bic.w	r0, r3, r0
 8000722:	6110      	str	r0, [r2, #16]
 8000724:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8000726:	4b02      	ldr	r3, [pc, #8]	; (8000730 <RCC_APB1PeriphResetCmd+0x18>)
 8000728:	691a      	ldr	r2, [r3, #16]
 800072a:	4310      	orrs	r0, r2
 800072c:	6118      	str	r0, [r3, #16]
 800072e:	4770      	bx	lr
 8000730:	40021000 	.word	0x40021000

08000734 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 8000734:	4b01      	ldr	r3, [pc, #4]	; (800073c <RCC_BackupResetCmd+0x8>)
 8000736:	6018      	str	r0, [r3, #0]
 8000738:	4770      	bx	lr
 800073a:	bf00      	nop
 800073c:	42420440 	.word	0x42420440

08000740 <RCC_ClockSecuritySystemCmd>:
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8000740:	4b01      	ldr	r3, [pc, #4]	; (8000748 <RCC_ClockSecuritySystemCmd+0x8>)
 8000742:	6018      	str	r0, [r3, #0]
 8000744:	4770      	bx	lr
 8000746:	bf00      	nop
 8000748:	4242004c 	.word	0x4242004c

0800074c <RCC_MCOConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCO));

  /* Perform Byte access to MCO bits to select the MCO source */
  *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
 800074c:	4b01      	ldr	r3, [pc, #4]	; (8000754 <RCC_MCOConfig+0x8>)
 800074e:	7018      	strb	r0, [r3, #0]
 8000750:	4770      	bx	lr
 8000752:	bf00      	nop
 8000754:	40021007 	.word	0x40021007

08000758 <RCC_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8000758:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 800075a:	2b01      	cmp	r3, #1
 800075c:	d00b      	beq.n	8000776 <RCC_GetFlagStatus+0x1e>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 800075e:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 8000760:	4b09      	ldr	r3, [pc, #36]	; (8000788 <RCC_GetFlagStatus+0x30>)
  {
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
 8000762:	f000 001f 	and.w	r0, r0, #31
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
  {
    statusreg = RCC->BDCR;
 8000766:	bf0c      	ite	eq
 8000768:	6a1b      	ldreq	r3, [r3, #32]
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 800076a:	6a5b      	ldrne	r3, [r3, #36]	; 0x24
  {
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
 800076c:	fa23 f000 	lsr.w	r0, r3, r0
}
 8000770:	f000 0001 	and.w	r0, r0, #1
 8000774:	4770      	bx	lr

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8000776:	4b04      	ldr	r3, [pc, #16]	; (8000788 <RCC_GetFlagStatus+0x30>)
  {
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
 8000778:	f000 001f 	and.w	r0, r0, #31

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 800077c:	681b      	ldr	r3, [r3, #0]
  {
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
 800077e:	fa23 f000 	lsr.w	r0, r3, r0
}
 8000782:	f000 0001 	and.w	r0, r0, #1
 8000786:	4770      	bx	lr
 8000788:	40021000 	.word	0x40021000

0800078c <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= CSR_RMVF_Set;
 800078c:	4a02      	ldr	r2, [pc, #8]	; (8000798 <RCC_ClearFlag+0xc>)
 800078e:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8000790:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000794:	6253      	str	r3, [r2, #36]	; 0x24
 8000796:	4770      	bx	lr
 8000798:	40021000 	.word	0x40021000

0800079c <RCC_GetITStatus>:
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 800079c:	4b03      	ldr	r3, [pc, #12]	; (80007ac <RCC_GetITStatus+0x10>)
 800079e:	689b      	ldr	r3, [r3, #8]
  {
    bitstatus = RESET;
  }

  /* Return the RCC_IT status */
  return  bitstatus;
 80007a0:	4218      	tst	r0, r3
}
 80007a2:	bf14      	ite	ne
 80007a4:	2001      	movne	r0, #1
 80007a6:	2000      	moveq	r0, #0
 80007a8:	4770      	bx	lr
 80007aa:	bf00      	nop
 80007ac:	40021000 	.word	0x40021000

080007b0 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 80007b0:	4b01      	ldr	r3, [pc, #4]	; (80007b8 <RCC_ClearITPendingBit+0x8>)
 80007b2:	7018      	strb	r0, [r3, #0]
 80007b4:	4770      	bx	lr
 80007b6:	bf00      	nop
 80007b8:	4002100a 	.word	0x4002100a

080007bc <blinkyTask>:

void prvSetupHardware(void) {
	led_life_init();
}

void blinkyTask(void *dummy) {
 80007bc:	b508      	push	{r3, lr}
	(void)dummy;

	while (1) {
		/* maintain LED2 status for 100ms */
		led_life_on();
 80007be:	f000 f8bb 	bl	8000938 <led_life_on>
		vTaskDelay(100);
 80007c2:	2064      	movs	r0, #100	; 0x64
 80007c4:	f000 fb5e 	bl	8000e84 <vTaskDelay>
		led_life_off();
 80007c8:	f000 f8bc 	bl	8000944 <led_life_off>
		vTaskDelay(100);
 80007cc:	2064      	movs	r0, #100	; 0x64
 80007ce:	f000 fb59 	bl	8000e84 <vTaskDelay>
 80007d2:	e7f4      	b.n	80007be <blinkyTask+0x2>

080007d4 <vTaskInit>:
	}
}

void vTaskInit(void) {
 80007d4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	xTaskCreate(blinkyTask,
 80007d6:	2300      	movs	r3, #0
 80007d8:	2201      	movs	r2, #1
 80007da:	9200      	str	r2, [sp, #0]
 80007dc:	9303      	str	r3, [sp, #12]
 80007de:	9302      	str	r3, [sp, #8]
 80007e0:	9301      	str	r3, [sp, #4]
 80007e2:	2280      	movs	r2, #128	; 0x80
 80007e4:	4903      	ldr	r1, [pc, #12]	; (80007f4 <vTaskInit+0x20>)
 80007e6:	4804      	ldr	r0, [pc, #16]	; (80007f8 <vTaskInit+0x24>)
 80007e8:	f000 f95c 	bl	8000aa4 <xTaskGenericCreate>
				(const signed char *)"blinkyTask",
				configMINIMAL_STACK_SIZE,
				NULL,                 /* pvParameters */
				tskIDLE_PRIORITY + 1, /* uxPriority */
				NULL                  /* pvCreatedTask */);
}
 80007ec:	b005      	add	sp, #20
 80007ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80007f2:	bf00      	nop
 80007f4:	080012a8 	.word	0x080012a8
 80007f8:	080007bd 	.word	0x080007bd

080007fc <main>:
/**
  * @brief  Main program.
  * @param  None
  * @retval None
  */
int main(void) {
 80007fc:	b508      	push	{r3, lr}
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
static __IO uint32_t TimingDelay;

void prvSetupHardware(void) {
	led_life_init();
 80007fe:	f000 f883 	bl	8000908 <led_life_init>
	 * To reconfigure the default setting of SystemInit() function, refer to
	 * system_stm32f2xx.c file */

	prvSetupHardware();

	vTaskInit();
 8000802:	f7ff ffe7 	bl	80007d4 <vTaskInit>

	vTaskStartScheduler();
 8000806:	f000 fa17 	bl	8000c38 <vTaskStartScheduler>

	return (0);
}
 800080a:	2000      	movs	r0, #0
 800080c:	bd08      	pop	{r3, pc}

0800080e <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 800080e:	4770      	bx	lr

08000810 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8000810:	e7fe      	b.n	8000810 <HardFault_Handler>
	...

08000814 <SystemInit>:
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000814:	4b38      	ldr	r3, [pc, #224]	; (80008f8 <SystemInit+0xe4>)
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8000816:	b082      	sub	sp, #8
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000818:	681a      	ldr	r2, [r3, #0]
 800081a:	f042 0201 	orr.w	r2, r2, #1
 800081e:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8000820:	6859      	ldr	r1, [r3, #4]
 8000822:	4a36      	ldr	r2, [pc, #216]	; (80008fc <SystemInit+0xe8>)
 8000824:	400a      	ands	r2, r1
 8000826:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000828:	681a      	ldr	r2, [r3, #0]
 800082a:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 800082e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000832:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000834:	681a      	ldr	r2, [r3, #0]
 8000836:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800083a:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 800083c:	685a      	ldr	r2, [r3, #4]
 800083e:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8000842:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8000844:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 8000848:	609a      	str	r2, [r3, #8]
  * @param  None
  * @retval None
  */
static void SetSysClockTo72(void)
{
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 800084a:	2200      	movs	r2, #0
 800084c:	9200      	str	r2, [sp, #0]
 800084e:	9201      	str	r2, [sp, #4]
  
  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8000850:	681a      	ldr	r2, [r3, #0]
 8000852:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000856:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8000858:	681a      	ldr	r2, [r3, #0]
 800085a:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 800085e:	9201      	str	r2, [sp, #4]
    StartUpCounter++;  
 8000860:	9a00      	ldr	r2, [sp, #0]
 8000862:	3201      	adds	r2, #1
 8000864:	9200      	str	r2, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8000866:	9a01      	ldr	r2, [sp, #4]
 8000868:	b91a      	cbnz	r2, 8000872 <SystemInit+0x5e>
 800086a:	9a00      	ldr	r2, [sp, #0]
 800086c:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 8000870:	d1f2      	bne.n	8000858 <SystemInit+0x44>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8000872:	681a      	ldr	r2, [r3, #0]
 8000874:	f412 3200 	ands.w	r2, r2, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 8000878:	bf18      	it	ne
 800087a:	2201      	movne	r2, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 800087c:	9201      	str	r2, [sp, #4]
  }  

  if (HSEStatus == (uint32_t)0x01)
 800087e:	9a01      	ldr	r2, [sp, #4]
 8000880:	2a01      	cmp	r2, #1
 8000882:	d005      	beq.n	8000890 <SystemInit+0x7c>
  SetSysClock();

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8000884:	4b1e      	ldr	r3, [pc, #120]	; (8000900 <SystemInit+0xec>)
 8000886:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800088a:	609a      	str	r2, [r3, #8]
#endif 
}
 800088c:	b002      	add	sp, #8
 800088e:	4770      	bx	lr
  }  

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 8000890:	4a1c      	ldr	r2, [pc, #112]	; (8000904 <SystemInit+0xf0>)
 8000892:	6811      	ldr	r1, [r2, #0]
 8000894:	f041 0110 	orr.w	r1, r1, #16
 8000898:	6011      	str	r1, [r2, #0]

    /* Flash 2 wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
 800089a:	6811      	ldr	r1, [r2, #0]
 800089c:	f021 0107 	bic.w	r1, r1, #7
 80008a0:	6011      	str	r1, [r2, #0]
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
 80008a2:	6811      	ldr	r1, [r2, #0]
 80008a4:	f041 0102 	orr.w	r1, r1, #2
 80008a8:	6011      	str	r1, [r2, #0]

 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 80008aa:	685a      	ldr	r2, [r3, #4]
 80008ac:	605a      	str	r2, [r3, #4]
      
    /* PCLK2 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 80008ae:	685a      	ldr	r2, [r3, #4]
 80008b0:	605a      	str	r2, [r3, #4]
    
    /* PCLK1 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
 80008b2:	685a      	ldr	r2, [r3, #4]
 80008b4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80008b8:	605a      	str	r2, [r3, #4]
    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
                            RCC_CFGR_PLLMULL9); 
#else    
    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
 80008ba:	685a      	ldr	r2, [r3, #4]
 80008bc:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 80008c0:	605a      	str	r2, [r3, #4]
                                        RCC_CFGR_PLLMULL));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
 80008c2:	685a      	ldr	r2, [r3, #4]
 80008c4:	f442 12e8 	orr.w	r2, r2, #1900544	; 0x1d0000
 80008c8:	605a      	str	r2, [r3, #4]
#endif /* STM32F10X_CL */

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 80008ca:	681a      	ldr	r2, [r3, #0]
 80008cc:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80008d0:	601a      	str	r2, [r3, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 80008d2:	6819      	ldr	r1, [r3, #0]
 80008d4:	4a08      	ldr	r2, [pc, #32]	; (80008f8 <SystemInit+0xe4>)
 80008d6:	0189      	lsls	r1, r1, #6
 80008d8:	d5fb      	bpl.n	80008d2 <SystemInit+0xbe>
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 80008da:	6851      	ldr	r1, [r2, #4]
 80008dc:	f021 0103 	bic.w	r1, r1, #3
 80008e0:	6051      	str	r1, [r2, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
 80008e2:	6851      	ldr	r1, [r2, #4]
 80008e4:	f041 0102 	orr.w	r1, r1, #2
 80008e8:	6051      	str	r1, [r2, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
 80008ea:	685a      	ldr	r2, [r3, #4]
 80008ec:	f002 020c 	and.w	r2, r2, #12
 80008f0:	2a08      	cmp	r2, #8
 80008f2:	d1fa      	bne.n	80008ea <SystemInit+0xd6>
 80008f4:	e7c6      	b.n	8000884 <SystemInit+0x70>
 80008f6:	bf00      	nop
 80008f8:	40021000 	.word	0x40021000
 80008fc:	f8ff0000 	.word	0xf8ff0000
 8000900:	e000ed00 	.word	0xe000ed00
 8000904:	40022000 	.word	0x40022000

08000908 <led_life_init>:
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure); 
}

void led_life_init() {
 8000908:	b507      	push	{r0, r1, r2, lr}
	GPIO_InitTypeDef        GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(LED_LIFE_IO_CLOCK, ENABLE);
 800090a:	2101      	movs	r1, #1
 800090c:	2040      	movs	r0, #64	; 0x40
 800090e:	f7ff fed9 	bl	80006c4 <RCC_APB2PeriphClockCmd>

	GPIO_InitStructure.GPIO_Pin = LED_LIFE_IO_PIN;
 8000912:	2380      	movs	r3, #128	; 0x80
 8000914:	f8ad 3004 	strh.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8000918:	2310      	movs	r3, #16
 800091a:	f88d 3007 	strb.w	r3, [sp, #7]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(LED_LIFE_IO_PORT, &GPIO_InitStructure);
 800091e:	a901      	add	r1, sp, #4
	GPIO_InitTypeDef        GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(LED_LIFE_IO_CLOCK, ENABLE);

	GPIO_InitStructure.GPIO_Pin = LED_LIFE_IO_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8000920:	2303      	movs	r3, #3
	GPIO_Init(LED_LIFE_IO_PORT, &GPIO_InitStructure);
 8000922:	4804      	ldr	r0, [pc, #16]	; (8000934 <led_life_init+0x2c>)
	GPIO_InitTypeDef        GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(LED_LIFE_IO_CLOCK, ENABLE);

	GPIO_InitStructure.GPIO_Pin = LED_LIFE_IO_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8000924:	f88d 3006 	strb.w	r3, [sp, #6]
	GPIO_Init(LED_LIFE_IO_PORT, &GPIO_InitStructure);
 8000928:	f7ff fc98 	bl	800025c <GPIO_Init>
}
 800092c:	b003      	add	sp, #12
 800092e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000932:	bf00      	nop
 8000934:	40011800 	.word	0x40011800

08000938 <led_life_on>:

void led_life_on() {
	GPIO_SetBits(LED_LIFE_IO_PORT, LED_LIFE_IO_PIN);
 8000938:	2180      	movs	r1, #128	; 0x80
 800093a:	4801      	ldr	r0, [pc, #4]	; (8000940 <led_life_on+0x8>)
 800093c:	f7ff bd06 	b.w	800034c <GPIO_SetBits>
 8000940:	40011800 	.word	0x40011800

08000944 <led_life_off>:
}

void led_life_off() {
	GPIO_ResetBits(LED_LIFE_IO_PORT, LED_LIFE_IO_PIN);
 8000944:	2180      	movs	r1, #128	; 0x80
 8000946:	4801      	ldr	r0, [pc, #4]	; (800094c <led_life_off+0x8>)
 8000948:	f7ff bd02 	b.w	8000350 <GPIO_ResetBits>
 800094c:	40011800 	.word	0x40011800

08000950 <Reset_Handler>:
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:	

/* Copy the data segment initializers from flash to SRAM */  
  movs	r1, #0
 8000950:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8000952:	e003      	b.n	800095c <LoopCopyDataInit>

08000954 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8000954:	4b0a      	ldr	r3, [pc, #40]	; (8000980 <LoopFillZerobss+0x10>)
	ldr	r3, [r3, r1]
 8000956:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8000958:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 800095a:	3104      	adds	r1, #4

0800095c <LoopCopyDataInit>:
    
LoopCopyDataInit:
	ldr	r0, =_sdata
 800095c:	4809      	ldr	r0, [pc, #36]	; (8000984 <LoopFillZerobss+0x14>)
	ldr	r3, =_edata
 800095e:	4b0a      	ldr	r3, [pc, #40]	; (8000988 <LoopFillZerobss+0x18>)
	adds	r2, r0, r1
 8000960:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8000962:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8000964:	d3f6      	bcc.n	8000954 <CopyDataInit>
	ldr	r2, =_sbss
 8000966:	4a09      	ldr	r2, [pc, #36]	; (800098c <LoopFillZerobss+0x1c>)
	b	LoopFillZerobss
 8000968:	e002      	b.n	8000970 <LoopFillZerobss>

0800096a <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
	movs	r3, #0
 800096a:	2300      	movs	r3, #0
	str	r3, [r2], #4
 800096c:	f842 3b04 	str.w	r3, [r2], #4

08000970 <LoopFillZerobss>:
    
LoopFillZerobss:
	ldr	r3, = _ebss
 8000970:	4b07      	ldr	r3, [pc, #28]	; (8000990 <LoopFillZerobss+0x20>)
	cmp	r2, r3
 8000972:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8000974:	d3f9      	bcc.n	800096a <FillZerobss>
/* Call the clock system intitialization function.*/
  bl  SystemInit 	
 8000976:	f7ff ff4d 	bl	8000814 <SystemInit>
/* Call the application's entry point.*/
	bl	main
 800097a:	f7ff ff3f 	bl	80007fc <main>
	bx	lr    
 800097e:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */  
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 8000980:	080012c8 	.word	0x080012c8
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4
    
LoopCopyDataInit:
	ldr	r0, =_sdata
 8000984:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8000988:	20000448 	.word	0x20000448
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 800098c:	20000448 	.word	0x20000448
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4
    
LoopFillZerobss:
	ldr	r3, = _ebss
 8000990:	20001558 	.word	0x20001558

08000994 <ADC1_2_IRQHandler>:
 * @retval None       
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8000994:	e7fe      	b.n	8000994 <ADC1_2_IRQHandler>

08000996 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000996:	f100 0308 	add.w	r3, r0, #8
 800099a:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800099c:	f04f 32ff 	mov.w	r2, #4294967295

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80009a0:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80009a2:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80009a4:	2300      	movs	r3, #0
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80009a6:	6082      	str	r2, [r0, #8]
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80009a8:	6003      	str	r3, [r0, #0]
 80009aa:	4770      	bx	lr

080009ac <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 80009ac:	2300      	movs	r3, #0
 80009ae:	6103      	str	r3, [r0, #16]
 80009b0:	4770      	bx	lr

080009b2 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 80009b2:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80009b4:	689a      	ldr	r2, [r3, #8]
ListItem_t * const pxIndex = pxList->pxIndex;

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 80009b6:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80009b8:	608a      	str	r2, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 80009ba:	689a      	ldr	r2, [r3, #8]
 80009bc:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 80009be:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 80009c0:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
	pxIndex->pxPrevious->pxNext = pxNewListItem;
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 80009c2:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 80009c4:	3301      	adds	r3, #1
 80009c6:	6003      	str	r3, [r0, #0]
 80009c8:	4770      	bx	lr

080009ca <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 80009ca:	680a      	ldr	r2, [r1, #0]
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 80009cc:	b530      	push	{r4, r5, lr}
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 80009ce:	1c53      	adds	r3, r2, #1
 80009d0:	d101      	bne.n	80009d6 <vListInsert+0xc>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 80009d2:	6903      	ldr	r3, [r0, #16]
 80009d4:	e007      	b.n	80009e6 <vListInsert+0x1c>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80009d6:	f100 0308 	add.w	r3, r0, #8
 80009da:	685c      	ldr	r4, [r3, #4]
 80009dc:	6825      	ldr	r5, [r4, #0]
 80009de:	42aa      	cmp	r2, r5
 80009e0:	d301      	bcc.n	80009e6 <vListInsert+0x1c>
 80009e2:	4623      	mov	r3, r4
 80009e4:	e7f9      	b.n	80009da <vListInsert+0x10>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 80009e6:	685a      	ldr	r2, [r3, #4]
 80009e8:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80009ea:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 80009ec:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 80009ee:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 80009f0:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = pxNewListItem;

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 80009f2:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 80009f4:	3301      	adds	r3, #1
 80009f6:	6003      	str	r3, [r0, #0]
 80009f8:	bd30      	pop	{r4, r5, pc}

080009fa <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80009fa:	6841      	ldr	r1, [r0, #4]
 80009fc:	6882      	ldr	r2, [r0, #8]

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 80009fe:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8000a00:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8000a02:	6882      	ldr	r2, [r0, #8]
 8000a04:	6051      	str	r1, [r2, #4]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8000a06:	6859      	ldr	r1, [r3, #4]
 8000a08:	4288      	cmp	r0, r1
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8000a0a:	bf08      	it	eq
 8000a0c:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8000a0e:	2200      	movs	r2, #0
 8000a10:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8000a12:	6818      	ldr	r0, [r3, #0]
 8000a14:	3801      	subs	r0, #1
 8000a16:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8000a18:	4770      	bx	lr
	...

08000a1c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8000a1c:	b508      	push	{r3, lr}

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8000a1e:	4c03      	ldr	r4, [pc, #12]	; (8000a2c <prvIdleTask+0x10>)
 8000a20:	6823      	ldr	r3, [r4, #0]
 8000a22:	2b01      	cmp	r3, #1
 8000a24:	d9fd      	bls.n	8000a22 <prvIdleTask+0x6>
			{
				taskYIELD();
 8000a26:	f000 fab9 	bl	8000f9c <vPortYield>
 8000a2a:	e7f9      	b.n	8000a20 <prvIdleTask+0x4>
 8000a2c:	2000049c 	.word	0x2000049c

08000a30 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8000a30:	4a06      	ldr	r2, [pc, #24]	; (8000a4c <prvResetNextTaskUnblockTime+0x1c>)
 8000a32:	6813      	ldr	r3, [r2, #0]
 8000a34:	6819      	ldr	r1, [r3, #0]
 8000a36:	4b06      	ldr	r3, [pc, #24]	; (8000a50 <prvResetNextTaskUnblockTime+0x20>)
 8000a38:	b911      	cbnz	r1, 8000a40 <prvResetNextTaskUnblockTime+0x10>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8000a3a:	f04f 32ff 	mov.w	r2, #4294967295
 8000a3e:	e003      	b.n	8000a48 <prvResetNextTaskUnblockTime+0x18>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8000a40:	6812      	ldr	r2, [r2, #0]
 8000a42:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 8000a44:	68d2      	ldr	r2, [r2, #12]
 8000a46:	6852      	ldr	r2, [r2, #4]
 8000a48:	601a      	str	r2, [r3, #0]
 8000a4a:	4770      	bx	lr
 8000a4c:	20000468 	.word	0x20000468
 8000a50:	20000018 	.word	0x20000018

08000a54 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8000a54:	4b0e      	ldr	r3, [pc, #56]	; (8000a90 <prvAddCurrentTaskToDelayedList+0x3c>)
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 8000a56:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8000a58:	681a      	ldr	r2, [r3, #0]
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 8000a5a:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8000a5c:	6050      	str	r0, [r2, #4]

	if( xTimeToWake < xTickCount )
 8000a5e:	4a0d      	ldr	r2, [pc, #52]	; (8000a94 <prvAddCurrentTaskToDelayedList+0x40>)
 8000a60:	6812      	ldr	r2, [r2, #0]
 8000a62:	4290      	cmp	r0, r2
 8000a64:	d207      	bcs.n	8000a76 <prvAddCurrentTaskToDelayedList+0x22>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 8000a66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8000a6a:	4a0b      	ldr	r2, [pc, #44]	; (8000a98 <prvAddCurrentTaskToDelayedList+0x44>)
 8000a6c:	6810      	ldr	r0, [r2, #0]
 8000a6e:	6819      	ldr	r1, [r3, #0]
 8000a70:	3104      	adds	r1, #4
 8000a72:	f7ff bfaa 	b.w	80009ca <vListInsert>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8000a76:	4a09      	ldr	r2, [pc, #36]	; (8000a9c <prvAddCurrentTaskToDelayedList+0x48>)
 8000a78:	6810      	ldr	r0, [r2, #0]
 8000a7a:	6819      	ldr	r1, [r3, #0]
 8000a7c:	3104      	adds	r1, #4
 8000a7e:	f7ff ffa4 	bl	80009ca <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 8000a82:	4b07      	ldr	r3, [pc, #28]	; (8000aa0 <prvAddCurrentTaskToDelayedList+0x4c>)
 8000a84:	681a      	ldr	r2, [r3, #0]
 8000a86:	4294      	cmp	r4, r2
		{
			xNextTaskUnblockTime = xTimeToWake;
 8000a88:	bf38      	it	cc
 8000a8a:	601c      	strcc	r4, [r3, #0]
 8000a8c:	bd10      	pop	{r4, pc}
 8000a8e:	bf00      	nop
 8000a90:	20000504 	.word	0x20000504
 8000a94:	2000051c 	.word	0x2000051c
 8000a98:	20000520 	.word	0x20000520
 8000a9c:	20000468 	.word	0x20000468
 8000aa0:	20000018 	.word	0x20000018

08000aa4 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 8000aa4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000aa8:	ae0a      	add	r6, sp, #40	; 0x28
 8000aaa:	460f      	mov	r7, r1
 8000aac:	e896 0a40 	ldmia.w	r6, {r6, r9, fp}
 8000ab0:	4615      	mov	r5, r2
 8000ab2:	469a      	mov	sl, r3
BaseType_t xReturn;
TCB_t * pxNewTCB;

	configASSERT( pxTaskCode );
 8000ab4:	4680      	mov	r8, r0
 8000ab6:	b910      	cbnz	r0, 8000abe <xTaskGenericCreate+0x1a>
 8000ab8:	f000 fa7c 	bl	8000fb4 <ulPortSetInterruptMask>
 8000abc:	e7fe      	b.n	8000abc <xTaskGenericCreate+0x18>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 8000abe:	2e04      	cmp	r6, #4
 8000ac0:	d902      	bls.n	8000ac8 <xTaskGenericCreate+0x24>
 8000ac2:	f000 fa77 	bl	8000fb4 <ulPortSetInterruptMask>
 8000ac6:	e7fe      	b.n	8000ac6 <xTaskGenericCreate+0x22>
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 8000ac8:	2048      	movs	r0, #72	; 0x48
 8000aca:	f000 fb3d 	bl	8001148 <pvPortMalloc>

	if( pxNewTCB != NULL )
 8000ace:	4604      	mov	r4, r0
 8000ad0:	2800      	cmp	r0, #0
 8000ad2:	f000 8094 	beq.w	8000bfe <xTaskGenericCreate+0x15a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000ad6:	f1bb 0f00 	cmp.w	fp, #0
 8000ada:	d103      	bne.n	8000ae4 <xTaskGenericCreate+0x40>
 8000adc:	00a8      	lsls	r0, r5, #2
 8000ade:	f000 fb33 	bl	8001148 <pvPortMalloc>
 8000ae2:	e000      	b.n	8000ae6 <xTaskGenericCreate+0x42>
 8000ae4:	4658      	mov	r0, fp
 8000ae6:	6320      	str	r0, [r4, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 8000ae8:	b918      	cbnz	r0, 8000af2 <xTaskGenericCreate+0x4e>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8000aea:	4620      	mov	r0, r4
 8000aec:	f000 fb54 	bl	8001198 <vPortFree>
 8000af0:	e085      	b.n	8000bfe <xTaskGenericCreate+0x15a>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8000af2:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 8000af6:	3d01      	subs	r5, #1
 8000af8:	eb00 0085 	add.w	r0, r0, r5, lsl #2
 8000afc:	1e7b      	subs	r3, r7, #1
 8000afe:	f020 0507 	bic.w	r5, r0, #7
 8000b02:	f104 0233 	add.w	r2, r4, #51	; 0x33
 8000b06:	370f      	adds	r7, #15
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 8000b08:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8000b0c:	f802 1f01 	strb.w	r1, [r2, #1]!

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 8000b10:	7819      	ldrb	r1, [r3, #0]
 8000b12:	b109      	cbz	r1, 8000b18 <xTaskGenericCreate+0x74>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8000b14:	429f      	cmp	r7, r3
 8000b16:	d1f7      	bne.n	8000b08 <xTaskGenericCreate+0x64>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8000b18:	2300      	movs	r3, #0
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8000b1a:	1d27      	adds	r7, r4, #4
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8000b1c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8000b20:	4638      	mov	r0, r7
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 8000b22:	62e6      	str	r6, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8000b24:	6466      	str	r6, [r4, #68]	; 0x44
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8000b26:	f7ff ff41 	bl	80009ac <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8000b2a:	f104 0018 	add.w	r0, r4, #24
 8000b2e:	f7ff ff3d 	bl	80009ac <vListInitialiseItem>
	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000b32:	f1c6 0305 	rsb	r3, r6, #5
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8000b36:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000b38:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8000b3a:	6264      	str	r4, [r4, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8000b3c:	4652      	mov	r2, sl
 8000b3e:	4641      	mov	r1, r8
 8000b40:	4628      	mov	r0, r5
 8000b42:	f000 fa0b 	bl	8000f5c <pxPortInitialiseStack>
 8000b46:	6020      	str	r0, [r4, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 8000b48:	f1b9 0f00 	cmp.w	r9, #0
 8000b4c:	d001      	beq.n	8000b52 <xTaskGenericCreate+0xae>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8000b4e:	f8c9 4000 	str.w	r4, [r9]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 8000b52:	f000 fa45 	bl	8000fe0 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 8000b56:	4a2c      	ldr	r2, [pc, #176]	; (8000c08 <xTaskGenericCreate+0x164>)
			if( pxCurrentTCB == NULL )
 8000b58:	4d2c      	ldr	r5, [pc, #176]	; (8000c0c <xTaskGenericCreate+0x168>)

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
		{
			uxCurrentNumberOfTasks++;
 8000b5a:	6813      	ldr	r3, [r2, #0]
 8000b5c:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 8000c2c <xTaskGenericCreate+0x188>
 8000b60:	3301      	adds	r3, #1
 8000b62:	6013      	str	r3, [r2, #0]
			if( pxCurrentTCB == NULL )
 8000b64:	682b      	ldr	r3, [r5, #0]
 8000b66:	bb23      	cbnz	r3, 8000bb2 <xTaskGenericCreate+0x10e>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 8000b68:	602c      	str	r4, [r5, #0]

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8000b6a:	6812      	ldr	r2, [r2, #0]
 8000b6c:	2a01      	cmp	r2, #1
 8000b6e:	d128      	bne.n	8000bc2 <xTaskGenericCreate+0x11e>
 8000b70:	4698      	mov	r8, r3
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8000b72:	eb09 0008 	add.w	r0, r9, r8
 8000b76:	f108 0814 	add.w	r8, r8, #20
 8000b7a:	f7ff ff0c 	bl	8000996 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8000b7e:	f1b8 0f64 	cmp.w	r8, #100	; 0x64
 8000b82:	d1f6      	bne.n	8000b72 <xTaskGenericCreate+0xce>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 8000b84:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 8000c30 <xTaskGenericCreate+0x18c>
	vListInitialise( &xDelayedTaskList2 );
 8000b88:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8000c34 <xTaskGenericCreate+0x190>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 8000b8c:	4650      	mov	r0, sl
 8000b8e:	f7ff ff02 	bl	8000996 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8000b92:	4640      	mov	r0, r8
 8000b94:	f7ff feff 	bl	8000996 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8000b98:	481d      	ldr	r0, [pc, #116]	; (8000c10 <xTaskGenericCreate+0x16c>)
 8000b9a:	f7ff fefc 	bl	8000996 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8000b9e:	481d      	ldr	r0, [pc, #116]	; (8000c14 <xTaskGenericCreate+0x170>)
 8000ba0:	f7ff fef9 	bl	8000996 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8000ba4:	4b1c      	ldr	r3, [pc, #112]	; (8000c18 <xTaskGenericCreate+0x174>)
 8000ba6:	f8c3 a000 	str.w	sl, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8000baa:	4b1c      	ldr	r3, [pc, #112]	; (8000c1c <xTaskGenericCreate+0x178>)
 8000bac:	f8c3 8000 	str.w	r8, [r3]
 8000bb0:	e007      	b.n	8000bc2 <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8000bb2:	4b1b      	ldr	r3, [pc, #108]	; (8000c20 <xTaskGenericCreate+0x17c>)
 8000bb4:	681b      	ldr	r3, [r3, #0]
 8000bb6:	b923      	cbnz	r3, 8000bc2 <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8000bb8:	682b      	ldr	r3, [r5, #0]
 8000bba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000bbc:	429e      	cmp	r6, r3
					{
						pxCurrentTCB = pxNewTCB;
 8000bbe:	bf28      	it	cs
 8000bc0:	602c      	strcs	r4, [r5, #0]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8000bc2:	4a18      	ldr	r2, [pc, #96]	; (8000c24 <xTaskGenericCreate+0x180>)
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8000bc4:	2014      	movs	r0, #20
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8000bc6:	6813      	ldr	r3, [r2, #0]
 8000bc8:	3301      	adds	r3, #1
 8000bca:	6013      	str	r3, [r2, #0]
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8000bcc:	4a16      	ldr	r2, [pc, #88]	; (8000c28 <xTaskGenericCreate+0x184>)
 8000bce:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000bd0:	6811      	ldr	r1, [r2, #0]
 8000bd2:	fb00 9003 	mla	r0, r0, r3, r9
 8000bd6:	428b      	cmp	r3, r1
 8000bd8:	4639      	mov	r1, r7
 8000bda:	bf88      	it	hi
 8000bdc:	6013      	strhi	r3, [r2, #0]
 8000bde:	f7ff fee8 	bl	80009b2 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 8000be2:	f000 fa0f 	bl	8001004 <vPortExitCritical>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 8000be6:	4b0e      	ldr	r3, [pc, #56]	; (8000c20 <xTaskGenericCreate+0x17c>)
 8000be8:	681b      	ldr	r3, [r3, #0]
 8000bea:	b12b      	cbz	r3, 8000bf8 <xTaskGenericCreate+0x154>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 8000bec:	682b      	ldr	r3, [r5, #0]
 8000bee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000bf0:	429e      	cmp	r6, r3
 8000bf2:	d901      	bls.n	8000bf8 <xTaskGenericCreate+0x154>
			{
				taskYIELD_IF_USING_PREEMPTION();
 8000bf4:	f000 f9d2 	bl	8000f9c <vPortYield>
 8000bf8:	2001      	movs	r0, #1
 8000bfa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8000bfe:	f04f 30ff 	mov.w	r0, #4294967295
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
 8000c02:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000c06:	bf00      	nop
 8000c08:	20000528 	.word	0x20000528
 8000c0c:	20000504 	.word	0x20000504
 8000c10:	20000508 	.word	0x20000508
 8000c14:	2000052c 	.word	0x2000052c
 8000c18:	20000468 	.word	0x20000468
 8000c1c:	20000520 	.word	0x20000520
 8000c20:	2000046c 	.word	0x2000046c
 8000c24:	20000524 	.word	0x20000524
 8000c28:	20000540 	.word	0x20000540
 8000c2c:	2000049c 	.word	0x2000049c
 8000c30:	20000470 	.word	0x20000470
 8000c34:	20000484 	.word	0x20000484

08000c38 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 8000c38:	b530      	push	{r4, r5, lr}
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 8000c3a:	2400      	movs	r4, #0

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 8000c3c:	b085      	sub	sp, #20
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 8000c3e:	9403      	str	r4, [sp, #12]
 8000c40:	9402      	str	r4, [sp, #8]
 8000c42:	9401      	str	r4, [sp, #4]
 8000c44:	9400      	str	r4, [sp, #0]
 8000c46:	4623      	mov	r3, r4
 8000c48:	2280      	movs	r2, #128	; 0x80
 8000c4a:	490c      	ldr	r1, [pc, #48]	; (8000c7c <vTaskStartScheduler+0x44>)
 8000c4c:	480c      	ldr	r0, [pc, #48]	; (8000c80 <vTaskStartScheduler+0x48>)
 8000c4e:	f7ff ff29 	bl	8000aa4 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8000c52:	2801      	cmp	r0, #1
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 8000c54:	4605      	mov	r5, r0
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8000c56:	d10a      	bne.n	8000c6e <vTaskStartScheduler+0x36>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 8000c58:	f000 f9ac 	bl	8000fb4 <ulPortSetInterruptMask>
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
 8000c5c:	4b09      	ldr	r3, [pc, #36]	; (8000c84 <vTaskStartScheduler+0x4c>)
 8000c5e:	601d      	str	r5, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8000c60:	4b09      	ldr	r3, [pc, #36]	; (8000c88 <vTaskStartScheduler+0x50>)
 8000c62:	601c      	str	r4, [r3, #0]
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 8000c64:	b005      	add	sp, #20
 8000c66:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 8000c6a:	f000 ba25 	b.w	80010b8 <xPortStartScheduler>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
 8000c6e:	b910      	cbnz	r0, 8000c76 <vTaskStartScheduler+0x3e>
 8000c70:	f000 f9a0 	bl	8000fb4 <ulPortSetInterruptMask>
 8000c74:	e7fe      	b.n	8000c74 <vTaskStartScheduler+0x3c>
	}
}
 8000c76:	b005      	add	sp, #20
 8000c78:	bd30      	pop	{r4, r5, pc}
 8000c7a:	bf00      	nop
 8000c7c:	080012b3 	.word	0x080012b3
 8000c80:	08000a1d 	.word	0x08000a1d
 8000c84:	2000046c 	.word	0x2000046c
 8000c88:	2000051c 	.word	0x2000051c

08000c8c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 8000c8c:	4a02      	ldr	r2, [pc, #8]	; (8000c98 <vTaskSuspendAll+0xc>)
 8000c8e:	6813      	ldr	r3, [r2, #0]
 8000c90:	3301      	adds	r3, #1
 8000c92:	6013      	str	r3, [r2, #0]
 8000c94:	4770      	bx	lr
 8000c96:	bf00      	nop
 8000c98:	20000500 	.word	0x20000500

08000c9c <xTaskIncrementTick>:

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000c9c:	4b3b      	ldr	r3, [pc, #236]	; (8000d8c <xTaskIncrementTick+0xf0>)

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 8000c9e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000ca2:	681b      	ldr	r3, [r3, #0]
 8000ca4:	2b00      	cmp	r3, #0
 8000ca6:	d136      	bne.n	8000d16 <xTaskIncrementTick+0x7a>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 8000ca8:	4b39      	ldr	r3, [pc, #228]	; (8000d90 <xTaskIncrementTick+0xf4>)
 8000caa:	681a      	ldr	r2, [r3, #0]
 8000cac:	3201      	adds	r2, #1
 8000cae:	601a      	str	r2, [r3, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 8000cb0:	681d      	ldr	r5, [r3, #0]

			if( xConstTickCount == ( TickType_t ) 0U )
 8000cb2:	b98d      	cbnz	r5, 8000cd8 <xTaskIncrementTick+0x3c>
			{
				taskSWITCH_DELAYED_LISTS();
 8000cb4:	4b37      	ldr	r3, [pc, #220]	; (8000d94 <xTaskIncrementTick+0xf8>)
 8000cb6:	681a      	ldr	r2, [r3, #0]
 8000cb8:	6812      	ldr	r2, [r2, #0]
 8000cba:	b112      	cbz	r2, 8000cc2 <xTaskIncrementTick+0x26>
 8000cbc:	f000 f97a 	bl	8000fb4 <ulPortSetInterruptMask>
 8000cc0:	e7fe      	b.n	8000cc0 <xTaskIncrementTick+0x24>
 8000cc2:	4a35      	ldr	r2, [pc, #212]	; (8000d98 <xTaskIncrementTick+0xfc>)
 8000cc4:	6819      	ldr	r1, [r3, #0]
 8000cc6:	6810      	ldr	r0, [r2, #0]
 8000cc8:	6018      	str	r0, [r3, #0]
 8000cca:	6011      	str	r1, [r2, #0]
 8000ccc:	4a33      	ldr	r2, [pc, #204]	; (8000d9c <xTaskIncrementTick+0x100>)
 8000cce:	6813      	ldr	r3, [r2, #0]
 8000cd0:	3301      	adds	r3, #1
 8000cd2:	6013      	str	r3, [r2, #0]
 8000cd4:	f7ff feac 	bl	8000a30 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 8000cd8:	4c31      	ldr	r4, [pc, #196]	; (8000da0 <xTaskIncrementTick+0x104>)
 8000cda:	f04f 0b00 	mov.w	fp, #0
 8000cde:	6823      	ldr	r3, [r4, #0]
 8000ce0:	9401      	str	r4, [sp, #4]
 8000ce2:	429d      	cmp	r5, r3
 8000ce4:	4e2f      	ldr	r6, [pc, #188]	; (8000da4 <xTaskIncrementTick+0x108>)
 8000ce6:	4f30      	ldr	r7, [pc, #192]	; (8000da8 <xTaskIncrementTick+0x10c>)
 8000ce8:	d30b      	bcc.n	8000d02 <xTaskIncrementTick+0x66>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8000cea:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8000d94 <xTaskIncrementTick+0xf8>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 8000cee:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 8000db4 <xTaskIncrementTick+0x118>
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8000cf2:	f8d8 2000 	ldr.w	r2, [r8]
 8000cf6:	6812      	ldr	r2, [r2, #0]
 8000cf8:	b9a2      	cbnz	r2, 8000d24 <xTaskIncrementTick+0x88>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 8000cfa:	9b01      	ldr	r3, [sp, #4]
 8000cfc:	f04f 32ff 	mov.w	r2, #4294967295
 8000d00:	601a      	str	r2, [r3, #0]
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8000d02:	683a      	ldr	r2, [r7, #0]
 8000d04:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8000d06:	2214      	movs	r2, #20
 8000d08:	434a      	muls	r2, r1
 8000d0a:	58b2      	ldr	r2, [r6, r2]
			{
				xSwitchRequired = pdTRUE;
 8000d0c:	2a02      	cmp	r2, #2
 8000d0e:	bf28      	it	cs
 8000d10:	f04f 0b01 	movcs.w	fp, #1
 8000d14:	e030      	b.n	8000d78 <xTaskIncrementTick+0xdc>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 8000d16:	4a25      	ldr	r2, [pc, #148]	; (8000dac <xTaskIncrementTick+0x110>)

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 8000d18:	f04f 0b00 	mov.w	fp, #0
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 8000d1c:	6813      	ldr	r3, [r2, #0]
 8000d1e:	3301      	adds	r3, #1
 8000d20:	6013      	str	r3, [r2, #0]
 8000d22:	e029      	b.n	8000d78 <xTaskIncrementTick+0xdc>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8000d24:	f8d8 2000 	ldr.w	r2, [r8]
 8000d28:	68d2      	ldr	r2, [r2, #12]
 8000d2a:	68d4      	ldr	r4, [r2, #12]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 8000d2c:	6861      	ldr	r1, [r4, #4]

						if( xConstTickCount < xItemValue )
 8000d2e:	428d      	cmp	r5, r1
 8000d30:	d202      	bcs.n	8000d38 <xTaskIncrementTick+0x9c>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
 8000d32:	9b01      	ldr	r3, [sp, #4]
 8000d34:	6019      	str	r1, [r3, #0]
							break;
 8000d36:	e7e4      	b.n	8000d02 <xTaskIncrementTick+0x66>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8000d38:	f104 0a04 	add.w	sl, r4, #4
 8000d3c:	4650      	mov	r0, sl
 8000d3e:	f7ff fe5c 	bl	80009fa <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8000d42:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000d44:	b119      	cbz	r1, 8000d4e <xTaskIncrementTick+0xb2>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8000d46:	f104 0018 	add.w	r0, r4, #24
 8000d4a:	f7ff fe56 	bl	80009fa <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 8000d4e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8000d50:	f8d9 1000 	ldr.w	r1, [r9]
 8000d54:	2314      	movs	r3, #20
 8000d56:	4288      	cmp	r0, r1
 8000d58:	bf88      	it	hi
 8000d5a:	f8c9 0000 	strhi.w	r0, [r9]
 8000d5e:	4651      	mov	r1, sl
 8000d60:	fb03 6000 	mla	r0, r3, r0, r6
 8000d64:	f7ff fe25 	bl	80009b2 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000d68:	6838      	ldr	r0, [r7, #0]
 8000d6a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8000d6c:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
							{
								xSwitchRequired = pdTRUE;
 8000d6e:	4291      	cmp	r1, r2
 8000d70:	bf28      	it	cs
 8000d72:	f04f 0b01 	movcs.w	fp, #1
 8000d76:	e7bc      	b.n	8000cf2 <xTaskIncrementTick+0x56>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8000d78:	4a0d      	ldr	r2, [pc, #52]	; (8000db0 <xTaskIncrementTick+0x114>)
 8000d7a:	6812      	ldr	r2, [r2, #0]
		{
			xSwitchRequired = pdTRUE;
 8000d7c:	2a00      	cmp	r2, #0
 8000d7e:	bf18      	it	ne
 8000d80:	f04f 0b01 	movne.w	fp, #1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 8000d84:	4658      	mov	r0, fp
 8000d86:	b003      	add	sp, #12
 8000d88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000d8c:	20000500 	.word	0x20000500
 8000d90:	2000051c 	.word	0x2000051c
 8000d94:	20000468 	.word	0x20000468
 8000d98:	20000520 	.word	0x20000520
 8000d9c:	20000464 	.word	0x20000464
 8000da0:	20000018 	.word	0x20000018
 8000da4:	2000049c 	.word	0x2000049c
 8000da8:	20000504 	.word	0x20000504
 8000dac:	20000498 	.word	0x20000498
 8000db0:	20000544 	.word	0x20000544
 8000db4:	20000540 	.word	0x20000540

08000db8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 8000db8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 8000dbc:	4c29      	ldr	r4, [pc, #164]	; (8000e64 <xTaskResumeAll+0xac>)
 8000dbe:	6823      	ldr	r3, [r4, #0]
 8000dc0:	b913      	cbnz	r3, 8000dc8 <xTaskResumeAll+0x10>
 8000dc2:	f000 f8f7 	bl	8000fb4 <ulPortSetInterruptMask>
 8000dc6:	e7fe      	b.n	8000dc6 <xTaskResumeAll+0xe>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 8000dc8:	f000 f90a 	bl	8000fe0 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8000dcc:	6823      	ldr	r3, [r4, #0]
 8000dce:	3b01      	subs	r3, #1
 8000dd0:	6023      	str	r3, [r4, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000dd2:	6823      	ldr	r3, [r4, #0]
 8000dd4:	b10b      	cbz	r3, 8000dda <xTaskResumeAll+0x22>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 8000dd6:	2400      	movs	r4, #0
 8000dd8:	e03f      	b.n	8000e5a <xTaskResumeAll+0xa2>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8000dda:	4b23      	ldr	r3, [pc, #140]	; (8000e68 <xTaskResumeAll+0xb0>)
 8000ddc:	681b      	ldr	r3, [r3, #0]
 8000dde:	2b00      	cmp	r3, #0
 8000de0:	d0f9      	beq.n	8000dd6 <xTaskResumeAll+0x1e>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8000de2:	4d22      	ldr	r5, [pc, #136]	; (8000e6c <xTaskResumeAll+0xb4>)
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
 8000de4:	4e22      	ldr	r6, [pc, #136]	; (8000e70 <xTaskResumeAll+0xb8>)
 8000de6:	f8df 8098 	ldr.w	r8, [pc, #152]	; 8000e80 <xTaskResumeAll+0xc8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8000dea:	682b      	ldr	r3, [r5, #0]
 8000dec:	b1f3      	cbz	r3, 8000e2c <xTaskResumeAll+0x74>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8000dee:	68eb      	ldr	r3, [r5, #12]
 8000df0:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8000df2:	1d27      	adds	r7, r4, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8000df4:	f104 0018 	add.w	r0, r4, #24
 8000df8:	f7ff fdff 	bl	80009fa <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8000dfc:	4638      	mov	r0, r7
 8000dfe:	f7ff fdfc 	bl	80009fa <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8000e02:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000e04:	6832      	ldr	r2, [r6, #0]
 8000e06:	2014      	movs	r0, #20
 8000e08:	4293      	cmp	r3, r2
 8000e0a:	fb00 8003 	mla	r0, r0, r3, r8
 8000e0e:	4639      	mov	r1, r7
 8000e10:	bf88      	it	hi
 8000e12:	6033      	strhi	r3, [r6, #0]
 8000e14:	f7ff fdcd 	bl	80009b2 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000e18:	4b16      	ldr	r3, [pc, #88]	; (8000e74 <xTaskResumeAll+0xbc>)
 8000e1a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000e1c:	681b      	ldr	r3, [r3, #0]
 8000e1e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000e20:	429a      	cmp	r2, r3
 8000e22:	d3e2      	bcc.n	8000dea <xTaskResumeAll+0x32>
					{
						xYieldPending = pdTRUE;
 8000e24:	4b14      	ldr	r3, [pc, #80]	; (8000e78 <xTaskResumeAll+0xc0>)
 8000e26:	2201      	movs	r2, #1
 8000e28:	601a      	str	r2, [r3, #0]
 8000e2a:	e7dc      	b.n	8000de6 <xTaskResumeAll+0x2e>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 8000e2c:	4c13      	ldr	r4, [pc, #76]	; (8000e7c <xTaskResumeAll+0xc4>)
 8000e2e:	6823      	ldr	r3, [r4, #0]
 8000e30:	b933      	cbnz	r3, 8000e40 <xTaskResumeAll+0x88>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 8000e32:	4b11      	ldr	r3, [pc, #68]	; (8000e78 <xTaskResumeAll+0xc0>)
 8000e34:	681c      	ldr	r4, [r3, #0]
 8000e36:	2c01      	cmp	r4, #1
 8000e38:	d1cd      	bne.n	8000dd6 <xTaskResumeAll+0x1e>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 8000e3a:	f000 f8af 	bl	8000f9c <vPortYield>
 8000e3e:	e00c      	b.n	8000e5a <xTaskResumeAll+0xa2>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 8000e40:	4d0d      	ldr	r5, [pc, #52]	; (8000e78 <xTaskResumeAll+0xc0>)
 8000e42:	2601      	movs	r6, #1
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 8000e44:	6823      	ldr	r3, [r4, #0]
 8000e46:	2b00      	cmp	r3, #0
 8000e48:	d0f3      	beq.n	8000e32 <xTaskResumeAll+0x7a>
					{
						if( xTaskIncrementTick() != pdFALSE )
 8000e4a:	f7ff ff27 	bl	8000c9c <xTaskIncrementTick>
 8000e4e:	b100      	cbz	r0, 8000e52 <xTaskResumeAll+0x9a>
						{
							xYieldPending = pdTRUE;
 8000e50:	602e      	str	r6, [r5, #0]
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 8000e52:	6823      	ldr	r3, [r4, #0]
 8000e54:	3b01      	subs	r3, #1
 8000e56:	6023      	str	r3, [r4, #0]
 8000e58:	e7f4      	b.n	8000e44 <xTaskResumeAll+0x8c>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8000e5a:	f000 f8d3 	bl	8001004 <vPortExitCritical>

	return xAlreadyYielded;
}
 8000e5e:	4620      	mov	r0, r4
 8000e60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000e64:	20000500 	.word	0x20000500
 8000e68:	20000528 	.word	0x20000528
 8000e6c:	20000508 	.word	0x20000508
 8000e70:	20000540 	.word	0x20000540
 8000e74:	20000504 	.word	0x20000504
 8000e78:	20000544 	.word	0x20000544
 8000e7c:	20000498 	.word	0x20000498
 8000e80:	2000049c 	.word	0x2000049c

08000e84 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 8000e84:	b510      	push	{r4, lr}
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 8000e86:	b918      	cbnz	r0, 8000e90 <vTaskDelay+0xc>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8000e88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 8000e8c:	f000 b886 	b.w	8000f9c <vPortYield>


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
 8000e90:	4b0b      	ldr	r3, [pc, #44]	; (8000ec0 <vTaskDelay+0x3c>)
 8000e92:	681b      	ldr	r3, [r3, #0]
 8000e94:	b113      	cbz	r3, 8000e9c <vTaskDelay+0x18>
 8000e96:	f000 f88d 	bl	8000fb4 <ulPortSetInterruptMask>
 8000e9a:	e7fe      	b.n	8000e9a <vTaskDelay+0x16>
			vTaskSuspendAll();
 8000e9c:	f7ff fef6 	bl	8000c8c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8000ea0:	4b08      	ldr	r3, [pc, #32]	; (8000ec4 <vTaskDelay+0x40>)
 8000ea2:	681b      	ldr	r3, [r3, #0]
 8000ea4:	18c4      	adds	r4, r0, r3

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8000ea6:	4b08      	ldr	r3, [pc, #32]	; (8000ec8 <vTaskDelay+0x44>)
 8000ea8:	6818      	ldr	r0, [r3, #0]
 8000eaa:	3004      	adds	r0, #4
 8000eac:	f7ff fda5 	bl	80009fa <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 8000eb0:	4620      	mov	r0, r4
 8000eb2:	f7ff fdcf 	bl	8000a54 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 8000eb6:	f7ff ff7f 	bl	8000db8 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8000eba:	2800      	cmp	r0, #0
 8000ebc:	d0e4      	beq.n	8000e88 <vTaskDelay+0x4>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8000ebe:	bd10      	pop	{r4, pc}
 8000ec0:	20000500 	.word	0x20000500
 8000ec4:	2000051c 	.word	0x2000051c
 8000ec8:	20000504 	.word	0x20000504

08000ecc <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8000ecc:	4b17      	ldr	r3, [pc, #92]	; (8000f2c <vTaskSwitchContext+0x60>)

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8000ece:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8000ed0:	681a      	ldr	r2, [r3, #0]
 8000ed2:	4b17      	ldr	r3, [pc, #92]	; (8000f30 <vTaskSwitchContext+0x64>)
 8000ed4:	b10a      	cbz	r2, 8000eda <vTaskSwitchContext+0xe>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 8000ed6:	2201      	movs	r2, #1
 8000ed8:	e026      	b.n	8000f28 <vTaskSwitchContext+0x5c>
	}
	else
	{
		xYieldPending = pdFALSE;
 8000eda:	601a      	str	r2, [r3, #0]
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
 8000edc:	4815      	ldr	r0, [pc, #84]	; (8000f34 <vTaskSwitchContext+0x68>)
 8000ede:	4b16      	ldr	r3, [pc, #88]	; (8000f38 <vTaskSwitchContext+0x6c>)
 8000ee0:	2414      	movs	r4, #20
 8000ee2:	681a      	ldr	r2, [r3, #0]
 8000ee4:	4913      	ldr	r1, [pc, #76]	; (8000f34 <vTaskSwitchContext+0x68>)
 8000ee6:	4362      	muls	r2, r4
 8000ee8:	5882      	ldr	r2, [r0, r2]
 8000eea:	b942      	cbnz	r2, 8000efe <vTaskSwitchContext+0x32>
 8000eec:	681a      	ldr	r2, [r3, #0]
 8000eee:	b912      	cbnz	r2, 8000ef6 <vTaskSwitchContext+0x2a>
 8000ef0:	f000 f860 	bl	8000fb4 <ulPortSetInterruptMask>
 8000ef4:	e7fe      	b.n	8000ef4 <vTaskSwitchContext+0x28>
 8000ef6:	681a      	ldr	r2, [r3, #0]
 8000ef8:	3a01      	subs	r2, #1
 8000efa:	601a      	str	r2, [r3, #0]
 8000efc:	e7f1      	b.n	8000ee2 <vTaskSwitchContext+0x16>
 8000efe:	4b0e      	ldr	r3, [pc, #56]	; (8000f38 <vTaskSwitchContext+0x6c>)
 8000f00:	681a      	ldr	r2, [r3, #0]
 8000f02:	2314      	movs	r3, #20
 8000f04:	4353      	muls	r3, r2
 8000f06:	18c8      	adds	r0, r1, r3
 8000f08:	6844      	ldr	r4, [r0, #4]
 8000f0a:	3308      	adds	r3, #8
 8000f0c:	6864      	ldr	r4, [r4, #4]
 8000f0e:	440b      	add	r3, r1
 8000f10:	429c      	cmp	r4, r3
 8000f12:	bf08      	it	eq
 8000f14:	6863      	ldreq	r3, [r4, #4]
 8000f16:	6044      	str	r4, [r0, #4]
 8000f18:	bf08      	it	eq
 8000f1a:	6043      	streq	r3, [r0, #4]
 8000f1c:	2314      	movs	r3, #20
 8000f1e:	fb03 1202 	mla	r2, r3, r2, r1
 8000f22:	6853      	ldr	r3, [r2, #4]
 8000f24:	68da      	ldr	r2, [r3, #12]
 8000f26:	4b05      	ldr	r3, [pc, #20]	; (8000f3c <vTaskSwitchContext+0x70>)
 8000f28:	601a      	str	r2, [r3, #0]
 8000f2a:	bd10      	pop	{r4, pc}
 8000f2c:	20000500 	.word	0x20000500
 8000f30:	20000544 	.word	0x20000544
 8000f34:	2000049c 	.word	0x2000049c
 8000f38:	20000540 	.word	0x20000540
 8000f3c:	20000504 	.word	0x20000504

08000f40 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8000f40:	4805      	ldr	r0, [pc, #20]	; (8000f58 <prvPortStartFirstTask+0x18>)
 8000f42:	6800      	ldr	r0, [r0, #0]
 8000f44:	6800      	ldr	r0, [r0, #0]
 8000f46:	f380 8808 	msr	MSP, r0
 8000f4a:	b662      	cpsie	i
 8000f4c:	f3bf 8f4f 	dsb	sy
 8000f50:	f3bf 8f6f 	isb	sy
 8000f54:	df00      	svc	0
 8000f56:	bf00      	nop
 8000f58:	e000ed08 	.word	0xe000ed08

08000f5c <pxPortInitialiseStack>:
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8000f5c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 8000f60:	e900 000a 	stmdb	r0, {r1, r3}
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8000f64:	4b03      	ldr	r3, [pc, #12]	; (8000f74 <pxPortInitialiseStack+0x18>)
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8000f66:	f840 2c20 	str.w	r2, [r0, #-32]
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8000f6a:	f840 3c0c 	str.w	r3, [r0, #-12]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
 8000f6e:	3840      	subs	r0, #64	; 0x40
 8000f70:	4770      	bx	lr
 8000f72:	bf00      	nop
 8000f74:	08000fc5 	.word	0x08000fc5

08000f78 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8000f78:	4b07      	ldr	r3, [pc, #28]	; (8000f98 <pxCurrentTCBConst2>)
 8000f7a:	6819      	ldr	r1, [r3, #0]
 8000f7c:	6808      	ldr	r0, [r1, #0]
 8000f7e:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8000f82:	f380 8809 	msr	PSP, r0
 8000f86:	f3bf 8f6f 	isb	sy
 8000f8a:	f04f 0000 	mov.w	r0, #0
 8000f8e:	f380 8811 	msr	BASEPRI, r0
 8000f92:	f04e 0e0d 	orr.w	lr, lr, #13
 8000f96:	4770      	bx	lr

08000f98 <pxCurrentTCBConst2>:
 8000f98:	20000504 	.word	0x20000504

08000f9c <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8000f9c:	4b04      	ldr	r3, [pc, #16]	; (8000fb0 <vPortYield+0x14>)
 8000f9e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000fa2:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 8000fa4:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8000fa8:	f3bf 8f6f 	isb	sy
 8000fac:	4770      	bx	lr
 8000fae:	bf00      	nop
 8000fb0:	e000ed04 	.word	0xe000ed04

08000fb4 <ulPortSetInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) uint32_t ulPortSetInterruptMask( void )
{
	__asm volatile														\
 8000fb4:	f3ef 8011 	mrs	r0, BASEPRI
 8000fb8:	f04f 01ff 	mov.w	r1, #255	; 0xff
 8000fbc:	f381 8811 	msr	BASEPRI, r1
 8000fc0:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
}
 8000fc2:	2000      	movs	r0, #0

08000fc4 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8000fc4:	b508      	push	{r3, lr}
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8000fc6:	4b05      	ldr	r3, [pc, #20]	; (8000fdc <prvTaskExitError+0x18>)
 8000fc8:	681b      	ldr	r3, [r3, #0]
 8000fca:	3301      	adds	r3, #1
 8000fcc:	d002      	beq.n	8000fd4 <prvTaskExitError+0x10>
 8000fce:	f7ff fff1 	bl	8000fb4 <ulPortSetInterruptMask>
 8000fd2:	e7fe      	b.n	8000fd2 <prvTaskExitError+0xe>
	portDISABLE_INTERRUPTS();
 8000fd4:	f7ff ffee 	bl	8000fb4 <ulPortSetInterruptMask>
 8000fd8:	e7fe      	b.n	8000fd8 <prvTaskExitError+0x14>
 8000fda:	bf00      	nop
 8000fdc:	2000001c 	.word	0x2000001c

08000fe0 <vPortEnterCritical>:
	__asm volatile( "isb" );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 8000fe0:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
 8000fe2:	f7ff ffe7 	bl	8000fb4 <ulPortSetInterruptMask>
	uxCriticalNesting++;
 8000fe6:	4a04      	ldr	r2, [pc, #16]	; (8000ff8 <vPortEnterCritical+0x18>)
 8000fe8:	6813      	ldr	r3, [r2, #0]
 8000fea:	3301      	adds	r3, #1
 8000fec:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
 8000fee:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8000ff2:	f3bf 8f6f 	isb	sy
 8000ff6:	bd08      	pop	{r3, pc}
 8000ff8:	2000001c 	.word	0x2000001c

08000ffc <vPortClearInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( uint32_t ulNewMaskValue )
{
	__asm volatile													\
 8000ffc:	f380 8811 	msr	BASEPRI, r0
 8001000:	4770      	bx	lr
	...

08001004 <vPortExitCritical>:
	__asm volatile( "isb" );
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8001004:	b508      	push	{r3, lr}
	configASSERT( uxCriticalNesting );
 8001006:	4b07      	ldr	r3, [pc, #28]	; (8001024 <vPortExitCritical+0x20>)
 8001008:	6818      	ldr	r0, [r3, #0]
 800100a:	b910      	cbnz	r0, 8001012 <vPortExitCritical+0xe>
 800100c:	f7ff ffd2 	bl	8000fb4 <ulPortSetInterruptMask>
 8001010:	e7fe      	b.n	8001010 <vPortExitCritical+0xc>
	uxCriticalNesting--;
 8001012:	3801      	subs	r0, #1
 8001014:	6018      	str	r0, [r3, #0]
	if( uxCriticalNesting == 0 )
 8001016:	b918      	cbnz	r0, 8001020 <vPortExitCritical+0x1c>
	{
		portENABLE_INTERRUPTS();
	}
}
 8001018:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
	if( uxCriticalNesting == 0 )
	{
		portENABLE_INTERRUPTS();
 800101c:	f7ff bfee 	b.w	8000ffc <vPortClearInterruptMask>
 8001020:	bd08      	pop	{r3, pc}
 8001022:	bf00      	nop
 8001024:	2000001c 	.word	0x2000001c

08001028 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8001028:	f3ef 8009 	mrs	r0, PSP
 800102c:	f3bf 8f6f 	isb	sy
 8001030:	4b0d      	ldr	r3, [pc, #52]	; (8001068 <pxCurrentTCBConst>)
 8001032:	681a      	ldr	r2, [r3, #0]
 8001034:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001038:	6010      	str	r0, [r2, #0]
 800103a:	e92d 4008 	stmdb	sp!, {r3, lr}
 800103e:	f04f 00ff 	mov.w	r0, #255	; 0xff
 8001042:	f380 8811 	msr	BASEPRI, r0
 8001046:	f7ff ff41 	bl	8000ecc <vTaskSwitchContext>
 800104a:	f04f 0000 	mov.w	r0, #0
 800104e:	f380 8811 	msr	BASEPRI, r0
 8001052:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8001056:	6819      	ldr	r1, [r3, #0]
 8001058:	6808      	ldr	r0, [r1, #0]
 800105a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800105e:	f380 8809 	msr	PSP, r0
 8001062:	f3bf 8f6f 	isb	sy
 8001066:	4770      	bx	lr

08001068 <pxCurrentTCBConst>:
 8001068:	20000504 	.word	0x20000504

0800106c <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 800106c:	b508      	push	{r3, lr}
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
 800106e:	f7ff ffa1 	bl	8000fb4 <ulPortSetInterruptMask>
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8001072:	f7ff fe13 	bl	8000c9c <xTaskIncrementTick>
 8001076:	b118      	cbz	r0, 8001080 <SysTick_Handler+0x14>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8001078:	4b04      	ldr	r3, [pc, #16]	; (800108c <SysTick_Handler+0x20>)
 800107a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800107e:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8001080:	2000      	movs	r0, #0
}
 8001082:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8001086:	f7ff bfb9 	b.w	8000ffc <vPortClearInterruptMask>
 800108a:	bf00      	nop
 800108c:	e000ed04 	.word	0xe000ed04

08001090 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8001090:	4b06      	ldr	r3, [pc, #24]	; (80010ac <vPortSetupTimerInterrupt+0x1c>)
 8001092:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8001096:	681b      	ldr	r3, [r3, #0]
 8001098:	fbb3 f3f2 	udiv	r3, r3, r2
 800109c:	4a04      	ldr	r2, [pc, #16]	; (80010b0 <vPortSetupTimerInterrupt+0x20>)
 800109e:	3b01      	subs	r3, #1
 80010a0:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 80010a2:	4b04      	ldr	r3, [pc, #16]	; (80010b4 <vPortSetupTimerInterrupt+0x24>)
 80010a4:	2207      	movs	r2, #7
 80010a6:	601a      	str	r2, [r3, #0]
 80010a8:	4770      	bx	lr
 80010aa:	bf00      	nop
 80010ac:	20000014 	.word	0x20000014
 80010b0:	e000e014 	.word	0xe000e014
 80010b4:	e000e010 	.word	0xe000e010

080010b8 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 80010b8:	b513      	push	{r0, r1, r4, lr}
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 80010ba:	4b1e      	ldr	r3, [pc, #120]	; (8001134 <xPortStartScheduler+0x7c>)
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80010bc:	2100      	movs	r1, #0
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 80010be:	781a      	ldrb	r2, [r3, #0]
 80010c0:	b2d2      	uxtb	r2, r2
 80010c2:	9201      	str	r2, [sp, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 80010c4:	22ff      	movs	r2, #255	; 0xff
 80010c6:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 80010c8:	781b      	ldrb	r3, [r3, #0]
 80010ca:	b2db      	uxtb	r3, r3
 80010cc:	f88d 3003 	strb.w	r3, [sp, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80010d0:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80010d4:	4b18      	ldr	r3, [pc, #96]	; (8001138 <xPortStartScheduler+0x80>)
 80010d6:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80010d8:	4b18      	ldr	r3, [pc, #96]	; (800113c <xPortStartScheduler+0x84>)
 80010da:	2207      	movs	r2, #7
 80010dc:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80010de:	f89d 0003 	ldrb.w	r0, [sp, #3]
 80010e2:	1e54      	subs	r4, r2, #1
 80010e4:	0600      	lsls	r0, r0, #24
 80010e6:	d508      	bpl.n	80010fa <xPortStartScheduler+0x42>
		{
			ulMaxPRIGROUPValue--;
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 80010e8:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80010ec:	2101      	movs	r1, #1
 80010ee:	0052      	lsls	r2, r2, #1
 80010f0:	b2d2      	uxtb	r2, r2
 80010f2:	f88d 2003 	strb.w	r2, [sp, #3]
 80010f6:	4622      	mov	r2, r4
 80010f8:	e7f1      	b.n	80010de <xPortStartScheduler+0x26>
 80010fa:	b101      	cbz	r1, 80010fe <xPortStartScheduler+0x46>
 80010fc:	601a      	str	r2, [r3, #0]
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 80010fe:	681a      	ldr	r2, [r3, #0]
 8001100:	0212      	lsls	r2, r2, #8
 8001102:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8001106:	601a      	str	r2, [r3, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8001108:	9b01      	ldr	r3, [sp, #4]
 800110a:	4a0a      	ldr	r2, [pc, #40]	; (8001134 <xPortStartScheduler+0x7c>)
 800110c:	b2db      	uxtb	r3, r3
 800110e:	7013      	strb	r3, [r2, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8001110:	4b0b      	ldr	r3, [pc, #44]	; (8001140 <xPortStartScheduler+0x88>)
 8001112:	681a      	ldr	r2, [r3, #0]
 8001114:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8001118:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 800111a:	681a      	ldr	r2, [r3, #0]
 800111c:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 8001120:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 8001122:	f7ff ffb5 	bl	8001090 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8001126:	4b07      	ldr	r3, [pc, #28]	; (8001144 <xPortStartScheduler+0x8c>)
 8001128:	2200      	movs	r2, #0
 800112a:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 800112c:	f7ff ff08 	bl	8000f40 <prvPortStartFirstTask>

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
 8001130:	f7ff ff48 	bl	8000fc4 <prvTaskExitError>
 8001134:	e000e400 	.word	0xe000e400
 8001138:	20000548 	.word	0x20000548
 800113c:	2000054c 	.word	0x2000054c
 8001140:	e000ed20 	.word	0xe000ed20
 8001144:	2000001c 	.word	0x2000001c

08001148 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8001148:	b538      	push	{r3, r4, r5, lr}
 800114a:	4604      	mov	r4, r0
void *pvReturn = NULL;
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 800114c:	0743      	lsls	r3, r0, #29
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800114e:	bf1c      	itt	ne
 8001150:	f020 0407 	bicne.w	r4, r0, #7
 8001154:	3408      	addne	r4, #8
		}
	#endif

	vTaskSuspendAll();
 8001156:	f7ff fd99 	bl	8000c8c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 800115a:	4a0c      	ldr	r2, [pc, #48]	; (800118c <pvPortMalloc+0x44>)
 800115c:	6813      	ldr	r3, [r2, #0]
 800115e:	b91b      	cbnz	r3, 8001168 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
 8001160:	4b0b      	ldr	r3, [pc, #44]	; (8001190 <pvPortMalloc+0x48>)
 8001162:	f023 0307 	bic.w	r3, r3, #7
 8001166:	6013      	str	r3, [r2, #0]
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8001168:	f640 70f7 	movw	r0, #4087	; 0xff7
 800116c:	4909      	ldr	r1, [pc, #36]	; (8001194 <pvPortMalloc+0x4c>)
 800116e:	680b      	ldr	r3, [r1, #0]
 8001170:	441c      	add	r4, r3
 8001172:	4284      	cmp	r4, r0
 8001174:	d805      	bhi.n	8001182 <pvPortMalloc+0x3a>
 8001176:	42a3      	cmp	r3, r4
 8001178:	d203      	bcs.n	8001182 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 800117a:	6815      	ldr	r5, [r2, #0]
			xNextFreeByte += xWantedSize;
 800117c:	600c      	str	r4, [r1, #0]
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 800117e:	441d      	add	r5, r3
 8001180:	e000      	b.n	8001184 <pvPortMalloc+0x3c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 8001182:	2500      	movs	r5, #0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}	
	xTaskResumeAll();
 8001184:	f7ff fe18 	bl	8000db8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 8001188:	4628      	mov	r0, r5
 800118a:	bd38      	pop	{r3, r4, r5, pc}
 800118c:	20000554 	.word	0x20000554
 8001190:	20000560 	.word	0x20000560
 8001194:	20000550 	.word	0x20000550

08001198 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 8001198:	b508      	push	{r3, lr}
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
 800119a:	b110      	cbz	r0, 80011a2 <vPortFree+0xa>
 800119c:	f7ff ff0a 	bl	8000fb4 <ulPortSetInterruptMask>
 80011a0:	e7fe      	b.n	80011a0 <vPortFree+0x8>
 80011a2:	bd08      	pop	{r3, pc}

080011a4 <register_fini>:
 80011a4:	4b02      	ldr	r3, [pc, #8]	; (80011b0 <register_fini+0xc>)
 80011a6:	b113      	cbz	r3, 80011ae <register_fini+0xa>
 80011a8:	4802      	ldr	r0, [pc, #8]	; (80011b4 <register_fini+0x10>)
 80011aa:	f000 b805 	b.w	80011b8 <atexit>
 80011ae:	4770      	bx	lr
 80011b0:	00000000 	.word	0x00000000
 80011b4:	080011c5 	.word	0x080011c5

080011b8 <atexit>:
 80011b8:	2300      	movs	r3, #0
 80011ba:	4601      	mov	r1, r0
 80011bc:	461a      	mov	r2, r3
 80011be:	4618      	mov	r0, r3
 80011c0:	f000 b814 	b.w	80011ec <__register_exitproc>

080011c4 <__libc_fini_array>:
 80011c4:	b538      	push	{r3, r4, r5, lr}
 80011c6:	4d07      	ldr	r5, [pc, #28]	; (80011e4 <__libc_fini_array+0x20>)
 80011c8:	4c07      	ldr	r4, [pc, #28]	; (80011e8 <__libc_fini_array+0x24>)
 80011ca:	1b2c      	subs	r4, r5, r4
 80011cc:	10a4      	asrs	r4, r4, #2
 80011ce:	d005      	beq.n	80011dc <__libc_fini_array+0x18>
 80011d0:	3c01      	subs	r4, #1
 80011d2:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 80011d6:	4798      	blx	r3
 80011d8:	2c00      	cmp	r4, #0
 80011da:	d1f9      	bne.n	80011d0 <__libc_fini_array+0xc>
 80011dc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80011e0:	f000 b85c 	b.w	800129c <_fini>
 80011e4:	080012c8 	.word	0x080012c8
 80011e8:	080012c4 	.word	0x080012c4

080011ec <__register_exitproc>:
 80011ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80011f0:	4c25      	ldr	r4, [pc, #148]	; (8001288 <__register_exitproc+0x9c>)
 80011f2:	4606      	mov	r6, r0
 80011f4:	6825      	ldr	r5, [r4, #0]
 80011f6:	4688      	mov	r8, r1
 80011f8:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
 80011fc:	4692      	mov	sl, r2
 80011fe:	4699      	mov	r9, r3
 8001200:	b3c4      	cbz	r4, 8001274 <__register_exitproc+0x88>
 8001202:	6860      	ldr	r0, [r4, #4]
 8001204:	281f      	cmp	r0, #31
 8001206:	dc17      	bgt.n	8001238 <__register_exitproc+0x4c>
 8001208:	1c41      	adds	r1, r0, #1
 800120a:	b176      	cbz	r6, 800122a <__register_exitproc+0x3e>
 800120c:	eb04 0380 	add.w	r3, r4, r0, lsl #2
 8001210:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
 8001214:	f8d4 5188 	ldr.w	r5, [r4, #392]	; 0x188
 8001218:	2201      	movs	r2, #1
 800121a:	4082      	lsls	r2, r0
 800121c:	4315      	orrs	r5, r2
 800121e:	2e02      	cmp	r6, #2
 8001220:	f8c4 5188 	str.w	r5, [r4, #392]	; 0x188
 8001224:	f8c3 9108 	str.w	r9, [r3, #264]	; 0x108
 8001228:	d01e      	beq.n	8001268 <__register_exitproc+0x7c>
 800122a:	1c83      	adds	r3, r0, #2
 800122c:	6061      	str	r1, [r4, #4]
 800122e:	2000      	movs	r0, #0
 8001230:	f844 8023 	str.w	r8, [r4, r3, lsl #2]
 8001234:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001238:	4b14      	ldr	r3, [pc, #80]	; (800128c <__register_exitproc+0xa0>)
 800123a:	b303      	cbz	r3, 800127e <__register_exitproc+0x92>
 800123c:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8001240:	f3af 8000 	nop.w
 8001244:	4604      	mov	r4, r0
 8001246:	b1d0      	cbz	r0, 800127e <__register_exitproc+0x92>
 8001248:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
 800124c:	2700      	movs	r7, #0
 800124e:	e884 0088 	stmia.w	r4, {r3, r7}
 8001252:	4638      	mov	r0, r7
 8001254:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8001258:	2101      	movs	r1, #1
 800125a:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
 800125e:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
 8001262:	2e00      	cmp	r6, #0
 8001264:	d0e1      	beq.n	800122a <__register_exitproc+0x3e>
 8001266:	e7d1      	b.n	800120c <__register_exitproc+0x20>
 8001268:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
 800126c:	431a      	orrs	r2, r3
 800126e:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
 8001272:	e7da      	b.n	800122a <__register_exitproc+0x3e>
 8001274:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
 8001278:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 800127c:	e7c1      	b.n	8001202 <__register_exitproc+0x16>
 800127e:	f04f 30ff 	mov.w	r0, #4294967295
 8001282:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001286:	bf00      	nop
 8001288:	080012b8 	.word	0x080012b8
 800128c:	00000000 	.word	0x00000000

08001290 <_init>:
 8001290:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001292:	bf00      	nop
 8001294:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001296:	bc08      	pop	{r3}
 8001298:	469e      	mov	lr, r3
 800129a:	4770      	bx	lr

0800129c <_fini>:
 800129c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800129e:	bf00      	nop
 80012a0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80012a2:	bc08      	pop	{r3}
 80012a4:	469e      	mov	lr, r3
 80012a6:	4770      	bx	lr
